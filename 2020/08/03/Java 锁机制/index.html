<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Java 锁机制 | 潜心做事</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Java,线程安全,锁," />
  

  <meta name="description" content="java.util.concurrent.locks 包下的常用类interface Lock12345678public interface Lock &amp;#123;    void lock();    void lockInterruptibly() throws InterruptedException;    boolean tryLock();    boolean tryLock(lo">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 锁机制">
<meta property="og:url" content="https://zhouxelf.com/2020/08/03/Java%20%E9%94%81%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="潜心做事">
<meta property="og:description" content="java.util.concurrent.locks 包下的常用类interface Lock12345678public interface Lock &amp;#123;    void lock();    void lockInterruptibly() throws InterruptedException;    boolean tryLock();    boolean tryLock(lo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhouxelf.com/images/%E8%87%AA%E9%80%89%E9%94%81.png">
<meta property="og:image" content="https://zhouxelf.com/images/%E9%94%81.png">
<meta property="article:published_time" content="2020-08-03T12:03:03.000Z">
<meta property="article:modified_time" content="2021-04-21T15:32:29.594Z">
<meta property="article:author" content="zhouxelf">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="线程安全">
<meta property="article:tag" content="锁">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhouxelf.com/images/%E8%87%AA%E9%80%89%E9%94%81.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/personal-style.css">

  

  

  

  


  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">导航</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">导航</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java-util-concurrent-locks-%E5%8C%85%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">java.util.concurrent.locks 包下的常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#interface-Lock"><span class="toc-text">interface Lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class-ReentrantLock"><span class="toc-text">class ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interface-ReadWriteLock"><span class="toc-text">interface ReadWriteLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class-ReentrantReadWriteLock"><span class="toc-text">class ReentrantReadWriteLock</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="toc-text">锁的相关概念介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81-vs-%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">乐观锁 vs 悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81-vs-%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">自旋锁 vs 适应性自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%94%81-vs-%E5%81%8F%E5%90%91%E9%94%81-vs-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-vs-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">无锁 vs 偏向锁 vs 轻量级锁 vs 重量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-vs-%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-text">可重入锁 vs 非可重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81-vs-%E9%9D%9E%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81"><span class="toc-text">可中断锁 vs 非可中断锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81-vs-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">公平锁 vs 非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">读写锁</span></a></li></ol></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Java 锁机制" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Java 锁机制</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2020.08.03</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>zhouxelf</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="java-util-concurrent-locks-包下的常用类"><a href="#java-util-concurrent-locks-包下的常用类" class="headerlink" title="java.util.concurrent.locks 包下的常用类"></a>java.util.concurrent.locks 包下的常用类</h1><h3 id="interface-Lock"><a href="#interface-Lock" class="headerlink" title="interface Lock"></a>interface Lock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取锁</strong></p>
<ul>
<li>lock()</li>
<li>tryLock()</li>
<li>tryLock(long time, TimeUnit unit)</li>
<li>lockInterruptibly()</li>
</ul>
<p><strong>释放锁</strong></p>
<ul>
<li>unlock()</li>
</ul>
<p>lock() 获取锁最常用的一个方法，<code>如果获取的锁已被其它线程获取，则进行等待</code>。采用 Lock，必须主动释放锁，并且发生异常时，不会自动释放锁，因此 <code>Lock 必须在 try catch 块中进行，并且释放锁的操作放在 finally 块中进行</code>，以保证锁一定被释放，防止死锁的发生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryLock() 方法是<code>有返回值的</code>，表示尝试获取锁，如果获取成功，返回 true，如果获取失败(即锁已被其它线程获取)，则返回 false，这个方法无论如何都会<code>立即返回，在拿不到锁时不会一直等待</code>。</p>
<p>tryLock(long time, TimeUnit unit) 和 tryLock() 类似，也有返回值，区别在于这个方法<code>拿不到锁时会等待一定时间</code>，在这个时间内如果还拿不到，则返回 false，如果一开始或者等待期间拿到了锁，就返回 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"><span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 业务代码</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取锁失败，处理其它业务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lockInterruptibly() 方法比较特殊，当通过这个方法去获取锁时，<code>如果线程正在等待获取锁，则这个线程能够响应中断</code>。比如：当两个线程同时通过 lockInterruptibly() 获取某个锁时，假如线程 A 获取到了锁，而线程 B 只能等待，那么对线程 B 调用 Thread.interrupt() 方法能够中断线程 B 的等待过程。</p>
<p>由于 lockInterruptibly() 的声明中抛出了异常，所以 lockInterruptibly() 必须放在 try catch 块中或者在调用 lockInterruptibly() 的方法外声明抛出 InterruptedException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> method <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Lock lock = ...;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 业务代码</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 当一个线程获取了锁之后，是不会被 interrupt() 方法中断的，单独调用 interrupt() 只能中断阻塞过程中的线程，不能中断正在运行过程中的线程。</p>
</blockquote>
<p>因此通过 lockInterruptibly() 方法获取某个锁时，如果获取不到，只能等待，在进行等待的情况下，是可以响应中断的。</p>
<p>用 synchronized 修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待。</p>
<h3 id="class-ReentrantLock"><a href="#class-ReentrantLock" class="headerlink" title="class ReentrantLock"></a>class ReentrantLock</h3><p>ReentrantLock 可重入锁，它是唯一实现了 Lock 接口的类，并且提供了更多的方法。</p>
<p><strong>lock()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();  <span class="comment">// lock 是成员变量生效</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Lock lock = new ReentrantLock();  // lock 是局部变量不生效</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot;获取了锁&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LockTest lt = <span class="keyword">new</span> LockTest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                lt.insert(Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                lt.insert(Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>tryLock()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(thread.getName() + <span class="string">&quot;获取了锁&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                    arrayList.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// TODO</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot;获取锁失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> TryLockTest tlt = <span class="keyword">new</span> TryLockTest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                tlt.insert(Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                tlt.insert(Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>lockInterruptibly()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LockInterruptiblyTest ltt = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(LockInterruptiblyTest ltt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ltt = ltt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ltt.insert(Thread.currentThread());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;被中断&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockInterruptiblyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// tips: 如果需要正确中断等待锁的进程，必须将锁放到外面，然后将 InterruptedException 抛出</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot;获取了锁&quot;</span>);</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() - start &gt;= Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行 finally&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockInterruptiblyTest ltt = <span class="keyword">new</span> LockInterruptiblyTest();</span><br><span class="line">        MyThread thread_1 = <span class="keyword">new</span> MyThread(ltt);</span><br><span class="line">        MyThread thread_2 = <span class="keyword">new</span> MyThread(ltt);</span><br><span class="line">        thread_1.start();</span><br><span class="line">        thread_2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中断等待的进程</span></span><br><span class="line">        thread_2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="interface-ReadWriteLock"><a href="#interface-ReadWriteLock" class="headerlink" title="interface ReadWriteLock"></a>interface ReadWriteLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReadWriteLock 接口定义了两个方法，<code>一个来获取读锁，一个来获取写锁，也就是说将文件的读写操作分开，分成两个锁来分配给线程，从而使得多个线程可以同时进行读操作</code>。</p>
<h3 id="class-ReentrantReadWriteLock"><a href="#class-ReentrantReadWriteLock" class="headerlink" title="class ReentrantReadWriteLock"></a>class ReentrantReadWriteLock</h3><p>ReentrantReadWriteLock 提供了丰富的方法，最主要的方法有两个，用来获取读锁和写锁。</p>
<ul>
<li>readLock()</li>
<li>writeLock()</li>
</ul>
<p><strong>多个线程同时读操作，synchronized 的效果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadReadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (System.currentTimeMillis() - start &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot;正在进行读操作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;读操作完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReadReadTest rrt = <span class="keyword">new</span> ReadReadTest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rrt.read(Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rrt.read(Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多个线程同时读操作，ReentrantReadWriteLock 的效果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rrwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        rrwl.readLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">while</span> (System.currentTimeMillis() - start &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(thread.getName() + <span class="string">&quot;正在进行读操作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot;读操作完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rrwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantReadWriteLockTest rrwlt = <span class="keyword">new</span> ReentrantReadWriteLockTest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rrwlt.read(Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rrwlt.read(Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>如果一个线程占用了读锁，其它线程申请写锁，申请线程会一直等待释放读锁。</li>
<li>如果一个线程占用了写锁，其它线程申请读锁或写锁，申请线程会一直等待释放写锁。</li>
</ol>
<p><strong>Lock 和 synchronized 的选择</strong></p>
<ol>
<li>Lock 是一个接口，而 synchronized 是 Java 中的关键字，是内置的语言实现。</li>
<li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会发生死锁现象；而 Lock 在发生异常时，如果没有主动通过 unlock() 释放锁，则很可能发生死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。</li>
<li>Lock 可以让等待锁的线程响应中断 lockInterruptibly()，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。</li>
<li>通过 Lock() 可以知道有没有获取到锁，synchronized 不行。</li>
<li>Lock 可以提高多个线程进行读操作的效率。</li>
</ol>
<p><code>在性能来说，如果竞争资源不激烈，二者的性能是差不多的，而当竞争资源非常激烈时(即有大量线程同步竞争)，此时 Lock 的性能要远远由于 synchronized，所以说，在具体使用时要根据适当情况选择。</code></p>
<h1 id="锁的相关概念介绍"><a href="#锁的相关概念介绍" class="headerlink" title="锁的相关概念介绍"></a>锁的相关概念介绍</h1><h3 id="乐观锁-vs-悲观锁"><a href="#乐观锁-vs-悲观锁" class="headerlink" title="乐观锁 vs 悲观锁"></a>乐观锁 vs 悲观锁</h3><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。</p>
<p>悲观锁: 对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p>
<p>在 Java 中，<code>synchronized 关键字和 Lock 的实现类都是悲观锁</code>。</p>
<p>乐观锁: 认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作(例如报错或者自动重试)。</p>
<p>在 Java 中, <code>乐观锁是通过使用无锁编程来实现，最常采用的是 CAS 算法(Compare And Swap)，Java 原子类中的递增操作就通过 CAS 自旋实现的</code>。</p>
<h3 id="自旋锁-vs-适应性自旋锁"><a href="#自旋锁-vs-适应性自旋锁" class="headerlink" title="自旋锁 vs 适应性自旋锁"></a>自旋锁 vs 适应性自旋锁</h3><p>阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃 CPU 的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而<code>为了让当前线程 “稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销，这就是自旋锁</code>。</p>
<p><img src="/images/%E8%87%AA%E9%80%89%E9%94%81.png"></p>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。<code>如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源</code>。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数(默认是10次，可以使用 -XX:PreBlockSpin 来更改)没有成功获得锁，就应当挂起线程。</p>
<p><code>自旋锁的实现原理同样也是 CAS</code>，AtomicInteger 中调用 unsafe 进行自增操作的源码中的 do-while 循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>
<p>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。<code>JDK 6 中变为默认开启</code>，并且引入了自适应的自旋锁(适应性自旋锁)。</p>
<p><code>自适应意味着自旋的时间(次数)不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</code>。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<h3 id="无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁"><a href="#无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁" class="headerlink" title="无锁 vs 偏向锁 vs 轻量级锁 vs 重量级锁"></a>无锁 vs 偏向锁 vs 轻量级锁 vs 重量级锁</h3><p>这四种锁是指锁的状态，专门针对 synchronized 的。</p>
<p><strong>无锁</strong></p>
<p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>上面我们介绍的 CAS 原理及应用即是无锁的实现，无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>
<p><strong>偏向锁</strong></p>
<p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁，其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p><code>偏向锁在 JDK 6 及以后的 JVM 里是默认启用的</code>。可以通过 JVM 参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>
<p><strong>轻量级锁</strong></p>
<p>指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<p>若当前只有一个等待线程，则该线程通过自旋进行等待，但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>
<p><strong>重量级锁</strong></p>
<p>升级为重量级锁时，锁标志的状态值变为 “10”，此时 Mark Word 中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>
<p><img src="/images/%E9%94%81.png"></p>
<h3 id="可重入锁-vs-非可重入锁"><a href="#可重入锁-vs-非可重入锁" class="headerlink" title="可重入锁 vs 非可重入锁"></a>可重入锁 vs 非可重入锁</h3><p>如果锁具备可重入性，则称作为可重入锁，<code>sychronized 和 ReentrantLock 都是可重入锁</code>。</p>
<p><strong>可重入性实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。</strong></p>
<p>举个栗子，当一个线程执行到某个 synchronized 方法时，比如 method_1，而 method_1 中会调用另一个 synchronized 方法 method_2，此时线程不必重新去申请锁，而是可以直接执行方法 method_2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title">method_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method_2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title">method_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面类的两个方法都被 synchronized 修饰了，假如某一时刻，线程 A 执行到了 method_1，此时线程获取了这个对象的锁，而由于 method_2 也是 synchronized 方法，假如 synchronized 不具备可重入性，此时线程 A 需要重新申请锁。但是这就会造成一个问题，因为线程 A 已经持有了该对象的锁，现在又要获取该对象的锁，这样线程 A 就会一直等待永远获取不到锁。</p>
<p>由于 synchronized 和 Lock 都具备可重入性，所以不会发生上述现象。</p>
<h3 id="可中断锁-vs-非可中断锁"><a href="#可中断锁-vs-非可中断锁" class="headerlink" title="可中断锁 vs 非可中断锁"></a>可中断锁 vs 非可中断锁</h3><p>可中断锁，顾名思义，就是可以响应中断的锁。</p>
<p>线程 A 获取了锁正在执行代码，线程 B 正在等待获取锁，由于等待时间过长不想等了，想先处理其它事情，如果可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p>
<p>在 Java 中，<code>synchronized 是不可中断锁，Lock 是可中断锁</code>。</p>
<p>Lock 中 lockInterruptibly() 方法体现了可中断性。</p>
<h3 id="公平锁-vs-非公平锁"><a href="#公平锁-vs-非公平锁" class="headerlink" title="公平锁 vs 非公平锁"></a>公平锁 vs 非公平锁</h3><p>公平锁：尽量以线程请求锁的顺序来分配锁，比如同时有多个线程在等待一个锁，当这个锁被释放时，等待最久的线程会获得该锁，这就是公平锁。</p>
<p>非公平锁：无法保证以线程请求锁的顺序来分配锁，可能导致某个或者一些线程永远获取不到锁。</p>
<p>在 Java 中，<code>synchronized 就是非公平锁</code>，它无法保证等待的线程获取锁的顺序。</p>
<p><code>ReentrantLock 和 ReentrantReadWriteLock，默认是非公平锁，可以设置为公平锁</code>。</p>
<p>在 ReentrantLock 中定义了 2 个静态内部类，一个是 NotFairSync，一个是 FairSync ，分别用来实现非公平锁和公平锁。</p>
<p>ReentrantLock 类中定义了很多方法，比如：</p>
<ul>
<li>isFair() 判断锁是否公平锁</li>
<li>isLocked() 判断锁是否被某线程获取了</li>
<li>isHeldByCurrentThread() 判断锁是否被当前线程获取了</li>
<li>hasQueuedThreads() 判断是否有线程在等待该锁</li>
</ul>
<blockquote>
<p>tips: 在 ReentrantReadWriteLock 中也有类似的方法，同样也可以设置为公平锁和非公平锁，不过要记住，ReentrantReadWriteLock 并未实现 Lock 接口，它实现的 是ReadWriteLock 接口。</p>
</blockquote>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁将对一个资源的访问分成了 2 个锁，一个读锁和一个写锁。因为有了读写锁，使得多个线程之间的读操作不会发生冲突。</p>
<p><code>ReadWriteLock 就是读写锁，它是一个接口，ReentrantReadWriteLock 实现了这个接口</code>。</p>
<p>通过 readLock() 获取读锁，通过 writeLock() 获取写锁。</p>
<p><br><br></p>

    
  </div>

</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2020/05/07/Java%20%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2020/11/13/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
  <section id="changyan-comments">
    <div id="SOHUCS" sid="Java 锁机制"></div>
    <script charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/changyan.js" ></script>
    <script type="text/javascript">
      window.changyan.api.config({
        appid: 'cyt7l11BM',
        conf: 'prod_a98ea73c3a76aca2a1fbc73edb66a25d'
      });
    </script>
  </section>

    

    

    
    

    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
