[{"title":"Java 线程池原理分析","url":"https://zhouxelf.com/2021/03/21/Java 线程池原理分析/","content":"<h1 id=\"线程池类图\"><a href=\"#线程池类图\" class=\"headerlink\" title=\"线程池类图\"></a>线程池类图</h1><p><img src=\"/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E5%9B%BE.png\"></p>\n<ul>\n<li>Executor 接口提供一种思想：将任务提交和任务执行进行解耦。用户只需提供 Runnable 对象，将任务的运行逻辑提交到执行器(Executor)中，由 Executor 框架完成线程的调配和任务的执行部分。</li>\n<li>ExecutorService 接口增加了一些能力：1&gt; 扩充执行任务的能力，补充可以为一个或一批异步任务生成 Future 的方法，(比如 submit 方法)；2&gt; 提供了管控线程池的方法，比如停止线程池的运行(shutdown)。</li>\n<li>AbstractExecutorService 则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。</li>\n<li>最下层的实现类 ThreadPoolExecutor 将会一方面维护自身的生命周期，另一方面同时管理线程和任务。</li>\n</ul>\n<h1 id=\"线程池创建方式\"><a href=\"#线程池创建方式\" class=\"headerlink\" title=\"线程池创建方式\"></a>线程池创建方式</h1><ul>\n<li>Executors.newFixedThreadPool() 创建固定大小的线程池</li>\n<li>Executors.newSingleThreadExecutor() 创建单个线程的线程池</li>\n<li>Executors.newCachedThreadPool() 无限线程池</li>\n<li>Executors.newScheduledThreadPool() 创建一个定长线程池，支持定时及周期性任务执行</li>\n</ul>\n<p>以上实际调用到 ThreadPoolExecutor 类</p>\n<ul>\n<li>JDK8 Executors.newWorkStealingPool() 根据所需的并发数来动态创建和关闭线程</li>\n</ul>\n<h1 id=\"ThreadPoolExecutor-分析\"><a href=\"#ThreadPoolExecutor-分析\" class=\"headerlink\" title=\"ThreadPoolExecutor 分析\"></a>ThreadPoolExecutor 分析</h1><p>线程池运行流程图</p>\n<p><img src=\"/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png\"></p>\n<h2 id=\"创建-ThreadPoolExecutor\"><a href=\"#创建-ThreadPoolExecutor\" class=\"headerlink\" title=\"创建 ThreadPoolExecutor\"></a>创建 ThreadPoolExecutor</h2><p><img src=\"/images/ThreadPoolExecutor.png\"></p>\n<ul>\n<li>corePoolSize 线程池的基本大小</li>\n<li>maximumPoolSize 线程池最大线程大小</li>\n<li>keepAliveTime 和 unit 则是线程空闲后的存活时间</li>\n<li>workQueue 用于存放任务的阻塞队列</li>\n<li>handler 当队列和最大线程池都满了之后的饱和策略</li>\n</ul>\n<h2 id=\"线程池生命周期\"><a href=\"#线程池生命周期\" class=\"headerlink\" title=\"线程池生命周期\"></a>线程池生命周期</h2><p>关键属性 ctl(AtomicInteger) 表示为线程池控制状态，它是一个被两个字段 workerCount(工作线程数量)、runState(线程池运行状态) 打包成的原子 Integer。</p>\n<ul>\n<li>workerCount 存储在 Integer 的后 29 位，所以 workerCount 的最大值是 2^29 - 1(大概 5 亿)，而不是 2^32 - 1(大概 20 亿)。</li>\n<li>runState 存储在 Integer 的前 3 位，有 RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED 共 5 个状态。</li>\n</ul>\n<p><img src=\"/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png\"></p>\n<ul>\n<li>RUNNING 自然是运行状态，指可以接受任务执行队列里的任务</li>\n<li>SHUTDOWN 指调用了 shutdown() 方法，不再接受新任务了，但是队列里的任务得执行完毕</li>\n<li>STOP 指调用了 shutdownNow() 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务</li>\n<li>TIDYING 所有任务都执行完毕，在调用 shutdown()、shutdownNow() 时都会尝试更新为这个状态</li>\n<li>TERMINATED 终止状态，当执行 terminated() 后会更新为这个状态</li>\n</ul>\n<h2 id=\"任务管理\"><a href=\"#任务管理\" class=\"headerlink\" title=\"任务管理\"></a>任务管理</h2><p>任务管理是指，通过检查现在线程池的运行状态、运行线程数、运行策略，来决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。</p>\n<h3 id=\"任务的调度\"><a href=\"#任务的调度\" class=\"headerlink\" title=\"任务的调度\"></a>任务的调度</h3><p><img src=\"/images/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6.png\"></p>\n<p>一种是任务直接由新创建的线程执行，另一种是线程从任务队列中获取任务然后执行。</p>\n<p><img src=\"/images/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6_2.png\"></p>\n<ol>\n<li>获取当前线程池的状态；</li>\n<li>当前线程数量小于 coreSize 时创建一个新的线程运行；</li>\n<li>如果当前线程处于运行状态，并且写入阻塞队列成功；</li>\n<li>双重检查，再次获取线程状态：如果线程状态变了(非运行状态)就需要从阻塞队列移除任务，并尝试判断线程是否全部执行完毕，同时执行拒绝策略；</li>\n<li>如果当前线程池为空就新创建一个线程并执行；</li>\n<li>如果在第 3 步的判断为非运行状态，尝试新建线程，如果失败则执行拒绝策略。</li>\n</ol>\n<h3 id=\"任务的执行\"><a href=\"#任务的执行\" class=\"headerlink\" title=\"任务的执行\"></a>任务的执行</h3><p><img src=\"/images/%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C.png\"></p>\n<p>增加 worker ==&gt; new worker ==&gt; worker 的 run() ==&gt; worker 的 runWorker ==&gt; 线程的执行</p>\n<p><img src=\"/images/%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C_2.png\"></p>\n<p>循环获取 task 进行执行，见任务的申请</p>\n<p><img src=\"/images/%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C_3.png\"></p>\n<h3 id=\"任务的申请\"><a href=\"#任务的申请\" class=\"headerlink\" title=\"任务的申请\"></a>任务的申请</h3><p>线程从任务缓存模块中不断地取任务执行，实现线程管理模块和任务管理模块之间的通信。</p>\n<p><img src=\"/images/%E4%BB%BB%E5%8A%A1%E7%94%B3%E8%AF%B7.png\"></p>\n<p>getTask 这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回 null 值。工作线程 Worker 会不断接收新任务去执行，而当工作线程 Worker 接收不到任务的时候，就会开始被回收。</p>\n<p><img src=\"/images/%E4%BB%BB%E5%8A%A1%E7%94%B3%E8%AF%B7_2.png\"></p>\n<ul>\n<li>线程是可回收：调用队列的 poll(long timeout, TimeUnit unit) 方法，检索并且删除队列的头元素，如果没有足够的空间，就等待到指定的等待时间。</li>\n<li>线程是不可回收的：调用队列的 take() 方法，检索并且删除队列的头元素，如果没有足够的空间，就等待。</li>\n</ul>\n<h3 id=\"任务的拒绝\"><a href=\"#任务的拒绝\" class=\"headerlink\" title=\"任务的拒绝\"></a>任务的拒绝</h3><p><img src=\"/images/%E4%BB%BB%E5%8A%A1%E6%8B%92%E7%BB%9D.png\"></p>\n<ul>\n<li>ThreadPoolExecutor.AbortPolicy 线程池的默认拒绝策略，也是ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 的默认拒绝策略，丢弃任务，并且抛出 RejectedExecutionException 异常，建议使用这个策略，因为可以方便通过异常发现。</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy 由提交任务的线程处理该任务，这种情况下，需要等到所有任务执行完毕，这种策略适合大量计算的任务类型。</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy 丢弃队列最前面的任务，然后重新提交被拒绝的任务，这种策略适合经常需要丢弃旧的任务类型。</li>\n<li>ThreadPoolExecutor.DiscardPolicy 丢弃任务，但是不抛出异常，使用这种策略会导致我们无法发现异常。</li>\n</ul>\n<h2 id=\"Worker-线程的管理\"><a href=\"#Worker-线程的管理\" class=\"headerlink\" title=\"Worker 线程的管理\"></a>Worker 线程的管理</h2><p><img src=\"/images/%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86.png\"></p>\n<h3 id=\"Worker-线程执行\"><a href=\"#Worker-线程执行\" class=\"headerlink\" title=\"Worker 线程执行\"></a>Worker 线程执行</h3><p><img src=\"/images/%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C.png\"></p>\n<p>thread 是在调用构造方法时通过 ThreadFactory 来创建的线程，可以用来执行任务。firstTask 用它来保存传入的第一个任务<br> Worker 是通过继承 AQS，使用不可重入的特性去反应线程现在的执行状态(可见 runWorker 方法)。</p>\n<blockquote>\n<p>tips: 所谓不可重入锁，即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞；所谓可重入，意味着线程可以进入它已经拥有的锁的同步代码块。</p>\n</blockquote>\n<p><img src=\"/images/%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C_2.png\"></p>\n<ol>\n<li>lock 方法一旦获取了独占锁，表示当前线程正在执行任务中；</li>\n<li>如果正在执行任务，则不应该中断线程；</li>\n<li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</li>\n<li>线程池在执行 shutdown 方法或 tryTerminate 方法时会调用 interruptIdleWorkers 方法来中断空闲的线程，interruptIdleWorkers 方法会使用tryLock 方法来判断线程池中的线程是否是空闲状态，如果线程是空闲状态则可以安全回收。</li>\n</ol>\n<p>线程回收则应用上述特性</p>\n<p><img src=\"/images/%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C_3.png\"></p>\n<h3 id=\"线程的回收\"><a href=\"#线程的回收\" class=\"headerlink\" title=\"线程的回收\"></a>线程的回收</h3><p>线程池中线程的销毁依赖 JVM 自动的回收，线程池是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被 JVM 回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker 被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当 Worker 无法获取到任务，也就是获取的任务为空时，循环会结束，Worker 会主动消除自身在线程池内的引用。</p>\n<p><img src=\"/images/%E7%BA%BF%E7%A8%8B%E5%9B%9E%E6%94%B6.png\"></p>\n<p><img src=\"/images/%E7%BA%BF%E7%A8%8B%E5%9B%9E%E6%94%B6_2.png\"></p>\n<p>在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分，但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。</p>\n<p><br><br></p>\n","categories":["后端"],"tags":["Java","线程池"]},{"title":"SpringMVC 框架及常用注解介绍","url":"https://zhouxelf.com/2021/02/27/SpringMVC 框架及常用注解/","content":"<h1 id=\"SpringMVC-概述\"><a href=\"#SpringMVC-概述\" class=\"headerlink\" title=\"SpringMVC 概述\"></a>SpringMVC 概述</h1><p>SpringMVC 是一个 Java Web 开发框架，也是 Spring 框架中重要的模块之一，使用它能进行快速的 Web 端应用开发。SpringMVC 默认使用单例开发，并且建议使用单例开发。相对于 Struts2 基于类的开发，SpringMVC 是基于方法开发的，它将客户端的 URL 请求映射到服务端的 Controller 内的方法，映射成功后 SpringMVC 生成一个 Handler 对象，对象中只包括了一个 Method 方法，方法执行结束后形参数据销毁。</p>\n<h1 id=\"SpringMVC-示例\"><a href=\"#SpringMVC-示例\" class=\"headerlink\" title=\"SpringMVC 示例\"></a>SpringMVC 示例</h1><p><strong>1&gt;</strong> 使用 Maven 创建一个 Web 项目，然后在 pom.xml 文件中添加以下依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- SpringMVC 需要的包，会自动加载依赖的包 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-webmvc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.1.5.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.servlet<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>javax.servlet-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.1.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>provided<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>2&gt;</strong> 在 web.xml 文件中配置 DispatcherServlet、过滤器、监听器等<br><strong>3&gt;</strong> 在 web.xml 文件中指定的 contextConfig 文件 spring-servlet.xml 中对拦截器、视图解析器、注解等进行配置<br><strong>4&gt;</strong> 目录结构</p>\n<p><img src=\"/images/SpringMVC%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png\"></p>\n<ul>\n<li>controller 包下是控制器类</li>\n<li>service 包下是服务类</li>\n<li>bean 包下是数据类</li>\n<li>jsp 目录下是 .jsp 视图文件</li>\n</ul>\n<h1 id=\"SpringMVC-请求处理流程图\"><a href=\"#SpringMVC-请求处理流程图\" class=\"headerlink\" title=\"SpringMVC 请求处理流程图\"></a>SpringMVC 请求处理流程图</h1><p><img src=\"/images/SpringMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%9B%BE.png\"></p>\n<p>SpringMVC 是一个基于 DispatcherServlet 的 MVC 框架，主要由 DispatcherServlet、HandlerMapping、Controller、ViewResolver 和 View 组成。</p>\n<p>一个 HTTP 请求处理过程如下：</p>\n<ol>\n<li>DispatcherServlet 接收到请求后，根据对应配置文件中配置的处理器映射，找到对应的处理器映射项(HandlerMapping)，根据配置的映射规则，找到对应的处理器(Handler)；</li>\n<li>调用相应处理器中的处理方法，处理该请求，处理器处理结束后会将一个 ModelAndView 类型的数据传给 DispatcherServlet，这其中包含了处理结果的视图和视图中要使用的数据；</li>\n<li>DispatcherServlet 根据得到的 ModelAndView 中的视图对象，找到一个合适的视图解析器(ViewResolver)，根据视图解析器的配置将视图要显示的数据传给对应的视图，最后给浏览器构造一个 HTTP 响应。</li>\n</ol>\n<blockquote>\n<p>tips:</p>\n<ol>\n<li>Handler 处理以后再返回相应的视图(View)和模型(Model)，返回的视图和模型都可以不指定，即可以只返回 View 或 Model，或都不返回。</li>\n<li>Handler 处理后会委派给一个视图，由该视图来处理方法的返回值。处理程序的返回值并不代表视图的具体实现，可以只是 String 类型，代表视图名，甚至是 void(此时 SpringMVC 可以根据方法名或者控制器名找默认视图)。</li>\n<li>当返回值是视图名称时，视图可以拿到方法参数，比如处理方法以 Map 为参数，则这个 Map 对于视图是可见的。</li>\n</ol>\n</blockquote>\n<h1 id=\"SpringMVC-核心-Servlet-结构图\"><a href=\"#SpringMVC-核心-Servlet-结构图\" class=\"headerlink\" title=\"SpringMVC 核心 Servlet 结构图\"></a>SpringMVC 核心 Servlet 结构图</h1><p><img src=\"/images/SpringMVC%E6%A0%B8%E5%BF%83Servlet%E7%BB%93%E6%9E%84%E5%9B%BE.png\"></p>\n<p>在 SpringMVC 中 Servlet 可分为三个层次：</p>\n<ol>\n<li>HttpServletBean，其直接继承自 HttpServlet，主要是将 Servlet 中配置的参数设置到相应的属性中；</li>\n<li>FrameworkServlet，其负责初始化 WebApplicationContext；</li>\n<li>Dispatcherservlet，其负责初始化自身的 9 个组件。</li>\n</ol>\n<h1 id=\"doDispatcher-方法处理流程图\"><a href=\"#doDispatcher-方法处理流程图\" class=\"headerlink\" title=\"doDispatcher 方法处理流程图\"></a>doDispatcher 方法处理流程图</h1><p>doDispatcher 是 SpringMVC 中最核心的处理方法，负责处理请求和渲染页面。其最核心的代码只有 4 句，但却是精华中的精华，分别对应 4 个任务：</p>\n<ol>\n<li>根据 request 找到 Handler；</li>\n<li>根据 Handler 找到对应的 HandlerAdapter；</li>\n<li>用 HandlerAdapter 处理 Handler；</li>\n<li>调用 processDispatcherResult 方法处理结果。</li>\n</ol>\n<p>其详细的处理过程如下图</p>\n<p><img src=\"/images/SpringMVC%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png\"></p>\n<h1 id=\"SpringMVC-中过滤器、拦截器、监听器\"><a href=\"#SpringMVC-中过滤器、拦截器、监听器\" class=\"headerlink\" title=\"SpringMVC 中过滤器、拦截器、监听器\"></a>SpringMVC 中过滤器、拦截器、监听器</h1><h2 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h2><p>过滤器(Filter)依赖于 Servlet 容器，在容器初始化时调用，做一些过滤操作或获取想要获取的数据，比如：在过滤器中修改字符编码；在过滤器中修改 HttpServletRequest 的一些参数；过滤掉一些低俗文字、危险字符等。</p>\n<p>一个 Filter 包括：</p>\n<ol>\n<li>在 servlet 被调用之前截获；</li>\n<li>在 servlet 被调用之前检查 servlet sequest；</li>\n<li>根据需要修改 request header 和 request body；</li>\n<li>根据需要修改 response header 和 response body；</li>\n<li>在 servlet 被调用之后截获。</li>\n</ol>\n<p>每一个 Filter 从 doFilter() 方法中得到当前的 request 及 response，在这个方法里可以进行任何针对 request 及 response 的操作，Filter 调用 chain.doFilter() 方法把控制权交给下一个 Filter。</p>\n<h2 id=\"拦截器\"><a href=\"#拦截器\" class=\"headerlink\" title=\"拦截器\"></a>拦截器</h2><p>拦截器依赖于 Web 框架，在 SpringMVC 中就是依赖于 SpringMVC 框架。拦截器的实现是基于 Java 的反射机制，属于面向切面编程的一种运用。同时一个拦截器实例在一个 Controller 生命周期之内可以多次调用，但是缺点是只能对 Controller 请求进行拦截，对其它的一些比如直接访问静态资源的请求则没办法进行拦截处理。</p>\n<h2 id=\"监听器\"><a href=\"#监听器\" class=\"headerlink\" title=\"监听器\"></a>监听器</h2><p>监听器可以监听客户端的请求、服务端的操作等等，通过监听器，可以自动激发一些操作，比如监听在线用户的数量。监听器采用观察者模式，能够方便的从另一个纵向维度控制程序和数据。目前 Servlet 中提供了 6 种两类事件的观察者接口，分别是：</p>\n<ol>\n<li>3 个 EventListeners 类型的 ServletContextAttributeListener、ServletRequestAttributeListener、HttpSessionAttributeListener；</li>\n<li>3 个 LifecycleListeners 类型的 ServletContextListener、HttpSessionListener、ServletRequestListener。</li>\n</ol>\n<p>过滤器、拦截器的执行顺序如下图</p>\n<p><img src=\"/images/SpringMVC%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8.png\"></p>\n<h1 id=\"SpringMVC-注解分析\"><a href=\"#SpringMVC-注解分析\" class=\"headerlink\" title=\"SpringMVC 注解分析\"></a>SpringMVC 注解分析</h1><p>SpringMVC 中 annotation 的大量使用提高了开发效率，在结构上也比 xml 清晰，也更加的便于维护，不论是注入还是 AOP 还是事务，annotation 都远远的比 xml 好用。</p>\n<h2 id=\"注解在-SpringMVC-中的作用\"><a href=\"#注解在-SpringMVC-中的作用\" class=\"headerlink\" title=\"注解在 SpringMVC 中的作用\"></a>注解在 SpringMVC 中的作用</h2><p>注解也叫元数据，是 JDK1.5 版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解，它主要的作用有以下四个方面：</p>\n<ol>\n<li>生成文档，通过代码里标识的元数据生成 javadoc 文档；</li>\n<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证；</li>\n<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码；</li>\n<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li>\n</ol>\n<h2 id=\"注解的类型\"><a href=\"#注解的类型\" class=\"headerlink\" title=\"注解的类型\"></a>注解的类型</h2><p>注解一般分为以下三类：</p>\n<ol>\n<li>Java 自带的标准注解，如 @Override、@Deprecated、@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查；</li>\n<li>元注解，元注解是用于定义注解的注解，如 @Retention、@Target、@Inherited、@Documented；</li>\n<li>自定义注解，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。 </li>\n</ol>\n<p><strong>元注解说明</strong></p>\n<p>@Target 用于描述注解的使用范围</p>\n<table>\n<thead>\n<tr>\n<th>ElementType 取值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CONSTRUCTOR</td>\n<td>用于描述构造器</td>\n</tr>\n<tr>\n<td>FIELD</td>\n<td>用于描述域即类成员变量</td>\n</tr>\n<tr>\n<td>LOCAL_VARIABLE</td>\n<td>用于描述局部变量</td>\n</tr>\n<tr>\n<td>METHOD</td>\n<td>用于描述方法</td>\n</tr>\n<tr>\n<td>PACKAGE</td>\n<td>用于描述包</td>\n</tr>\n<tr>\n<td>PARAMETER</td>\n<td>用于描述参数</td>\n</tr>\n<tr>\n<td>TYPE</td>\n<td>用于描述类、接口(包括注解类型)或 enum 声明</td>\n</tr>\n</tbody></table>\n<p>@Retention 用于描述注解的生命周期</p>\n<table>\n<thead>\n<tr>\n<th>RetentionPoicy 取值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SOURCE</td>\n<td>在源文件中有效(即源文件保留)</td>\n</tr>\n<tr>\n<td>CLASS</td>\n<td>在 class 文件中有效(即 class 保留)</td>\n</tr>\n<tr>\n<td>RUNTIME</td>\n<td>在运行时有效(即运行时保留)</td>\n</tr>\n</tbody></table>\n<p>@Documented 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因此可以被例如 javadoc 此类的工具文档化，Documented 是一个标记注解，没有成员。</p>\n<p>@Inherited 一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。</p>\n<h1 id=\"常用的注解\"><a href=\"#常用的注解\" class=\"headerlink\" title=\"常用的注解\"></a>常用的注解</h1><ul>\n<li>@Service 用于标注业务层组件</li>\n<li>@Controller 用于标注控制层组件</li>\n<li>@Repository 用于标注数据访问组件</li>\n<li>@Component 泛指组件，当组件不好归类的时候，可以使用这个注解</li>\n<li>@RequestMapping 为控制器指定可以处理哪些 URL 请求</li>\n<li>@RequestParam 在处理方法入参处使用该注解可以把请求参数传递给请求方法</li>\n<li>@PathVariable 绑定 URL 占位符到入参</li>\n<li>@ExceptionHandler 注解到方法上，出现异常时会执行该方法</li>\n<li>@RequestBody 该注解用于读取 Request 请求的 Body 部分数据，使用系统默认配置的HttpMessageConverter 进行解析，然后把相应的数据绑定到要返回的对象上，再把HttpMessageConverter 返回的对象数据绑定到 Controller 中方法的参数上</li>\n<li>@ResponseBody 该注解用于将 Controller 方法返回的对象，通过适当的HttpMessageConverter 转换为指定格式后，写入到 Response 对象的 Body 数据区</li>\n</ul>\n<h1 id=\"Spring-使用时的注意点\"><a href=\"#Spring-使用时的注意点\" class=\"headerlink\" title=\"Spring 使用时的注意点\"></a>Spring 使用时的注意点</h1><ol>\n<li>不要在 Controller 中定义成员变量 </li>\n<li>如果必须要在 Controller 中定义一个非静态成员变量时，最好通过注解 @Scope(“prototype”) 将其设置为多例模式</li>\n</ol>\n<p><br><br></p>\n","categories":["后端"],"tags":["Java","SpringMVC"]},{"title":"JVM 内存管理","url":"https://zhouxelf.com/2021/01/28/JVM 内存管理/","content":"<h1 id=\"JVM-内存结构\"><a href=\"#JVM-内存结构\" class=\"headerlink\" title=\"JVM 内存结构\"></a>JVM 内存结构</h1><p>JVM 在执行 Java 程序的过程中，会把它管理的内存划分为几个不同的数据区域，这些区域都有各自的用途、创建时间、销毁时间。</p>\n<ul>\n<li>寄存器：最开的存储区，由编译器根据需求进行分配，在程序中无法控制。</li>\n<li>栈：存放基本类型的变量和对象的引用，对象本身不存放在栈中。</li>\n<li>堆：存放 new 出来的对象。</li>\n<li>静态域：存放静态成员变量，由 static 定义的。</li>\n<li>常量池：存放字符串常量和基本类型常量，由 public static final 定义的。</li>\n<li>非 RAM 存储：硬盘等永久存储空间。</li>\n</ul>\n<p>栈和常量池中的对象可以共享，堆中的对象不可以共享。</p>\n<p>栈中的数据大小和生命周期是可以确定的，当没有引用指向数据时，数据就会消失。</p>\n<p>堆中的对象由垃圾回收器负责回收，因此大小和生命周期不需要确定，具有很大的灵活性。</p>\n<p>对于字符串，其对象的引用都是存储在栈中的，如果是编译期就已经创建好的（直接双引号定义）就存储在常量池中，如果是运行期才能确定的（new 出来的）就存储在堆中。对于 equals 相等的字符串，在常量池中永远只有一份，在堆中有多份。</p>\n<p><strong>JDK8 JVM 分代图</strong></p>\n<p><img src=\"/images/JDK8_JVM.jpeg\"></p>\n<h2 id=\"线程隔离区域（线程安全区）\"><a href=\"#线程隔离区域（线程安全区）\" class=\"headerlink\" title=\"线程隔离区域（线程安全区）\"></a>线程隔离区域（线程安全区）</h2><ul>\n<li><p>程序计数器：多线程执行过程中，当前线程正在执行的字节码指令的行号指示器，分支、循环、跳转、异常处理、线程恢复等基础工程都需要依赖这个计数器来完成。该内存区域是虚拟机中没有规定任何 OutOfMemory Error 情况的区域，因为程序运行过程中，计数器中改变的只是值，而不会随着程序的运行需要更大的空间。</p>\n</li>\n<li><p>虚拟机栈：虚拟机栈存放当前正在执行方法所需要的数据、地址、指令。每个线程都会独享一块栈空间，每次方法调用都会创建一个栈帧，栈帧保存了方法的局部变量、操作数栈、动态链接、出口等信息。栈帧的深度是有限的，超过限制会抛出 StackOverflow Error 异常。</p>\n</li>\n<li><p>本地方法栈：本地方法是指在 JDK 中那些被 native 关键字修饰的方法。这类方法有点类似于 Java 中的接口，没有实现体，但实际上是由 JVM 在加载时调用底层实现的，实现体由非 Java 语言实现（如 C、C++），所以本地方法可以认为是连接 Java 代码和其它语言实现代码的入口。本地方法栈的功能类似于虚拟机栈，只是一个服务于 Java 方法，一个服务于本地方法。</p>\n</li>\n</ul>\n<h2 id=\"线程共享区域（线程非安全区）\"><a href=\"#线程共享区域（线程非安全区）\" class=\"headerlink\" title=\"线程共享区域（线程非安全区）\"></a>线程共享区域（线程非安全区）</h2><ul>\n<li>堆：存放创建对象的实例。堆区域在 JVM 中是非常重要的一块区域，这个区域几乎是被所有的线程所共享，同时也是 JVM 管理内存中最大的一块。</li>\n</ul>\n<p>当代主流虚拟机（Hotspot VM）的垃收集都采用「分代回收」的算法，「分代回收」基于这样一个事实：对象的生命周期不同，所以针对不同生命周期的对象可以采用不同的回收方式，以便提高回收效率。</p>\n<p>HotSpot VM 将内存划分为不同的物理区，就是分代思想的体现，JVM 内存主要由新生代、老年代、永久代构成。</p>\n<ul>\n<li>新生代（Young Generation）：大多数对象在新生代中创建，其中很多对象的生命周期很短。每次新生代的垃圾回收（又称 Mintor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。</li>\n</ul>\n<p>新生代内有分为三个区：一个 Eden 区，两个 Survivor 区（一般而言），大部分对象在 Eden 区中生成。当 Eden 区满时，还存活的对象将被复制到两个 Survivor 区（中的一个）。当这个 Suvivor 区满时，此区的存活并且不满足「晋升」条件的对象将被复制到另外一个 Survivor 区。对象每经历一次 Minor GC，年龄加 1，达到「晋升年龄阈值」后，被放倒老年代，这个过程也称为「晋升」。显然，「晋升年龄阈值」的大小直接影响着对象在新生代中的停留时间，在串行（Serial）和并行（ParNew）两种回收器中，「晋升年龄阈值」通过参数 MaxTenuringThreshold 设定，默认值为 15。</p>\n<ul>\n<li><p>老年代（Old Generation）：在新生代中经历了 N 次垃圾回收后仍然存活的对象，就会被放倒老年代，该区域对象存活率高。老年代的垃圾回收（又称 Major GC）通常使用「标记-清除」或「标记-整理」算法。整堆包括新生代和老年代的垃圾回收称为 Full GC（HotSpot VM 里，除了 CMS 之外，其它能收集老年代的 GC 都会同时收集整个 GC 堆，包括新生代）。</p>\n</li>\n<li><p>永久代（Perm Generation）：主要存放元数据，例如 Class、Method 的元信息，与垃圾回收要回收的 Java 对象关系不大，相对于新生代和老年代来说，该区域的划分对垃圾回收影响比较小。</p>\n</li>\n</ul>\n<blockquote>\n<p><code>注: 永久代在 JDK8 时被移除，取而代之的称为元空间</code>。</p>\n</blockquote>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>jdk8 废除的是永久代的概念，并不是方法区。</p>\n<p>JVM 的虚拟机规范只规定了有方法区这个概念和作用，并没有规定如何实现它。不同的 JVM 方法区的实现会不一样，比如在 HotSpot 虚拟机中使用永久代实现方法区，其它 JVM 并没有永久代的概念。方法区是一种规范，永久代是一种实现。</p>\n<p>我们经常说的永久代是方法区的一种实现，并且只在 HotSpot 虚拟机中有这种概念。JDK8（HotSpot 虚拟机）之前的版本经常碰到永久代溢出的异常 java.lang.OutOfMemeryError: PermGen space，这里的 PermGen space 指的就是永久代。在 JDK6 中，永久代包含方法区和常量池，但是在 jdk7 中规划去除永久代，于是在 JDK7 时将常量池移到了老年代。而在 JDK8<br>中彻底废除了永久代，取而代之的是元空间（Meta space）。</p>\n<h2 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h2><p>JDK8 之前，永久代设置太大，浪费资源，设置太小，容易溢出，并且永久代的 GC 效率很低。</p>\n<p>于是 JDK8 中彻底废除了永久代，取而代之是元空间（Meta Space）。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。元空间在非堆上，属于本地内存，不受 JVM 控制，也不会发生永久代溢出的异常。</p>\n<h1 id=\"常见的垃圾收集器\"><a href=\"#常见的垃圾收集器\" class=\"headerlink\" title=\"常见的垃圾收集器\"></a>常见的垃圾收集器</h1><p>目前在 Hotspot VM 中主要有分代收集和分区收集两大类，未来会逐渐向分区收集发展。</p>\n<h2 id=\"分代收集器\"><a href=\"#分代收集器\" class=\"headerlink\" title=\"分代收集器\"></a>分代收集器</h2><ul>\n<li>Serial：串行收集器是单线程的一个收集器，简单、易实现、效率高。</li>\n<li>ParNew：一款 Serial 多线程版的收集器，采用复制算法，主要工作在 Young 区，可以通过 -XX:ParallelGCThreads 参数来控制收集的线程数，整个过程都是 STW 的，常与 CMS 组合使用。</li>\n<li>Parallel Scavenge：吞吐量优先收集器，侧重于吞吐量的控制。</li>\n<li>CMS（Concurrent Mark Sweep）： 并发标记清除收集器以获取最短回收停顿时间为目标，采用「标记-清除」算法，分 4 大步进行垃圾收集，其中初始标记和重新标记会 STW ，多数应用于互联网站或者 B/S 系统的服务器端上，JDK9 被标记弃用，JDK14 被删除。</li>\n</ul>\n<h2 id=\"分区收集器\"><a href=\"#分区收集器\" class=\"headerlink\" title=\"分区收集器\"></a>分区收集器</h2><ul>\n<li>G1：一种服务器端的垃圾收集器，应用在多服务器和大容量内存环境中，在实现高吞吐量的同时，尽可能地满足垃圾收集暂停时间的要求。</li>\n<li>ZGC：JDK11 中推出的一款低延迟垃圾回收器，适用于大内存低延迟服务的内存管理和回收，SPECjbb 2015 基准测试，在 128G 的大堆下，最大停顿时间才 1.68ms，停顿时间远胜于 G1 和 CMS。</li>\n<li>Shenandoah：由 Red Hat 的一个团队负责开发，与 G1 类似，基于 Region 设计的垃圾收集器，但不需要 Remember Set 或者 Card Table 来记录跨 Region 引用，停顿时间和堆的大小没有任何关系，停顿时间和 ZGC 类似。</li>\n</ul>\n<p><br><br></p>\n","categories":["后端"],"tags":["Java","JVM"]},{"title":"《写给大家看的设计书》读书笔记","url":"https://zhouxelf.com/2021/01/15/《写给大家看的设计书》读书笔记/","content":"<h1 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h1><p>一旦能够说出什么东西的名字，就会很容易注意到它，就会掌握它，拥有它，让它受你所控。</p>\n<p>有关设计(同时也是有关生活)的一个更一般的指导原则是：<strong>不要畏畏缩缩</strong>。</p>\n<ul>\n<li>不要害怕在设计(或生活)中留有空白，这能让你的眼睛(以及心灵)稍作休息。</li>\n<li>不要害怕设计是不对称的，使用非居中的格式，不居中往往能使效果更强烈。尽管不建议使用居中，不过有意这么做也无不可。</li>\n<li>不要害怕把单词设置得非常大或非常小，不要担心说话声太大或者太小，这合适的场合这都是可以的。</li>\n<li>只要最后的结果能支持或强调你的设计或观点，不要害怕让图片太大或太小。</li>\n</ul>\n<p><strong>四大设计基本原则</strong></p>\n<ul>\n<li>亲密性</li>\n<li>对齐</li>\n<li>重复</li>\n<li>对比</li>\n</ul>\n<h1 id=\"亲密性\"><a href=\"#亲密性\" class=\"headerlink\" title=\"亲密性\"></a>亲密性</h1><p>亲密性原则是指：<strong>将相互关联的项组织在一起</strong>，移动这些项，使它们的物理位置相互靠近，这样以来，相关的项将被看作凝聚为一体的一个组，而不再是一堆彼此无关的片段。</p>\n<p>如果某些元素在理解上存在关联，或者相互之间存在某种关系，那么这些元素在视觉上也应该有关联。除此之外，其他孤立的元素或元素组则不应该存在亲密性。位置是否靠近可以体现元素之间是否存在关系。</p>\n<h2 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2><p>微微眯起眼睛，统计眼睛停顿的次数来数一数页面上有多少个元素。如果页面上的项超过 3～5 个(当然，这取决于具体情况)，就要看看哪些孤立的元素可以归为一组建议更近的亲密性，使之成为一个视觉单元。</p>\n<h2 id=\"要避免的问题\"><a href=\"#要避免的问题\" class=\"headerlink\" title=\"要避免的问题\"></a>要避免的问题</h2><ul>\n<li>避免一个页面上有太多孤立的元素。</li>\n<li>不要在元素之间留出同样大小的空白，除非各组同属于一个子集。</li>\n<li>标题、子标题、图表标题、图片能否归入相关材料？在这个问题上一定要非常清楚，哪怕只有一点含糊都要尽量避免。在有很近亲密性的元素之间建立关系。</li>\n<li>不同属一组的元素之间不要建立关系！如果元素之间彼此无关，要把它们分开。</li>\n<li>不要仅仅因为有空白就把元素放在角落或中央。</li>\n</ul>\n<h1 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h1><p>对齐原则是指：<strong>任何元素都不能在页面上随意安放，每一项都应当与页面上的某个内容存在某种视觉联系</strong>。对齐原则要求特别小心，再不能像从前那样，只要页面上刚好有空间就把元素随意 <strong>扔</strong> 到那里。</p>\n<p>在得到更多培训之前，一定要坚持一个原则：<strong>只使用一种对齐方式</strong>。页面上只使用一种文本对齐，所有文本都左对齐，或右对齐，或者全部居中。</p>\n<h2 id=\"如何实现-1\"><a href=\"#如何实现-1\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2><p>要特别注意元素放在哪里，应当总能在页面上找到与之对齐的元素，尽管这两个对象的物理位置可能相距很远。</p>\n<h2 id=\"要避免的问题-1\"><a href=\"#要避免的问题-1\" class=\"headerlink\" title=\"要避免的问题\"></a>要避免的问题</h2><ul>\n<li>要避免在页面上混合使用多种文本对齐方式，也就是说，不要将某些文本居中，而另外一些文本右对齐。</li>\n<li><strong>要着力避免居中对齐</strong>，除非你有意识地想要创建一种比较正式、稳重(通常也更乏味)的表示。并不是完全杜绝使用居中对齐，有时可以有意地选择这种对齐方式，但是不要把它作为默认选择。</li>\n</ul>\n<h1 id=\"重复\"><a href=\"#重复\" class=\"headerlink\" title=\"重复\"></a>重复</h1><p>重复原则是指：<strong>设计的某些方面需要在整个作品中重复</strong>。重复元素可能是一种粗字体、一条粗线、某个项目符号、颜色、设计原则、颜色、设计要素、某种格式、空间关系等。读者能看到的任何方面都可以作为重复元素。</p>\n<h2 id=\"如何实现-2\"><a href=\"#如何实现-2\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2><p>重复可以认为是保持一致性，而且我相信你早已经这样做过。现在，<strong>需要把现有的一致性更向前推进一步</strong>。</p>\n<h2 id=\"要避免的问题-2\"><a href=\"#要避免的问题-2\" class=\"headerlink\" title=\"要避免的问题\"></a>要避免的问题</h2><ul>\n<li>要避免太多地重复一个元素，重复太多会让人讨厌，要注意对比的价值。</li>\n</ul>\n<h1 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h1><p>对比原则是指：<strong>页面的不同元素之间要有对比效果，达到吸引读者的对比效果</strong>。如果两个项不完全相同，就应当使之不同，而且应当是截然不同。</p>\n<p>对比不仅可以用来吸引眼球，还可以用来组织信息、清晰层级、在页面上指引读者，并且制造焦点。</p>\n<p>记住一个重要规则：要实现有效的对比，对比就必须强烈，千万不要畏畏缩缩。</p>\n<h2 id=\"如何实现-3\"><a href=\"#如何实现-3\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2><p>可以通过字体选择、线宽、形状、大小、空间等来增加对比。增加对比很容易，途径有很多，这可能是增加视觉效果更有意思也更加让人满意的地方了。重要的是：<strong>对比一定要强烈</strong>。</p>\n<h2 id=\"要避免的问题-3\"><a href=\"#要避免的问题-3\" class=\"headerlink\" title=\"要避免的问题\"></a>要避免的问题</h2><ul>\n<li>不要犹豫。如果你想形成对比，就加大力度。不要将一种粗线与一种更粗的线进行对比。不要将棕色文本和黑色标题建立对比。要避免使用两种多种类似的字体。如果各个项不完全一样，干脆让它们截然不同。</li>\n</ul>\n<p><br><br></p>\n","categories":["读书笔记"],"tags":["读书笔记"]},{"title":"Java 集合框架","url":"https://zhouxelf.com/2020/11/13/Java 集合框架/","content":"<h1 id=\"集合简介\"><a href=\"#集合简介\" class=\"headerlink\" title=\"集合简介\"></a>集合简介</h1><p>集合是一个数学概念，远远早于 Java。</p>\n<p>早在 Java 2 中之前，Java 就提供了特设类。比如: Dictionary、Vector、Stack 和 Properties，这些类用来存储和操作对象组。</p>\n<p>虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。</p>\n<p>集合框架被设计成要满足以下几个目标：</p>\n<ol>\n<li>该框架必须是高性能的，基本集合(动态数组、链表、树、哈希表)的实现也必须是高效的。</li>\n<li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li>\n<li>对一个集合的扩展和适应必须是简单的。</li>\n</ol>\n<p>不同于数组，集合在声明时不需要指定固定的容量，它可以在新增或移除内容时自动地增加或缩减其容量。</p>\n<p><strong>Java 集合框架图</strong></p>\n<p><img src=\"/images/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.gif\"></p>\n<p>Java 集合框架主要包括两种类型的容器，一种是 <code>集合(Collection)</code>，存储一个元素集合，另一种是 <code>图(Map)</code>，存储键/值对映射。</p>\n<p>Collection 接口又有 3 种子类型:，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。</p>\n<p>所有的集合框架都包含如下内容:</p>\n<ul>\n<li><strong>接口</strong>: 代表集合的抽象数据类型。例如 Collection、List、Set、Map 等，之所以定义多个接口，是为了以不同的方式操作集合对象。</li>\n<li><strong>实现类</strong>: 集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如: ArrayList、LinkedList、HashSet、HashMap。</li>\n<li><strong>算法</strong>: 实现集合接口的对象里的方法执行的一些有用的计算。例如: 搜索和排序，这些算法被称为多态，因为相同的方法可以在相似的接口上有着不同的实现。</li>\n</ul>\n<p><strong>集合框架体系图</strong></p>\n<p><img src=\"/images/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB.png\"></p>\n<h1 id=\"集合接口\"><a href=\"#集合接口\" class=\"headerlink\" title=\"集合接口\"></a>集合接口</h1><ul>\n<li><strong>Collection 接口:</strong> 最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 元素，Java 不提供直接继承自 Collection 的类，只提供继承于的子接口(比如 List 和 Set)。Collection 接口存储一组 <code>不唯一、无序</code> 的对象。</li>\n<li><strong>List 接口:</strong> 一个有序的 Collection，使用此接口可以精确控制每个元素插入的位置，能够通过索引(元素在 List 中的位置，类似于数组的下标)来访问 List 中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组 <code>不唯一、有序(插入顺序)</code> 的对象。</li>\n<li><strong>Set 接口:</strong> Set 具有和 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。Set 接口存储一组 <code>唯一、无序</code> 的对象。</li>\n<li><strong>SortedSet 接口:</strong> 继承于 Set 保存 <code>有序</code> 的集合。</li>\n<li><strong>Map 接口:</strong> Map 接口存储 <code>一组键值对象</code>，提供 key 到 value 的映射。</li>\n<li><strong>Map.Entry:</strong> 描述在 <code>一个 Map 中的一个元素(key-value)</code>，是 Map 的一个内部类。</li>\n<li><strong>SortedMap 接口:</strong> 继承于 Map，<code>使 key 保持在升序排列</code>。</li>\n</ul>\n<h3 id=\"Set-和-List-的区别\"><a href=\"#Set-和-List-的区别\" class=\"headerlink\" title=\"Set 和 List 的区别\"></a>Set 和 List 的区别</h3><ol>\n<li>Set 接口实例存储的是无序的，不重复的数据，List 接口实例存储的是有序的，可以重复的元素。</li>\n<li> Set <code>检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变</code>，实现类有 HashSet、TreeSet。</li>\n<li> List 和数组类似，可以动态增长，根据实际存储的数据的长度自动增长 List 的长度，<code>查找元素效率高，插入删除效率低，因为会引起其他元素位置改变</code>，实现类有 ArrayList、LinkedList、Vector。</li>\n</ol>\n<h1 id=\"集合实现类\"><a href=\"#集合实现类\" class=\"headerlink\" title=\"集合实现类\"></a>集合实现类</h1><table>\n<thead>\n<tr>\n<th>实现类</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AbstractCollection</td>\n<td>实现了大部分的集合接口。</td>\n</tr>\n<tr>\n<td>AbstractList</td>\n<td>继承于 AbstractCollection 并且实现了大部分 List 接口。</td>\n</tr>\n<tr>\n<td>AbstractSequentialList</td>\n<td>继承于 AbstractList ，提供了对数据元素的链式访问而不是随机访问。</td>\n</tr>\n<tr>\n<td><code>LinkedList</code></td>\n<td>实现了 List 接口，允许有 null 元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个 List，则必须自己实现访问同步，解决方法就是在创建 List 时候构造一个同步的 List，LinkedList 查找效率低。</td>\n</tr>\n<tr>\n<td><code>ArrayList</code></td>\n<td>也是实现了 List 的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的，在多线程的情况下不要使用，ArrayList 增长当前长度的 50%，插入删除效率低。</td>\n</tr>\n<tr>\n<td>AbstractSet</td>\n<td>继承于AbstractCollection 并且实现了大部分 Set 接口。</td>\n</tr>\n<tr>\n<td><code>HashSet</code></td>\n<td>实现了 Set 接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为 null 的元素，但最多只能一个。</td>\n</tr>\n<tr>\n<td>LinkedHashSet</td>\n<td>具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。</td>\n</tr>\n<tr>\n<td>TreeSet</td>\n<td>实现了 Set 接口，可以实现排序等功能。</td>\n</tr>\n<tr>\n<td>AbstractMap</td>\n<td>实现了大部分的 Map 接口。</td>\n</tr>\n<tr>\n<td><code>HashMap</code></td>\n<td>实现了 Map 接口，根据 key 的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。</td>\n</tr>\n<tr>\n<td>TreeMap</td>\n<td>继承了 AbstractMap，并且使用一颗树。</td>\n</tr>\n<tr>\n<td>WeakHashMap</td>\n<td>继承 AbstractMap，使用弱密钥的哈希表。</td>\n</tr>\n<tr>\n<td>LinkedHashMap</td>\n<td>继承于 HashMap，使用元素的自然顺序对元素进行排序。</td>\n</tr>\n<tr>\n<td>IdentityHashMap</td>\n<td>继承 AbstractMap 类，比较文档时使用引用相等。</td>\n</tr>\n</tbody></table>\n<p>此外还有一些更早的类似集合的实现类，如下:</p>\n<table>\n<thead>\n<tr>\n<th>类</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Vector</td>\n<td>该类和 ArrayList 非常相似，但是该类是线程同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的 2 倍。</td>\n</tr>\n<tr>\n<td>Stack</td>\n<td>栈是 Vector 的一个子类，它实现了一个标准的后进先出的栈。</td>\n</tr>\n<tr>\n<td>Dictionary</td>\n<td>一个抽象类，用来存储 key-value，作用和 Map 相似。</td>\n</tr>\n<tr>\n<td>Hashtable</td>\n<td>Dictionary 类的子类。</td>\n</tr>\n<tr>\n<td>Properties</td>\n<td>继承于 Hashtable，表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串。</td>\n</tr>\n<tr>\n<td>BitSet</td>\n<td>创建一种特殊类型的数组来保存位值，BitSet 中数组大小会随需要增加。</td>\n</tr>\n</tbody></table>\n<h1 id=\"集合算法\"><a href=\"#集合算法\" class=\"headerlink\" title=\"集合算法\"></a>集合算法</h1><h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>一般遍历数组都是采用 for 循环或者增强 for，这两个方法也可以用在集合框架，但是还有一种方法是采用迭代器遍历集合框架，它是一个对象，实现了 Iterator 接口或 ListIterator 接口。</p>\n<p><code>Iterator，使你能够通过循环来得到或删除集合的元素，ListIterator 继承了 Iterator，以允许双向遍历列表和修改元素。</code></p>\n<p><strong>遍历 ArrayList</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;World&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;HAHAHAHA&quot;</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 第一种方法 使用 for-each 遍历 list</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String str : list) &#123;</span><br><span class=\"line\">            System.out.println(str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二种方法 把链表变为数组进行遍历</span></span><br><span class=\"line\">        String[] strArray = <span class=\"keyword\">new</span> String[list.size()];</span><br><span class=\"line\">        list.toArray(strArray);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strArray.length; i++) &#123;</span><br><span class=\"line\">            System.out.println(strArray[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第三种方法 使用迭代器进行遍历</span></span><br><span class=\"line\">        Iterator&lt;String&gt; ite = list.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ite.hasNext()) &#123;  <span class=\"comment\">// 判断下一个元素之后有值</span></span><br><span class=\"line\">            System.out.println(ite.next());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>遍历 Map</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;a1&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;b2&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;c3&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一样方法 普遍使用，二次取值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : map.keySet()) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;key = &quot;</span> + key + <span class=\"string\">&quot; and value = &quot;</span> + map.get(key));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二种方法</span></span><br><span class=\"line\">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">            Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;key = &quot;</span> + entry.getKey() + <span class=\"string\">&quot; and value = &quot;</span> + entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第三种方法 推荐，尤其容量大时</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;key = &quot;</span> + entry.getKey() + <span class=\"string\">&quot; and value = &quot;</span> + entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第四种方法 只能遍历 value</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String v : map.values()) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;value = &quot;</span> + v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"比较器\"><a href=\"#比较器\" class=\"headerlink\" title=\"比较器\"></a>比较器</h3><p>TreeSet 和 TreeMap 的按照排序顺序来存储元素，这是通过比较器来精确定义按照什么样的排序顺序，Comparator 接口可以让我们以不同的方式来排序一个集合。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>集合框架为程序员提供了预先包装的数据结构和算法来操纵他们。</li>\n<li>集合是一个对象，可容纳其他对象的引用，集合接口声明对每一种类型的集合可以执行的操作。</li>\n<li>集合框架的类和接口均在 java.util 包中。</li>\n<li><code>对象加入集合类，没有使用泛型的话会自动转换成 Object 类型，在取出的时候需要进行强制类型转换，使用泛型之后不用强制转换</code>。</li>\n</ul>\n<h1 id=\"常用实现类\"><a href=\"#常用实现类\" class=\"headerlink\" title=\"常用实现类\"></a>常用实现类</h1><h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><p><a href=\"https://www.runoob.com/java/java-arraylist.html\">Java ArrayList</a></p>\n<p>ArrayList 是一个可以动态修改的数组，与普通数组相比，它没有固定大小的限制，可以添加或删除元素。</p>\n<p>随机访问和遍历元素时，性能很好，该类时线程非同步的。</p>\n<p>ArrayList 继承了 AbstractList，并实现了 List 接口。</p>\n<p><img src=\"/images/ArrayList.png\"></p>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayListTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ArrayList&lt;String&gt; sites = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Google&quot;</span>);</span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Runoob&quot;</span>);</span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Taobao&quot;</span>);</span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Weibo&quot;</span>);</span><br><span class=\"line\">        System.out.println(sites);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 访问元素</span></span><br><span class=\"line\">        System.out.println(sites.get(<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 修改元素</span></span><br><span class=\"line\">        sites.set(<span class=\"number\">2</span>, <span class=\"string\">&quot;Wiki&quot;</span>);</span><br><span class=\"line\">        System.out.println(sites);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 删除元素</span></span><br><span class=\"line\">        sites.remove(<span class=\"number\">3</span>);</span><br><span class=\"line\">        System.out.println(sites);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算大小</span></span><br><span class=\"line\">        System.out.println(sites.size());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 排序</span></span><br><span class=\"line\">        Collections.sort(sites);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 迭代访问 for</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sites.size(); i++) &#123;</span><br><span class=\"line\">            System.out.println(sites.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 迭代访问 for-each</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String i : sites) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 迭代访问 Iterator</span></span><br><span class=\"line\">        Iterator&lt;String&gt; it = sites.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">            System.out.println(it.next());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h4><p>ArrayList 中的元素实际上是对象，以上实例中，数组列表元素都是字符串 String 类型，如果要存储其他类型，而 <E> 只能为引用数据类型，这时就需要使用到基本类型的包装类。</p>\n<table>\n<thead>\n<tr>\n<th>基本类型</th>\n<th>引用类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean</td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>Byte</td>\n</tr>\n<tr>\n<td>short</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>int</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>long</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>float</td>\n<td>Float</td>\n</tr>\n<tr>\n<td>double</td>\n<td>Double</td>\n</tr>\n<tr>\n<td>char</td>\n<td>Character</td>\n</tr>\n<tr>\n<td>无</td>\n<td>BigInteger</td>\n</tr>\n<tr>\n<td>无</td>\n<td>BigDecimal</td>\n</tr>\n</tbody></table>\n<p>BigInteger、BigDecimal 用于高精度运算，但是它们没有对应的基本类型。</p>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><p><a href=\"https://www.runoob.com/java/java-linkedlist.html\">Java LinkedList</a></p>\n<p>链表(Linked List)是一种常见的基础数据结构，是一种线性表，但是不会按照线性的顺序存储数据，而是在每一个节点里存放到下一个节点的地址。</p>\n<p>线程非同步的，多线程访问时需要自己实现同步，比如构造一个同步的 List</p>\n<blockquote>\n<p>List list = Collections.synchronizedList(new LinkedList(…))</p>\n</blockquote>\n<p>链表可分为 <strong>单向链表</strong> 和 <strong>双向链表</strong>。</p>\n<p>单向链表节点包含两个值: 当前节点的值和指向下一个节点的链接。</p>\n<p><img src=\"/images/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8.png\"></p>\n<p>双向链表节点包含三个值: 当前节点的值和指向上一个和指向下一个节点的链接。</p>\n<p><img src=\"/images/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png\"></p>\n<p><code>与 ArrayList 相比，LinkedList 增加、删除元素的效率更高，而查找、修改元素的效率较低</code>。</p>\n<p><strong>以下情况使用 ArrayList</strong></p>\n<ul>\n<li>频繁访问列表中的某一个元素。</li>\n<li>只需要在列表末尾添加和删除元素。</li>\n</ul>\n<p><strong>以下情况使用 LinkedList</strong></p>\n<ul>\n<li>需要通过循环迭代来访问列表中的某些元素。</li>\n<li>频繁的在列表开头、中间、末尾等位置进行添加、删除元素。</li>\n</ul>\n<p><img src=\"/images/LinkedList.png\"></p>\n<h4 id=\"常用方法-1\"><a href=\"#常用方法-1\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedListTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LinkedList&lt;String&gt; sites = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Google&quot;</span>);</span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Runoob&quot;</span>);</span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Taobao&quot;</span>);</span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Weibo&quot;</span>);</span><br><span class=\"line\">        System.out.println(sites);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加元素到头部</span></span><br><span class=\"line\">        sites.addFirst(<span class=\"string\">&quot;Wiki&quot;</span>);</span><br><span class=\"line\">        System.out.println(sites);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加元素到尾部</span></span><br><span class=\"line\">        sites.addLast(<span class=\"string\">&quot;Wiki&quot;</span>);</span><br><span class=\"line\">        System.out.println(sites);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 移除头部元素</span></span><br><span class=\"line\">        sites.removeFirst();</span><br><span class=\"line\">        System.out.println(sites);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 移除尾部元素</span></span><br><span class=\"line\">        sites.removeLast();</span><br><span class=\"line\">        System.out.println(sites);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取头部元素</span></span><br><span class=\"line\">        System.out.println(sites.getFirst());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取尾部元素</span></span><br><span class=\"line\">        System.out.println(sites.getLast());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h3><p><a href=\"https://www.runoob.com/java/java-hashset.html\">Java HashSet</a></p>\n<p>HashSet 是基于 HashMap 来实现的，是一个不允许有重复元素的集合，允许有一个 null 值。</p>\n<p>HashSet 实现了 List 接口，是无序的，非线程安全的，如果多个线程同时修改 HashSet，则结果是不确定的，必须在多线程访问时显式同步对 HashSet 的并发访问。</p>\n<p><img src=\"/images/HashSet.png\"></p>\n<h4 id=\"常用方法-2\"><a href=\"#常用方法-2\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashSetTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        HashSet&lt;String&gt; sites = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Google&quot;</span>);</span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Runoob&quot;</span>);</span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Taobao&quot;</span>);</span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Zhihu&quot;</span>);</span><br><span class=\"line\">        sites.add(<span class=\"string\">&quot;Runoob&quot;</span>);  <span class=\"comment\">// 重复的元素不会被添加</span></span><br><span class=\"line\">        System.out.println(sites);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断元素是否存在</span></span><br><span class=\"line\">        System.out.println(sites.contains(<span class=\"string\">&quot;Runoob&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 删除元素</span></span><br><span class=\"line\">        sites.remove(<span class=\"string\">&quot;Taobao&quot;</span>);</span><br><span class=\"line\">        System.out.println(sites);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 删除所有元素</span></span><br><span class=\"line\">        sites.clear();</span><br><span class=\"line\">        System.out.println(sites);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算大小</span></span><br><span class=\"line\">        System.out.println(sites.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><p><a href=\"https://www.runoob.com/java/java-hashmap.html\">Java HashMap</a></p>\n<p>HashMap 是一个散列表，存储的内容是键值对(key-value)映射。</p>\n<p>HashMap 实现了 Map 接口，是无序的，它根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。</p>\n<p><img src=\"/images/HashMap.png\"></p>\n<h4 id=\"常用方法-3\"><a href=\"#常用方法-3\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMapTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;Integer, String&gt; sites = <span class=\"keyword\">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">        sites.put(<span class=\"number\">1</span>, <span class=\"string\">&quot;Google&quot;</span>);</span><br><span class=\"line\">        sites.put(<span class=\"number\">2</span>, <span class=\"string\">&quot;Runoob&quot;</span>);</span><br><span class=\"line\">        sites.put(<span class=\"number\">3</span>, <span class=\"string\">&quot;Taobao&quot;</span>);</span><br><span class=\"line\">        sites.put(<span class=\"number\">4</span>, <span class=\"string\">&quot;Zhihu&quot;</span>);</span><br><span class=\"line\">        System.out.println(sites);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 访问元素</span></span><br><span class=\"line\">        System.out.println(sites.get(<span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 删除元素</span></span><br><span class=\"line\">        sites.remove(<span class=\"number\">4</span>);</span><br><span class=\"line\">        System.out.println(sites);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 清空元素</span></span><br><span class=\"line\">        sites.clear();</span><br><span class=\"line\">        System.out.println(sites);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算大小</span></span><br><span class=\"line\">        System.out.println(sites.size());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 迭代元素</span></span><br><span class=\"line\">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; entries = sites.entrySet().iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (entries.hasNext()) &#123;</span><br><span class=\"line\">            Map.Entry&lt;Integer, String&gt; entry = entries.next();</span><br><span class=\"line\">            System.out.println(entry.getKey() + <span class=\"string\">&quot; &quot;</span> + entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Integer i : sites.keySet()) &#123;</span><br><span class=\"line\">            System.out.println(i + <span class=\"string\">&quot; &quot;</span> + sites.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;Integer, String&gt; site : sites.entrySet()) &#123;</span><br><span class=\"line\">            System.out.println(site.getKey() + <span class=\"string\">&quot; &quot;</span> + site.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String v : sites.values()) &#123;</span><br><span class=\"line\">            System.out.println(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h3><p><a href=\"https://www.runoob.com/java/java-iterator.html\">Java Iterator</a></p>\n<p>Iterator 迭代器不是一个集合，它是一个接口，拥有访问集合的方法，可用于迭代 ArrayList、HashSet 等集合。</p>\n<p>Iterator 是 Java 迭代器最简单的实现，还有一个集合中的接口 ListIterator，它扩展了 Iterator 接口。</p>\n<p><img src=\"/images/Iterator.jpeg\"></p>\n<p>迭代器 it 的基本操作:</p>\n<ul>\n<li>it.next() 返回迭代器的下一个元素，并更新迭代器的状态。</li>\n<li>it.hasNext() 检测集合中是否还有元素。</li>\n<li>it.remove() 将迭代器返回的元素删除。</li>\n</ul>\n<h4 id=\"常用方法-4\"><a href=\"#常用方法-4\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IteratorTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ArrayList&lt;Integer&gt; nums = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        nums.add(<span class=\"number\">12</span>);</span><br><span class=\"line\">        nums.add(<span class=\"number\">8</span>);</span><br><span class=\"line\">        nums.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">        nums.add(<span class=\"number\">23</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取迭代器</span></span><br><span class=\"line\">        Iterator&lt;Integer&gt; it = nums.iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断集合是否还有元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 返回迭代器的下一个元素</span></span><br><span class=\"line\">            Integer i = it.next();</span><br><span class=\"line\">            <span class=\"comment\">// 删除小于 10 的元素</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">                it.remove();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(nums);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><br><br></p>\n","categories":["后端"],"tags":["Java","集合","Collection"]},{"title":"Java 锁机制","url":"https://zhouxelf.com/2020/08/03/Java 锁机制/","content":"<h1 id=\"java-util-concurrent-locks-包下的常用类\"><a href=\"#java-util-concurrent-locks-包下的常用类\" class=\"headerlink\" title=\"java.util.concurrent.locks 包下的常用类\"></a>java.util.concurrent.locks 包下的常用类</h1><h3 id=\"interface-Lock\"><a href=\"#interface-Lock\" class=\"headerlink\" title=\"interface Lock\"></a>interface Lock</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Lock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lockInterruptibly</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">(<span class=\"keyword\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Condition <span class=\"title\">newCondition</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>获取锁</strong></p>\n<ul>\n<li>lock()</li>\n<li>tryLock()</li>\n<li>tryLock(long time, TimeUnit unit)</li>\n<li>lockInterruptibly()</li>\n</ul>\n<p><strong>释放锁</strong></p>\n<ul>\n<li>unlock()</li>\n</ul>\n<p>lock() 获取锁最常用的一个方法，<code>如果获取的锁已被其它线程获取，则进行等待</code>。采用 Lock，必须主动释放锁，并且发生异常时，不会自动释放锁，因此 <code>Lock 必须在 try catch 块中进行，并且释放锁的操作放在 finally 块中进行</code>，以保证锁一定被释放，防止死锁的发生。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lock lock = ...;</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 业务代码</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>tryLock() 方法是<code>有返回值的</code>，表示尝试获取锁，如果获取成功，返回 true，如果获取失败(即锁已被其它线程获取)，则返回 false，这个方法无论如何都会<code>立即返回，在拿不到锁时不会一直等待</code>。</p>\n<p>tryLock(long time, TimeUnit unit) 和 tryLock() 类似，也有返回值，区别在于这个方法<code>拿不到锁时会等待一定时间</code>，在这个时间内如果还拿不到，则返回 false，如果一开始或者等待期间拿到了锁，就返回 true。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lock lock = ...;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (lock.tryLock()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 业务代码</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取锁失败，处理其它业务</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>lockInterruptibly() 方法比较特殊，当通过这个方法去获取锁时，<code>如果线程正在等待获取锁，则这个线程能够响应中断</code>。比如：当两个线程同时通过 lockInterruptibly() 获取某个锁时，假如线程 A 获取到了锁，而线程 B 只能等待，那么对线程 B 调用 Thread.interrupt() 方法能够中断线程 B 的等待过程。</p>\n<p>由于 lockInterruptibly() 的声明中抛出了异常，所以 lockInterruptibly() 必须放在 try catch 块中或者在调用 lockInterruptibly() 的方法外声明抛出 InterruptedException。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> method <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    Lock lock = ...;</span><br><span class=\"line\">    lock.lockInterruptibly();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 业务代码</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>tips: 当一个线程获取了锁之后，是不会被 interrupt() 方法中断的，单独调用 interrupt() 只能中断阻塞过程中的线程，不能中断正在运行过程中的线程。</p>\n</blockquote>\n<p>因此通过 lockInterruptibly() 方法获取某个锁时，如果获取不到，只能等待，在进行等待的情况下，是可以响应中断的。</p>\n<p>用 synchronized 修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待。</p>\n<h3 id=\"class-ReentrantLock\"><a href=\"#class-ReentrantLock\" class=\"headerlink\" title=\"class ReentrantLock\"></a>class ReentrantLock</h3><p>ReentrantLock 可重入锁，它是唯一实现了 Lock 接口的类，并且提供了更多的方法。</p>\n<p><strong>lock()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LockTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ArrayList&lt;Integer&gt; arrayList = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();  <span class=\"comment\">// lock 是成员变量生效</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Thread thread)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        Lock lock = new ReentrantLock();  // lock 是局部变量不生效</span></span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(thread.getName() + <span class=\"string\">&quot;获取了锁&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                arrayList.add(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// TODO</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(thread.getName() + <span class=\"string\">&quot;释放了锁&quot;</span>);</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> LockTest lt = <span class=\"keyword\">new</span> LockTest();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                lt.insert(Thread.currentThread());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                lt.insert(Thread.currentThread());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>tryLock()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TryLockTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ArrayList&lt;Integer&gt; arrayList = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Thread thread)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lock.tryLock()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(thread.getName() + <span class=\"string\">&quot;获取了锁&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000</span>; i++) &#123;</span><br><span class=\"line\">                    arrayList.add(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// TODO</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                System.out.println(thread.getName() + <span class=\"string\">&quot;释放了锁&quot;</span>);</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(thread.getName() + <span class=\"string\">&quot;获取锁失败&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> TryLockTest tlt = <span class=\"keyword\">new</span> TryLockTest();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                tlt.insert(Thread.currentThread());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                tlt.insert(Thread.currentThread());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>lockInterruptibly()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> LockInterruptiblyTest ltt = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyThread</span><span class=\"params\">(LockInterruptiblyTest ltt)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.ltt = ltt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ltt.insert(Thread.currentThread());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;被中断&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LockInterruptiblyTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Thread thread)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// tips: 如果需要正确中断等待锁的进程，必须将锁放到外面，然后将 InterruptedException 抛出</span></span><br><span class=\"line\">        lock.lockInterruptibly();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(thread.getName() + <span class=\"string\">&quot;获取了锁&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (System.currentTimeMillis() - start &gt;= Integer.MAX_VALUE) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;执行 finally&quot;</span>);</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">            System.out.println(thread.getName() + <span class=\"string\">&quot;释放了锁&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LockInterruptiblyTest ltt = <span class=\"keyword\">new</span> LockInterruptiblyTest();</span><br><span class=\"line\">        MyThread thread_1 = <span class=\"keyword\">new</span> MyThread(ltt);</span><br><span class=\"line\">        MyThread thread_2 = <span class=\"keyword\">new</span> MyThread(ltt);</span><br><span class=\"line\">        thread_1.start();</span><br><span class=\"line\">        thread_2.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 中断等待的进程</span></span><br><span class=\"line\">        thread_2.interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"interface-ReadWriteLock\"><a href=\"#interface-ReadWriteLock\" class=\"headerlink\" title=\"interface ReadWriteLock\"></a>interface ReadWriteLock</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Lock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Lock <span class=\"title\">readLock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Lock <span class=\"title\">writeLock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ReadWriteLock 接口定义了两个方法，<code>一个来获取读锁，一个来获取写锁，也就是说将文件的读写操作分开，分成两个锁来分配给线程，从而使得多个线程可以同时进行读操作</code>。</p>\n<h3 id=\"class-ReentrantReadWriteLock\"><a href=\"#class-ReentrantReadWriteLock\" class=\"headerlink\" title=\"class ReentrantReadWriteLock\"></a>class ReentrantReadWriteLock</h3><p>ReentrantReadWriteLock 提供了丰富的方法，最主要的方法有两个，用来获取读锁和写锁。</p>\n<ul>\n<li>readLock()</li>\n<li>writeLock()</li>\n</ul>\n<p><strong>多个线程同时读操作，synchronized 的效果</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReadReadTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(Thread thread)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (System.currentTimeMillis() - start &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.out.println(thread.getName() + <span class=\"string\">&quot;正在进行读操作&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(thread.getName() + <span class=\"string\">&quot;读操作完毕&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReadReadTest rrt = <span class=\"keyword\">new</span> ReadReadTest();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                rrt.read(Thread.currentThread());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                rrt.read(Thread.currentThread());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>多个线程同时读操作，ReentrantReadWriteLock 的效果</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReentrantReadWriteLockTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantReadWriteLock rrwl = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(Thread thread)</span> </span>&#123;</span><br><span class=\"line\">        rrwl.readLock().lock();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (System.currentTimeMillis() - start &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                System.out.println(thread.getName() + <span class=\"string\">&quot;正在进行读操作&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(thread.getName() + <span class=\"string\">&quot;读操作完毕&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            rrwl.readLock().unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantReadWriteLockTest rrwlt = <span class=\"keyword\">new</span> ReentrantReadWriteLockTest();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                rrwlt.read(Thread.currentThread());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                rrwlt.read(Thread.currentThread());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ol>\n<li>如果一个线程占用了读锁，其它线程申请写锁，申请线程会一直等待释放读锁。</li>\n<li>如果一个线程占用了写锁，其它线程申请读锁或写锁，申请线程会一直等待释放写锁。</li>\n</ol>\n<p><strong>Lock 和 synchronized 的选择</strong></p>\n<ol>\n<li>Lock 是一个接口，而 synchronized 是 Java 中的关键字，是内置的语言实现。</li>\n<li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会发生死锁现象；而 Lock 在发生异常时，如果没有主动通过 unlock() 释放锁，则很可能发生死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。</li>\n<li>Lock 可以让等待锁的线程响应中断 lockInterruptibly()，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。</li>\n<li>通过 Lock() 可以知道有没有获取到锁，synchronized 不行。</li>\n<li>Lock 可以提高多个线程进行读操作的效率。</li>\n</ol>\n<p><code>在性能来说，如果竞争资源不激烈，二者的性能是差不多的，而当竞争资源非常激烈时(即有大量线程同步竞争)，此时 Lock 的性能要远远由于 synchronized，所以说，在具体使用时要根据适当情况选择。</code></p>\n<h1 id=\"锁的相关概念介绍\"><a href=\"#锁的相关概念介绍\" class=\"headerlink\" title=\"锁的相关概念介绍\"></a>锁的相关概念介绍</h1><h3 id=\"乐观锁-vs-悲观锁\"><a href=\"#乐观锁-vs-悲观锁\" class=\"headerlink\" title=\"乐观锁 vs 悲观锁\"></a>乐观锁 vs 悲观锁</h3><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。</p>\n<p>悲观锁: 对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p>\n<p>在 Java 中，<code>synchronized 关键字和 Lock 的实现类都是悲观锁</code>。</p>\n<p>乐观锁: 认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作(例如报错或者自动重试)。</p>\n<p>在 Java 中, <code>乐观锁是通过使用无锁编程来实现，最常采用的是 CAS 算法(Compare And Swap)，Java 原子类中的递增操作就通过 CAS 自旋实现的</code>。</p>\n<h3 id=\"自旋锁-vs-适应性自旋锁\"><a href=\"#自旋锁-vs-适应性自旋锁\" class=\"headerlink\" title=\"自旋锁 vs 适应性自旋锁\"></a>自旋锁 vs 适应性自旋锁</h3><p>阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>\n<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃 CPU 的执行时间，看看持有锁的线程是否很快就会释放锁。</p>\n<p>而<code>为了让当前线程 “稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销，这就是自旋锁</code>。</p>\n<p><img src=\"/images/%E8%87%AA%E9%80%89%E9%94%81.png\"></p>\n<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。<code>如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源</code>。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数(默认是10次，可以使用 -XX:PreBlockSpin 来更改)没有成功获得锁，就应当挂起线程。</p>\n<p><code>自旋锁的实现原理同样也是 CAS</code>，AtomicInteger 中调用 unsafe 进行自增操作的源码中的 do-while 循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>\n<p>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。<code>JDK 6 中变为默认开启</code>，并且引入了自适应的自旋锁(适应性自旋锁)。</p>\n<p><code>自适应意味着自旋的时间(次数)不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</code>。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>\n<h3 id=\"无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁\"><a href=\"#无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁\" class=\"headerlink\" title=\"无锁 vs 偏向锁 vs 轻量级锁 vs 重量级锁\"></a>无锁 vs 偏向锁 vs 轻量级锁 vs 重量级锁</h3><p>这四种锁是指锁的状态，专门针对 synchronized 的。</p>\n<p><strong>无锁</strong></p>\n<p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>\n<p>上面我们介绍的 CAS 原理及应用即是无锁的实现，无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>\n<p><strong>偏向锁</strong></p>\n<p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p>\n<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁，其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>\n<p><code>偏向锁在 JDK 6 及以后的 JVM 里是默认启用的</code>。可以通过 JVM 参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>\n<p><strong>轻量级锁</strong></p>\n<p>指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>\n<p>若当前只有一个等待线程，则该线程通过自旋进行等待，但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>\n<p><strong>重量级锁</strong></p>\n<p>升级为重量级锁时，锁标志的状态值变为 “10”，此时 Mark Word 中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>\n<p><img src=\"/images/%E9%94%81.png\"></p>\n<h3 id=\"可重入锁-vs-非可重入锁\"><a href=\"#可重入锁-vs-非可重入锁\" class=\"headerlink\" title=\"可重入锁 vs 非可重入锁\"></a>可重入锁 vs 非可重入锁</h3><p>如果锁具备可重入性，则称作为可重入锁，<code>sychronized 和 ReentrantLock 都是可重入锁</code>。</p>\n<p><strong>可重入性实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。</strong></p>\n<p>举个栗子，当一个线程执行到某个 synchronized 方法时，比如 method_1，而 method_1 中会调用另一个 synchronized 方法 method_2，此时线程不必重新去申请锁，而是可以直接执行方法 method_2。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"title\">method_1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        method_2();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"title\">method_2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面类的两个方法都被 synchronized 修饰了，假如某一时刻，线程 A 执行到了 method_1，此时线程获取了这个对象的锁，而由于 method_2 也是 synchronized 方法，假如 synchronized 不具备可重入性，此时线程 A 需要重新申请锁。但是这就会造成一个问题，因为线程 A 已经持有了该对象的锁，现在又要获取该对象的锁，这样线程 A 就会一直等待永远获取不到锁。</p>\n<p>由于 synchronized 和 Lock 都具备可重入性，所以不会发生上述现象。</p>\n<h3 id=\"可中断锁-vs-非可中断锁\"><a href=\"#可中断锁-vs-非可中断锁\" class=\"headerlink\" title=\"可中断锁 vs 非可中断锁\"></a>可中断锁 vs 非可中断锁</h3><p>可中断锁，顾名思义，就是可以响应中断的锁。</p>\n<p>线程 A 获取了锁正在执行代码，线程 B 正在等待获取锁，由于等待时间过长不想等了，想先处理其它事情，如果可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p>\n<p>在 Java 中，<code>synchronized 是不可中断锁，Lock 是可中断锁</code>。</p>\n<p>Lock 中 lockInterruptibly() 方法体现了可中断性。</p>\n<h3 id=\"公平锁-vs-非公平锁\"><a href=\"#公平锁-vs-非公平锁\" class=\"headerlink\" title=\"公平锁 vs 非公平锁\"></a>公平锁 vs 非公平锁</h3><p>公平锁：尽量以线程请求锁的顺序来分配锁，比如同时有多个线程在等待一个锁，当这个锁被释放时，等待最久的线程会获得该锁，这就是公平锁。</p>\n<p>非公平锁：无法保证以线程请求锁的顺序来分配锁，可能导致某个或者一些线程永远获取不到锁。</p>\n<p>在 Java 中，<code>synchronized 就是非公平锁</code>，它无法保证等待的线程获取锁的顺序。</p>\n<p><code>ReentrantLock 和 ReentrantReadWriteLock，默认是非公平锁，可以设置为公平锁</code>。</p>\n<p>在 ReentrantLock 中定义了 2 个静态内部类，一个是 NotFairSync，一个是 FairSync ，分别用来实现非公平锁和公平锁。</p>\n<p>ReentrantLock 类中定义了很多方法，比如：</p>\n<ul>\n<li>isFair() 判断锁是否公平锁</li>\n<li>isLocked() 判断锁是否被某线程获取了</li>\n<li>isHeldByCurrentThread() 判断锁是否被当前线程获取了</li>\n<li>hasQueuedThreads() 判断是否有线程在等待该锁</li>\n</ul>\n<blockquote>\n<p>tips: 在 ReentrantReadWriteLock 中也有类似的方法，同样也可以设置为公平锁和非公平锁，不过要记住，ReentrantReadWriteLock 并未实现 Lock 接口，它实现的 是ReadWriteLock 接口。</p>\n</blockquote>\n<h3 id=\"读写锁\"><a href=\"#读写锁\" class=\"headerlink\" title=\"读写锁\"></a>读写锁</h3><p>读写锁将对一个资源的访问分成了 2 个锁，一个读锁和一个写锁。因为有了读写锁，使得多个线程之间的读操作不会发生冲突。</p>\n<p><code>ReadWriteLock 就是读写锁，它是一个接口，ReentrantReadWriteLock 实现了这个接口</code>。</p>\n<p>通过 readLock() 获取读锁，通过 writeLock() 获取写锁。</p>\n<p><br><br></p>\n","categories":["后端"],"tags":["Java","线程安全","锁"]},{"title":"Java 之线程安全","url":"https://zhouxelf.com/2020/05/07/Java 之线程安全/","content":"<h1 id=\"线程安全含义\"><a href=\"#线程安全含义\" class=\"headerlink\" title=\"线程安全含义\"></a>线程安全含义</h1><p>Java 中多线程编程极大地提高了效率，但是也会带来一些隐患，这就是 Java 中的线程安全问题。</p>\n<p>在单线程中不会出现线程安全问题，而在多线程编程中，有可能出现同时访问同一个资源的情况，这种资源可以是：一个变量、一个对象、一个文件、一个数据表等，而多个线程同时访问同一资源的时候，就会存在一个问题。</p>\n<p>线程是 CPU 调度的最小单元，通俗来讲就是，线程的代码是按照顺序来执行的，执行完毕就是结束的一条线。</p>\n<p>由于每个线程执行的过程是不可控的，所以很可能导致最终的结果和预期相违背或者直接导致程序出错。</p>\n<p>举个栗子:</p>\n<p>现在有两个线程往数据表里插入数据，要求不能插入重复的数据。</p>\n<p>某一时刻，两个线程同时读到了数据 X，之后</p>\n<ol>\n<li>两个线程同时查询数据表有没有数据 X，如果同时查到数据 X 不存在；</li>\n<li>两个线程同时将数据 X 插入数据表。</li>\n</ol>\n<p><code>多个线程同时访问一个资源时，会产生程序运行结果和预期不一致的情况</code>，这就是线程安全问题。</p>\n<p>被多个线程共享的资源，称为: <strong>临界资源</strong>，也叫 <strong>共享资源</strong>。</p>\n<blockquote>\n<p>tips: 当多个线程执行一个方法，方法内部的局部变量不是临界资源，因为方法是在栈上执行的，而 Java 栈是线程私有的，因此不会产生线程安全问题。</p>\n</blockquote>\n<p>基本上所有的并发模型在解决线程安全问题时，都采用 <strong>序列化访问临界资源</strong> 的方案，即在同一时刻，只能有一个线程访问临界资源，也成同步互斥访问。</p>\n<p>通常来说，是在访问临界资源的代码前面加上一个锁，当访问完临界资源后释放锁，让其它线程继续访问。</p>\n<h1 id=\"Java-内存模型-JMM\"><a href=\"#Java-内存模型-JMM\" class=\"headerlink\" title=\"Java 内存模型 JMM\"></a>Java 内存模型 JMM</h1><h3 id=\"什么是-JMM\"><a href=\"#什么是-JMM\" class=\"headerlink\" title=\"什么是 JMM\"></a>什么是 JMM</h3><p>JMM(Java Memory Model)是一种基于 <strong>计算机内存模型(定义了共享内存系统中多线程程序读写操作行为的规范)</strong> 的，屏蔽了各种硬件和操作系统访问差异的，保证了 Java 程序在各种平台下对内存的访问都能保证效果一致的机制和规范。</p>\n<p><img src=\"/images/JMM_1.png\"></p>\n<p>多线程执行中，主内存的变量为共享变量，只有一份，多个线程操作主内存中的共享变量时，都要先从主内存中拷贝一份副本到线程工作内存，执行完毕后，都要将变量副本值同步回主内存中。</p>\n<blockquote>\n<p>tips: 线程工作内存是线程私有内存，线程间无法访问对方的工作内存。</p>\n</blockquote>\n<p>线程对一个变量赋值的流程</p>\n<p><img src=\"/images/JMM_2.png\"></p>\n<p>线程工作内存和主内存之间的数据同步就是通过 JMM，它规定了何时以及如何做线程工作内存和主内存之间的数据同步。</p>\n<p>JMM 保证了共享内存的：</p>\n<ul>\n<li>原子性，对共享内存的操作必须是要么全部执行直到执行结束，且中间过程不能被任何外部因素打断，要么就不执行。</li>\n<li>可见性，多线程操作共享内存时，执行结果能够及时的同步到共享内存，确保其他线程对此结果及时可见。</li>\n<li>有序性，程序的执行顺序按照代码顺序执行，在单线程环境下，程序的执行都是有序的，但是在多线程环境下，JMM 为了性能优化，编译器和处理器会对指令进行重排，程序的执行会变成无序。</li>\n</ul>\n<h1 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h1><p>Java 提供了一系列的关键字和类来保证线程安全，主要有以下几种：</p>\n<ul>\n<li>synchronized 关键字</li>\n<li>volatile 关键字</li>\n<li>java.util.concurrent.atomic 包下一系列原子类</li>\n<li>Lock 锁</li>\n</ul>\n<h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><p><strong>1&gt; 保证方法或代码块操作的原子性</strong></p>\n<p>synchronized 保证方法内部或代码块内部资源(数据)的互斥访问。即同一时间，由同一个 <strong>Monitor(监视锁)</strong> 监视的代码，最多只能有一个线程在访问。</p>\n<p>被 synchronized 描述的方法或者代码块在多线程环境下同一时间只能由同一个线程访问，在持有当前 Monitor 的线程执行完成之前，其它线程想要调用就必须排队，直到上一个持有当前 Monitor 的线程执行结束，释放 Monitor，下一个线程才能获得 Monitor 执行。</p>\n<blockquote>\n<p>tips: 如果存在多个 Monitor 的情况下，多个 Monitor 之间是不互斥的。多个 Monitor 的情况出现在自定义多个锁分别来描述不同的方法或代码块，synchronized 在描述代码块时可以指定自定义 Monitor ，默认为 this 即当前类。</p>\n</blockquote>\n<p><strong>2&gt; 保证监视资源的可见性</strong></p>\n<p>保证多线程环境下对监视资源的数据同步。任何线程在获取到 Monitor 的第一时间，会将共享内存中的数据复制到线程工作内存中，任何线程释放 Monitor 的第一时间，会将线程工作内存中的数据复制到共享内存中。</p>\n<p><strong>3&gt; 保证线程间操作的有序性</strong></p>\n<p>synchronized 的原子性保证了由其描述的方法或代码块的操作具有有序性，同一时间最多只能由一个线程访问，<strong>不会触发 JMM 指令重排机制</strong>。</p>\n<p><code>对于 synchronized 方法或代码块，当出现异常时，JMM 会自动释放当前线程占用的锁，因此不会由于异常导致出现死锁现象。</code></p>\n<hr>\n<p><strong>在 Java 中，每一个对象都有一个锁标记(Monitor)。</strong></p>\n<ul>\n<li>当一个线程正在访问一个对象的 synchronized 方法时，<code>其它线程不能访问该对象的其它 synchronized 方法</code>。因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其它线程就无法获取该对象的锁了，所以无法访问该对象的其它 synchronized 方法。</li>\n<li>当一个线程正在访问一个对象的 synchronized 方法时，<code>其它线程可以访问该对象的非 synchronized 方法</code>。这个原因是，访问非 synchronized 方法不需要获取该对象的锁，如果一个方法没被 synchronized 修饰，说明该方法不会访问临界资源，那其它线程随便访问该方法。</li>\n<li>如果某一时刻，线程 A 需要访问对象 obj_1 的 synchronized 方法 fun_1，线程 B 需要访问对象 obj_2 的 synchronized 方法 fun_1，即使 obj_1、obj_2 都是某个类的对象，也不会产生线程安全问题，因为访问的是不同的对象，不存在互斥问题。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadSYNTest_1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> y = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. synchronized 方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">count</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        x = x + <span class=\"number\">1</span>;</span><br><span class=\"line\">        y = y + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. synchronized 代码块</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">count</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;  <span class=\"comment\">// 获取当前对象的锁，也可以是类中的一个属性  </span></span><br><span class=\"line\">            x = x + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        y = y + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">runTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt; <span class=\"number\">1_00000</span>; i++) &#123;</span><br><span class=\"line\">                    count();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;final x from 1: &quot;</span> + x);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;final y from 1: &quot;</span> + y);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt; <span class=\"number\">1_00000</span>; i++) &#123;</span><br><span class=\"line\">                    count();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;final x from 2: &quot;</span> + x);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;final y from 2: &quot;</span> + y);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ThreadSYNTest_1().runTest();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>synchronized 代码块比方法更灵活，因为可能一个方法中只有一部分代码需要同步，如果此时对这个方法用 synchronized 修饰，就会影响程序的效率。</p>\n<p><strong>在 Java 中，每一个类也有一个锁标记(Monitor)，用来控制对 static 数据成员的并发访问。</strong></p>\n<ul>\n<li>某一时刻，一个线程执行一个对象的非 static synchronized 方法，另一个线程执行这个对象所属类的 static synchronized 方法，这样不会发生互斥现象，因为访问 static synchronized 方法占用的是类锁，而访问非 static synchronized 方法占用的是对象锁，类锁和对象锁不互斥。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadSYNTest_2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">print_1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;x start&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;x end&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">print_2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;y start&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;y end&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ThreadSYNTest_2 t = <span class=\"keyword\">new</span> ThreadSYNTest_2();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                t.print_1();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                ThreadSYNTest_2.print_2();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><p>保证被 volatile 关键字描述的变量的操作具有 <strong>可见性</strong> 和 <strong>有序性</strong> (禁止指令重排)。</p>\n<p>注意：</p>\n<ol>\n<li>volatile 只对基本类型(byte、char、short、int、long、float、double、boolean)的赋值操作和对象的引用赋值操作有效。</li>\n<li>对于 i++ 此类复合操作，volatile 无法保证其有序性和原子性。</li>\n<li>相对 synchronized 来说，volatile 更加轻量一些。</li>\n</ol>\n<h3 id=\"java-util-concurrent-atomic\"><a href=\"#java-util-concurrent-atomic\" class=\"headerlink\" title=\"java.util.concurrent.atomic\"></a>java.util.concurrent.atomic</h3><p>java.util.concurrent.atomic 包提供了一系列的 AtomicBoolean、AtomicInteger、AtomicLong 等类，使用这些类来声明变量可以保证对其操作具有 <strong>原子性</strong> 来保证线程安全。</p>\n<p>实现原理和 synchronized 使用 Monitor(监视锁) 来保证资源在多线程下 <strong>阻塞互斥</strong> 访问不同，java.util.concurrent.atomic 包下的各原子类是基于 <strong>CAS(ComparAndSwap)</strong> 操作原理实现的。</p>\n<p>CAS 又称无锁操作，是一种乐观锁策略，原理就是多线程环境下各线程访问共享变量不会加锁阻塞排队，线程不会被挂起。通俗来讲就是一直循环对比，如果访问冲突就重试，知道没有冲突为止。</p>\n<h3 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h3><p>Lock 也在 java.util.concurrent 包下，是一个接口，其中定义一系列锁的操作方法，Lock 接口主要有 <strong>ReentrantLock、ReentrantReadWriteLock.ReadLock、ReentrantReadWriteLock.WriteLock</strong> 实现类。</p>\n<p>与 synchronized 不同是 Lock 提供了获取锁和释放锁等相关接口，使得使用上更加灵活，同时也可以做更加复杂的操作。</p>\n<p><strong>已经有了 sychronized，为什么还会出现 Lock 呢？</strong></p>\n<p>线程执行 synchronized 修饰的方法或代码块会获取锁，获取锁的线程释放锁会出现两种情况：</p>\n<ol>\n<li>获取锁的线程执行完了代码，线程正常释放锁；</li>\n<li>获取锁的线程执行出现异常，JMM 让线程自动释放锁。</li>\n</ol>\n<p>如果获取锁的线程没有出现异常，但是要等待 IO 或者其它原因(比如调用了 sleep 方法)被阻塞了，但是有没有释放锁，其它线程就只能一直等待，极大的影响效率。因此就需要一种机制避免等待的线程一直等待下去，通过 Lock 就可以实现。</p>\n<p>再举个栗子：当多个线程读写文件时，读写、写写会发生冲突，但是读读是不会发生冲突的，但是采用 synchronized 来实现同步的话，多个线程如果只是同步读的情况，一部分线程也需要等待。因此需要一种机制，保证多个线程同时读的情况不需要等待，通过 Lock 也可以实现。</p>\n<p>此外，Lock 可以检测线程有没有获取到锁，synchronize 是无法做到的。</p>\n<p>总结来说，Lock 相比 synchronized 更加灵活，但是需要注意几点：</p>\n<ol>\n<li><code>sychronized 是 Java 的关键字，是内置特性，Lock 不是 Java 内置的，是一个类，通过这个类实现同步访问。</code></li>\n<li><code>Lock 需要手动释放锁，synchronized 的方法或代码块执行完之后，系统会自动让线程释放锁，而 Lock 必须用户手动释放，如果没有主动释放，就可能出现死锁。</code></li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><strong>1&gt; 出现线程安全的问题的原因</strong></p>\n<p>多线程并发环境下，多个线程共同访问同一共享内存资源时，其中一个线程对资源进行写操作的中间(写入已经开始，但还没结束)，其它线程对这个写了一半的资源进行了读操作，或者对这个写了一半的资源进行了写操作，导致此资源出现数据错误。</p>\n<p><strong>2&gt; 如何避免出现线程安全问题？</strong></p>\n<ul>\n<li>保证共享资源在同一时间只能由一个线程进行操作(原子性、有序性)。</li>\n<li>线程操作的结果及时刷新，保证其它线程可以立即获取到修改后的最新数据(可见性)。</li>\n</ul>\n<p><br><br></p>\n","categories":["后端"],"tags":["Java","线程","线程安全"]},{"title":"Java 之线程池","url":"https://zhouxelf.com/2020/04/26/Java 之线程池/","content":"<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>对于多个任务，采用并发编程处理是一个提高处理效率的方式。在 Java 中，可以在需要的时候创建一个线程，实现也非常方便，但是有一个问题，如果并发线程的数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程会大大降低系统整体运行的效率，因为频繁创建、销毁线程会带来额外的开销。</p>\n<p><strong>new Thread 的弊端</strong></p>\n<ol>\n<li>每次 new Thread 新建线程对象性能差。</li>\n<li>线程缺乏统一管理，可能无限制的新建线程，线程之间互相竞争，很可能占用过多系统资源导致死机或 OOM。</li>\n<li>缺乏更多功能，比如定时执行、定期执行、线程中断等。</li>\n</ol>\n<h2 id=\"什么是线程池？\"><a href=\"#什么是线程池？\" class=\"headerlink\" title=\"什么是线程池？\"></a>什么是线程池？</h2><p>Java 提供线程池来处理这个问题，每次创建一个线程，线程执行完任务后不直接销毁，而是放入线程池里，下次需要创建线程时，直接从线程池里取一个线程，通过减少频繁创建、销毁线程的开销来提高运行效率。</p>\n<p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中。</p>\n<p><strong>线程池的好处</strong></p>\n<ol>\n<li>重用已有的线程，减少对象创建、消亡的开销，性能佳。</li>\n<li>可有效控制最大并发线程，提高线程资源的使用率，同时避免过多资源竞争，避免堵塞。</li>\n<li>提供定时执行、定期执行、单线程、并发数控制等功能。</li>\n</ol>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p>Java 中线程池的核心实现类是 ThreadPoolExecutor，涉及到的抽象类和接口如下:</p>\n<p><img src=\"/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E7%B1%BB.png\"></p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger ctl = <span class=\"keyword\">new</span> AtomicInteger(ctlOf(RUNNING, <span class=\"number\">0</span>));</span><br></pre></td></tr></table></figure>\n\n<p>ctl 这个 AtomicInteger 类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态(runState)和线程池内有效线程的数量 (workerCount)，高 3 位保存 runState，低 29 位保存 workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。</p>\n<p>关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">runStateOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>     </span>&#123; <span class=\"keyword\">return</span> c &amp; ~CAPACITY; &#125; <span class=\"comment\">//计算当前运行状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">workerCountOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>  </span>&#123; <span class=\"keyword\">return</span> c &amp; CAPACITY; &#125;  <span class=\"comment\">//计算当前线程数量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">ctlOf</span><span class=\"params\">(<span class=\"keyword\">int</span> rs, <span class=\"keyword\">int</span> wc)</span> </span>&#123; <span class=\"keyword\">return</span> rs | wc; &#125;   <span class=\"comment\">//通过状态和线程数生成 ctl</span></span><br></pre></td></tr></table></figure>\n\n<p>ThreadPoolExecutor 五种运行状态，分别为:</p>\n<table>\n<thead>\n<tr>\n<th>运行状态</th>\n<th>状态描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>RUNNING</td>\n<td>能接受新提交的任务，并且也能处理阻塞队列中的任务</td>\n</tr>\n<tr>\n<td>SHUTDOWN</td>\n<td>关闭状态，不再接受新提交的任务，但可以继续处理阻塞队列中已保存的任务</td>\n</tr>\n<tr>\n<td>STOP</td>\n<td>不能接收新任务，也不处理队列中的任务，会中断正在处理任务的线程</td>\n</tr>\n<tr>\n<td>TIDYING</td>\n<td>所有的任务都已经终止，workerCount(有效线程数)为 0</td>\n</tr>\n<tr>\n<td>TERMINATED</td>\n<td>terminated() 方法执行完后进入该状态</td>\n</tr>\n</tbody></table>\n<p><strong>示意图</strong></p>\n<p><img src=\"/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\"></p>\n<h2 id=\"任务调度\"><a href=\"#任务调度\" class=\"headerlink\" title=\"任务调度\"></a>任务调度</h2><p>所有的任务的调度都是有 execute() 方法完成的，执行该方法之后：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。</p>\n<ol>\n<li>首先检查线程池运行状态，如果不是 RUNNING，直接拒绝，线程池要保证在 RUNNING 的状态下执行任务。</li>\n<li>如果 workerCount &lt; corePoolSize，则创建并启动一个线程来执行提交的新任务。</li>\n<li>如果 workerCount &gt;= corePoolSize，且阻塞队列未满，则将任务添加到阻塞队列。</li>\n<li>如果 workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建一个新线程来执行新提交的任务。</li>\n<li>如果 workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满，则根据拒绝策略来处理该任务，默认的处理方式是直接抛异常。</li>\n</ol>\n<p><strong>示意图</strong></p>\n<p><img src=\"/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png\"></p>\n<h2 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h2><p>该类提供 4 个构造方法，参数如下:</p>\n<ul>\n<li>corePoolSize 线程池中保留的线程数，即使它们处于空闲状态，除非设置了 allowCoreThreadTimeOut</li>\n<li>maximumPoolSize 线程池中允许的最大线程数</li>\n<li>keepAliveTime 当线程数大于核心数时，多余空闲线程在终止之前等待新任务的最长时间</li>\n<li>unit keepAliveTime 参数的时间单位</li>\n<li>workQueue 在执行任务之前，用于保存任务的队列，此队列仅 Runnable execute 方法提交的 Runnable 任务</li>\n<li>threadFactory 执行程序创建新线程时使用的工厂</li>\n<li>handler 由于达到线程边界和队列容量而阻止执行时使用的处理程序</li>\n</ul>\n<h2 id=\"Executors\"><a href=\"#Executors\" class=\"headerlink\" title=\"Executors\"></a>Executors</h2><p>该类提供四个方法创建线程池:</p>\n<ul>\n<li>newCachedThreadPool() 创建一个可缓冲的线程池，可根据需要灵活调整线程池的配置</li>\n<li>newFixedThreadPool() 创建一个固定长度的线程池，可控制最大并发数，超出的线程在队列中等待</li>\n<li>newScheduledThreadPool() 创建一个固定长度的线程池，支持定时任务和周期性任务</li>\n<li>newSingleThreadExecutor() 创建一个单线程的线程池，只会使用唯一的线程执行队列中的任务，保证所有任务按照指定顺序执行。</li>\n</ul>\n<p><br><br></p>\n","categories":["后端"],"tags":["Java","线程","线程池"]},{"title":"Java 之多线程","url":"https://zhouxelf.com/2020/04/15/Java 之多线程/","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><ul>\n<li>Java 给多线程编程提供了内置的支持。</li>\n<li>线程：一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。一个线程不能独立存在，它必须是进程的一部分。</li>\n<li>进程：一个进程包括由操作系统分配的内存空间，包含 <strong>一个或多个</strong> 线程。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。</li>\n<li>多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。</li>\n</ul>\n<h1 id=\"一个线程的生命周期\"><a href=\"#一个线程的生命周期\" class=\"headerlink\" title=\"一个线程的生命周期\"></a>一个线程的生命周期</h1><p><img src=\"/images/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpeg\"></p>\n<ul>\n<li>新建状态：使用 new 关键字和 Thread 类或及其子类建立一个线程对象后，该线程对象就处于新建状态，直到执行 start()。</li>\n<li>就绪状态：调用 start() 之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，等待 JVM 里线程调度器的调度。</li>\n<li>运行状态：就绪状态的线程获取 CPU 资源，就可以执行 run()，之后线程处于运行状态。该状态的线程最为复杂，它可以变为阻塞状态、就绪状态或死亡状态。</li>\n<li>阻塞状态：如果线程执行了 sleep()、suspend() 等方法，失去所占资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后重新进入就绪状态。阻塞状态还可以分为三种：<ul>\n<li>等待阻塞：运行中的线程执行 wait() 方法，进入等待阻塞状态；</li>\n<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)；</li>\n<li>其他阻塞：通过调用线程的 sleep() 或 join() 发出 I/O 请求时，线程就进入阻塞状态。当 sleep() 状态超时，join() 等待线程终止或超时，或 I/O 处理完毕，线程重新进入就绪状态。</li>\n</ul>\n</li>\n<li>死亡状态：一个运行状态的线程完成任务或者其他终止条件发生时，线程就会切换到终止状态。</li>\n</ul>\n<p><img src=\"/images/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpeg\"></p>\n<h1 id=\"线程的优先级\"><a href=\"#线程的优先级\" class=\"headerlink\" title=\"线程的优先级\"></a>线程的优先级</h1><ul>\n<li>每个 Java 线程都有一个优先级，有助于操作系统确定调度顺序。</li>\n<li>Java 线程的优先级是一个整数，取值范围是 1-10 (Thread.MIN_PRIORITY - MAX_PRIORITY)。</li>\n<li>每个 Java 线程默认分配一个优先级 5(NORM_PRIORITY)。</li>\n<li>具有优先级搞的线程应该对程序更重要，应该在优先级低的线程之前分配处理器资源。但是，线程的优先级不能保证线程执行的顺序，也非常依赖于平台。</li>\n</ul>\n<h1 id=\"创建一个线程\"><a href=\"#创建一个线程\" class=\"headerlink\" title=\"创建一个线程\"></a>创建一个线程</h1><p>Java 提供了三种方法创建线程：</p>\n<ul>\n<li>通过实现 Runnable 接口；</li>\n<li>通过继承 Thread 类本身；</li>\n<li>通过 Callable 和 Future 创建线程。</li>\n</ul>\n<h2 id=\"通过实现-Runnable-接口\"><a href=\"#通过实现-Runnable-接口\" class=\"headerlink\" title=\"通过实现 Runnable 接口\"></a>通过实现 Runnable 接口</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunnableDemo</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Thread t;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String threadName;</span><br><span class=\"line\"></span><br><span class=\"line\">    RunnableDemo(String name) &#123;</span><br><span class=\"line\">        threadName = name;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Creating &quot;</span> + threadName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Running &quot;</span> + threadName);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">4</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Thread: &quot;</span> + threadName + <span class=\"string\">&quot;, &quot;</span> + i);</span><br><span class=\"line\">                <span class=\"comment\">// 线程睡眠</span></span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Thread &quot;</span> + threadName + <span class=\"string\">&quot;interrupted.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Thread &quot;</span> + threadName + <span class=\"string\">&quot; exiting.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Starting &quot;</span> + threadName);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            t = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">this</span>, threadName);</span><br><span class=\"line\">            t.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadTest_1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        RunnableDemo R1 = <span class=\"keyword\">new</span> RunnableDemo(<span class=\"string\">&quot;Thread-1&quot;</span>);</span><br><span class=\"line\">        R1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        RunnableDemo R2 = <span class=\"keyword\">new</span> RunnableDemo(<span class=\"string\">&quot;Thread-2&quot;</span>);</span><br><span class=\"line\">        R2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"通过继承-Thread-类本身\"><a href=\"#通过继承-Thread-类本身\" class=\"headerlink\" title=\"通过继承 Thread 类本身\"></a>通过继承 Thread 类本身</h2><p>本质上也是实现了 Runnable 接口的一个实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadDemo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Thread t;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String threadName;</span><br><span class=\"line\"></span><br><span class=\"line\">    ThreadDemo(String name) &#123;</span><br><span class=\"line\">        threadName = name;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Creating &quot;</span> + threadName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Running &quot;</span> + threadName);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">4</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Thread: &quot;</span> + threadName + <span class=\"string\">&quot;, &quot;</span> + i);</span><br><span class=\"line\">                <span class=\"comment\">// 线程睡眠</span></span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Thread &quot;</span> + threadName + <span class=\"string\">&quot;interrupted.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Thread &quot;</span> + threadName + <span class=\"string\">&quot; exiting.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Starting &quot;</span> + threadName);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            t = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">this</span>, threadName);</span><br><span class=\"line\">            t.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadTest_2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ThreadDemo T1 = <span class=\"keyword\">new</span> ThreadDemo(<span class=\"string\">&quot;Thread-1&quot;</span>);</span><br><span class=\"line\">        T1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        ThreadDemo T2 = <span class=\"keyword\">new</span> ThreadDemo(<span class=\"string\">&quot;Thread-2&quot;</span>);</span><br><span class=\"line\">        T2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"通过-Callable-和-Future-创建线程\"><a href=\"#通过-Callable-和-Future-创建线程\" class=\"headerlink\" title=\"通过 Callable 和 Future 创建线程\"></a>通过 Callable 和 Future 创建线程</h2><ol>\n<li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值；</li>\n<li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值；</li>\n<li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程；</li>\n<li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableThreadTest</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">Integer</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; - &quot;</span> + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        CallableThreadTest ctt = <span class=\"keyword\">new</span> CallableThreadTest();</span><br><span class=\"line\">        FutureTask&lt;Integer&gt; ft = <span class=\"keyword\">new</span> FutureTask&lt;&gt;(ctt);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 的循环变量 i 的值: &quot;</span> + i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">new</span> Thread(ft, <span class=\"string\">&quot;有返回值的线程&quot;</span>).start();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;子线程的返回值: &quot;</span> + ft.get());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"创建线程的三种方式对比\"><a href=\"#创建线程的三种方式对比\" class=\"headerlink\" title=\"创建线程的三种方式对比\"></a>创建线程的三种方式对比</h1><ul>\n<li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li>\n<li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li>\n</ul>\n<h1 id=\"线程的几个主要概念\"><a href=\"#线程的几个主要概念\" class=\"headerlink\" title=\"线程的几个主要概念\"></a>线程的几个主要概念</h1><ul>\n<li>线程同步</li>\n<li>线程间通信</li>\n<li>线程死锁</li>\n<li>线程控制：挂起、停止和恢复</li>\n</ul>\n<h1 id=\"多线程的使用\"><a href=\"#多线程的使用\" class=\"headerlink\" title=\"多线程的使用\"></a>多线程的使用</h1><p>有效利用多线程的关键是理解程序是 <strong>并发执行</strong> 而不是 <strong>串行执行</strong> 的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。</p>\n<p>通过对多线程的使用，可以编写出非常高效的程序。<strong>不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了</strong>。</p>\n<p>请记住，<strong>上下文的切换开销也很重要</strong>，如果你创建了太多的线程，CPU  花费在上下文的切换的时间将多于执行程序的时间！</p>\n<p><br><br></p>\n","categories":["后端"],"tags":["Java","线程"]},{"title":"理解同步、异步、阻塞、非阻塞","url":"https://zhouxelf.com/2020/01/17/理解同步、异步、阻塞、非阻塞/","content":"<h1 id=\"IO-操作\"><a href=\"#IO-操作\" class=\"headerlink\" title=\"IO 操作\"></a>IO 操作</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>IO 分成两个阶段：</p>\n<ol>\n<li>数据准备</li>\n<li>内核空间复制数据到用户空间(用户进程缓冲区)</li>\n</ol>\n<blockquote>\n<p>tips: 一旦拿到了数据就变成了数据操作，不再是 IO。</p>\n</blockquote>\n<p>阻塞 IO 和非阻塞 IO 的区别在于第 1 阶段发起 IO 请求是否被阻塞，如果阻塞直到请求完成就是传统的阻塞 IO，如果不阻塞就是非阻塞 IO。</p>\n<p>同步 IO 和异步 IO 的区别在于第 2 阶段是否被阻塞，如果不阻塞，而是操作系统做完 IO 操作再将结果返回，那么就是异步 IO。</p>\n<p>一般来讲：</p>\n<p>阻塞 IO 模型、非阻塞 IO 模型、IO 复用模型(select/poll/epoll)、信号驱动 IO 模型都属于同步 IO，因为阶段 2 都是阻塞的(尽管时间很短)。</p>\n<h2 id=\"五种-IO-模型的比较\"><a href=\"#五种-IO-模型的比较\" class=\"headerlink\" title=\"五种 IO 模型的比较\"></a>五种 IO 模型的比较</h2><p><img src=\"/images/IO%E6%A8%A1%E5%9E%8B.png\"></p>\n<h1 id=\"同步异步-IO、阻塞非阻塞-IO\"><a href=\"#同步异步-IO、阻塞非阻塞-IO\" class=\"headerlink\" title=\"同步异步 IO、阻塞非阻塞 IO\"></a>同步异步 IO、阻塞非阻塞 IO</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>同步异步 IO 的概念</p>\n<ul>\n<li>同步 IO：用户进程发起 IO 请求后，需要等待或轮询内核 IO 操作完成后才能继续执行。</li>\n<li>异步 IO：用户进程发起 IO 请求后，不需要等待或轮询内核 IO 操作是否完成，内核 IO 操作完成后会通知用户进程，或调用用户进程注册的回调函数。</li>\n</ul>\n<p>阻塞非阻塞 IO 的概念</p>\n<ul>\n<li>阻塞 IO：IO 操作需要彻底完成后，才能返回用户空间。</li>\n<li>非阻塞 IO：IO 操作被调用后立即返回一个状态值，无需登台 IO 操作彻底完成。</li>\n</ul>\n<h2 id=\"异步-IO-模型\"><a href=\"#异步-IO-模型\" class=\"headerlink\" title=\"异步 IO 模型\"></a>异步 IO 模型</h2><p><img src=\"/images/%E5%BC%82%E6%AD%A5IO.png\"></p>\n<h2 id=\"阻塞-IO-模型\"><a href=\"#阻塞-IO-模型\" class=\"headerlink\" title=\"阻塞 IO 模型\"></a>阻塞 IO 模型</h2><p><img src=\"/images/%E9%98%BB%E5%A1%9E.png\"></p>\n<h2 id=\"非阻塞-IO-模型\"><a href=\"#非阻塞-IO-模型\" class=\"headerlink\" title=\"非阻塞 IO 模型\"></a>非阻塞 IO 模型</h2><p><img src=\"/images/%E9%9D%9E%E9%98%BB%E5%A1%9E.png\"></p>\n<h2 id=\"IO-复用模型\"><a href=\"#IO-复用模型\" class=\"headerlink\" title=\"IO 复用模型\"></a>IO 复用模型</h2><p><img src=\"/images/IO%E5%A4%8D%E7%94%A8.jpg\"></p>\n<p><br><br></p>\n","categories":["后端"],"tags":["操作系统"]},{"title":"Java NIO 原理","url":"https://zhouxelf.com/2020/01/10/Java NIO 原理/","content":"<h1 id=\"Java-IO-读写原理\"><a href=\"#Java-IO-读写原理\" class=\"headerlink\" title=\"Java IO 读写原理\"></a>Java IO 读写原理</h1><p><strong>无论是 Socket 的读写还是文件的读写，在 Java 层面的应用开发或者 Linux 系统底层的开发，都属于输入(Input)和输出(Output)的处理，简称为 IO 读写。</strong></p>\n<p>用户程序进行 IO 读写，基本都会用到 Read/Write 两大系统调用。</p>\n<p>一个基础知识：Read 系统调用，并不是把数据直接从物理设备读到内存，Write 系统调用也不是直接把数据写入到物理设备。</p>\n<ul>\n<li>Read 系统调用，是把数据从内核缓冲区复制到进程缓冲区；</li>\n<li>Write 系统调用，是把数据从进程缓冲区复制到内核缓冲区。</li>\n</ul>\n<p>这两个系统调用，都不负责数据在内核缓冲区和磁盘之前的交换，底层的读写交换，是由操作系统 Kernel 内核实现的。</p>\n<h3 id=\"内核缓冲区和进程缓冲区\"><a href=\"#内核缓冲区和进程缓冲区\" class=\"headerlink\" title=\"内核缓冲区和进程缓冲区\"></a>内核缓冲区和进程缓冲区</h3><p>系统调用前需要先保存之前的进程数据和状态等信息，结束调用后还需要恢复之前的数据，为了减少这种损耗时间、损耗性能的系统调用，于是出现的缓冲区。</p>\n<p><strong>在 Linux 系统中，系统内核有个内核缓冲区；每个进程有自己的进程缓冲区。</strong></p>\n<p>有了缓冲区，操作系统使用 Read 函数把数据从内核缓冲区复制到进程缓冲区，Write 函数把数据从进程缓冲区复制到内核缓冲区中。数据不是实时进行 IO，而是暂存在缓冲区，等缓冲区数据达到一定量的时候，再进行 IO 调用，提升性能。</p>\n<h3 id=\"Java-IO-读写的底层流程\"><a href=\"#Java-IO-读写的底层流程\" class=\"headerlink\" title=\"Java IO 读写的底层流程\"></a>Java IO 读写的底层流程</h3><p>用户程序进行 IO 的读写，基本上会用到系统调用 Read、Write，系统调用的时候，数据在内核缓冲区和进程缓冲区之间交换，不等价于数据在内核缓冲区和磁盘之间的交换。</p>\n<p><img src=\"/images/%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4.png\"></p>\n<h1 id=\"四种主要的-IO-模型\"><a href=\"#四种主要的-IO-模型\" class=\"headerlink\" title=\"四种主要的 IO 模型\"></a>四种主要的 IO 模型</h1><ul>\n<li>同步阻塞 IO (Blocking IO)</li>\n<li>同步非阻塞 IO (Non-Blocking IO)</li>\n<li>IO 多路复用 (IO Multiplexing)</li>\n<li>异步 IO (Asynchronous IO)</li>\n</ul>\n<h3 id=\"同步阻塞-IO-Blocking-IO\"><a href=\"#同步阻塞-IO-Blocking-IO\" class=\"headerlink\" title=\"同步阻塞 IO (Blocking IO)\"></a>同步阻塞 IO (Blocking IO)</h3><p>在 Linux 的 Java 进程中，默认情况下所有的 socket 都是 Blocking IO。在这种模型中，用户进程冲 IO 系统调用开始，一直到系统调用返回，这段时间都是阻塞的。</p>\n<p><img src=\"/images/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO.jpeg\"></p>\n<p>BIO 特点：</p>\n<p>用户进程的线程发起系统调用，内核进行 IO 执行的两个阶段，用户线程都被阻塞了。 </p>\n<p>BIO 优点：</p>\n<p>程序简单，在阻塞等待数据期间，用户线程挂起，基本不会占用 CPU 资源。</p>\n<p>BIO 缺点：</p>\n<p>一般情况线，每个连接配置一个独立的线程，这在并发量小的情况下，没什么问题。但是，在高并发场景下，需要大量的线程来维护大量的连接，内存、线程切换开销会非常巨大，基本上，BIO 在高并发场景下是不可用的。</p>\n<h3 id=\"同步非阻塞-IO-None-Blocking-IO\"><a href=\"#同步非阻塞-IO-None-Blocking-IO\" class=\"headerlink\" title=\"同步非阻塞 IO (None Blocking IO)\"></a>同步非阻塞 IO (None Blocking IO)</h3><p>在 Linux 系统下，可以设置使 socket 变为 non-blocking IO，这种模型一旦开始系统调用，会出现以下两种情况：</p>\n<ol>\n<li>在内核缓冲区没有数据的情况下，系统调用立即返回，返回一个调用失败的信息。</li>\n<li>在内核缓冲区有数据的情况下，是阻塞的，直到数据从内核缓冲区复制进用户进程缓冲区，复制完成，系统调用返回成功。</li>\n</ol>\n<p><img src=\"/images/%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO.jpeg\"></p>\n<p>NIO 特点：</p>\n<p>用户程序的线程需要不断的进行 IO 系统调用，轮询数据是否准备好，如果没有准备好，继续轮询，直到完成系统调用为止。</p>\n<p>NIO 优点：</p>\n<p>每次发起系统调用，在内核等待数据过程中可以立即返回，用户线程不会被阻塞，实时性较好。</p>\n<p>NIO 缺点：</p>\n<p>同一个线程，需要不断的重复发起系统调用，这种轮询，将会不断地询问内核，将占用大量的 CPU 时间，系统资源利用率较低。</p>\n<blockquote>\n<p>tips: 强调一下，Java NIO(New IO) 不是 IO 模型中的 NIO 模型，而是另外一种模型，叫做 IO 多路复用模型(IO Multiplexing)。</p>\n</blockquote>\n<h3 id=\"IO-多路复用-IO-Multiplexing\"><a href=\"#IO-多路复用-IO-Multiplexing\" class=\"headerlink\" title=\"IO 多路复用 (IO Multiplexing)\"></a>IO 多路复用 (IO Multiplexing)</h3><p>为了避免同步非阻塞中轮询等待的问题，出现了一种优化方案，这就是 IO 多路复用 (IO Multiplexing)。</p>\n<p>IO 多路复用模型，就是通过一种新的系统调用，一个进程可以监视多个文件描述符，一旦某个描述符就绪(一般是内核缓冲区可读/可写)，内核就能够通知程序进行相应的系统调用。</p>\n<p>目前支持 IO 多路复用的系统调用有 select、poll、epoll。select 系统调用在目前几乎所有的操作系统上都有支持，具有良好的跨平台性，epoll 系统调用是在 Linux2.6 内核中率先实现的，是 select 系统调用的 Linux 增强版本。</p>\n<p>IO 多路复用的基本原理：单个线程不断的轮询 select、poll、epoll 系统调用所负责的成百上千个 socket 连接，当某个或某些 socket 网络连接的数据到达了，就返回这些可以读写的连接。因此，通过一次 select、poll、epoll 系统调用，就能查询到可以读写的一个甚至成百上千个网络连接。</p>\n<p><img src=\"/images/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpeg\"></p>\n<p>IO 多路复用特点：</p>\n<p>IO 多路复用，建立在操作系统内核能够提供多路分离系统调用 select、poll、epoll 的基础上，该模型下的程序需要用到两个系统调用，一个 select、poll、epoll 查询调用，一个 IO 读写调用。</p>\n<p>和 NIO 模型一样，IO 多路复用也需要轮询，负责 select、poll、epoll 查询调用的线程，需要不断的轮询，查出可以进行 IO 操作的连接，不同的是一次查询能查成百上千连接。</p>\n<p>另外，IO 多路复用和 NIO 是有关系的，对于每一个查询的 socket，一般都设置成 non-blocking，只是这一点对用户是透明的。</p>\n<p>IO 多路复用优点：</p>\n<p>可以同时处理成千上万个连接，与一条线程对应一个连接相比，系统不必创建线程，也不必维护这些线程，从而大大减少了系统的开销。</p>\n<p>IO 多路复用缺点：</p>\n<p>本质上，select、poll、epoll 系统调用，属于同步 IO，也是阻塞的，都需要在读写的数据就绪后，自己负责读写，也就是说这个读写过程是阻塞的。</p>\n<h3 id=\"异步-IO-Asynchronous-IO\"><a href=\"#异步-IO-Asynchronous-IO\" class=\"headerlink\" title=\"异步 IO (Asynchronous IO)\"></a>异步 IO (Asynchronous IO)</h3><p>为了优化掉最后一点阻塞，于是出现了异步 IO (Asynchronous IO)，简称为 AIO。</p>\n<p>异步 IO 的基本流程：用户线程发起系统调用，告知内核启动某个 IO 操作，内核立即将调用结果返回。同时，内核开始进行 IO 操作(包含数据准备、数据复制)，内核 IO 操作完成后，通知用户程序(信号、状态、回调函数等)，用户程序再进行后续的读写操作。</p>\n<p><img src=\"/images/%E5%BC%82%E6%AD%A5IO.jpeg\"></p>\n<p>异步 IO 特点：</p>\n<p>在接收到用户线程的 IO 操作请求，内核准备数据、复制数据的两个阶段，用户线程都是非阻塞的，用户线程只有接收到内核的通知，才进行下一步的读写操作。</p>\n<p>异步 IO 缺点：</p>\n<p>需要完成事件的注册与传递，这需要底层操作系统提供大量的支持，去做大量的工作。</p>\n<p>目前来说，Windwos 系统下通过 IOCP 实现了真正的异步 IO，但是目前 Windows 系统很少作为百万级以上或者说高并发应用的服务器操作系统来使用。</p>\n<p>而在 Linux 系统下，异步 IO 在 2.6 版本才引入，目前并不完善。所以，这也是在 Linux 下，实现高并发网络编程时都是以 IO 多路复用为主。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>四种 IO 模型，理论上越往后，阻塞越少，效率也是最优。在四种 IO 模型中，前三种属于同步 IO，因为其中真正的 IO 操作将阻塞线程，只有最后一种，才是真正的异步 IO 模型，可惜目前 Linux 尚欠完善。</p>\n<p><br><br></p>\n","categories":["后端"],"tags":["Java","NIO"]},{"title":"Vue.js 学习笔记之进阶篇","url":"https://zhouxelf.com/2019/10/06/Vue.js 学习笔记之进阶篇/","content":"<h1 id=\"过渡-amp-动画\"><a href=\"#过渡-amp-动画\" class=\"headerlink\" title=\"过渡 &amp; 动画\"></a>过渡 &amp; 动画</h1><ol>\n<li>Vue 提供了 transition 的封装组件，在某些情形下，可以给任何元素和组件添加进入/离开的过渡。</li>\n<li>常用的过渡都是使用 CSS 过渡，CSS 过渡会自动应用某些过渡的类名，在这些类名下写对应的过渡 CSS 效果，详见: <a href=\"https://cn.vuejs.org/v2/guide/transitions.html#%E8%BF%87%E6%B8%A1%E7%9A%84%E7%B1%BB%E5%90%8D\">过渡的类名</a>。</li>\n<li>CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除，详见: <a href=\"https://cn.vuejs.org/v2/guide/transitions.html#CSS-%E5%8A%A8%E7%94%BB\">CSS 动画</a>。</li>\n<li>使用自定义的过渡类名，Vue 的过渡系统和其他第三方的 CSS 动画库 Animate.css 结合的非常好，不需要自己写各种动画效果，详见: <a href=\"https://cn.vuejs.org/v2/guide/transitions.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%B8%A1%E7%9A%84%E7%B1%BB%E5%90%8D\">自定义过渡的类名</a>。</li>\n<li>过渡同样可以使用 JS 实现，配合动画库 Velocity.js 有较好的效果，详见: <a href=\"https://cn.vuejs.org/v2/guide/transitions.html#JavaScript-%E9%92%A9%E5%AD%90\">JavaScript 钩子</a>。</li>\n<li>Vue 提供了过渡模式，使过渡有一个较好的效果，详见: <a href=\"https://cn.vuejs.org/v2/guide/transitions.html#%E8%BF%87%E6%B8%A1%E6%A8%A1%E5%BC%8F\">过渡模式</a>。</li>\n<li>对于一个列表的过滤渲染，可以使用列表过渡，详见: <a href=\"https://cn.vuejs.org/v2/guide/transitions.html#%E5%88%97%E8%A1%A8%E8%BF%87%E6%B8%A1\">列表过渡</a>。</li>\n<li>对于一些数据元素本身，Vue 提供了状态过渡，详见: <a href=\"https://cn.vuejs.org/v2/guide/transitioning-state.html\">状态过渡</a>。</li>\n</ol>\n<h1 id=\"可复用性-amp-组合\"><a href=\"#可复用性-amp-组合\" class=\"headerlink\" title=\"可复用性 &amp; 组合\"></a>可复用性 &amp; 组合</h1><ol>\n<li>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能，一个混入对象可以包含任意组件选项，详见: <a href=\"https://cn.vuejs.org/v2/guide/mixins.html\">混入</a>。</li>\n<li>Vue 允许用户注册自定义指令，详见: <a href=\"https://cn.vuejs.org/v2/guide/custom-directive.html\">自定义指令</a>。</li>\n<li>绝大多数情况下，使用模板是合适的，但是对于一些情况，可能需要使用渲染函数来实现，Vue 提供了这种功能，详见: <a href=\"https://cn.vuejs.org/v2/guide/render-function.html\">渲染函数 &amp; JSX</a>。</li>\n<li>createElement 返回的告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息，我们把这样的节点描述为 <strong>虚拟节点(virtual node)<strong>，常简写为 <strong>VNode</strong>，</strong>虚拟 DOM</strong> 是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼，详见: <a href=\"https://cn.vuejs.org/v2/guide/render-function.html#%E8%8A%82%E7%82%B9%E3%80%81%E6%A0%91%E4%BB%A5%E5%8F%8A%E8%99%9A%E6%8B%9F-DOM\">节点、树及虚拟 DOM</a>。</li>\n<li>插件通常用来为 Vue 添加全局功能，插件的功能范围没有严格的限制，详见: <a href=\"https://cn.vuejs.org/v2/guide/plugins.html\">插件</a>。</li>\n<li>Vue 允许自定义过滤器，可被用于一些常见的文本格式化,过滤器可以用在两个地方：双花括号插值和 v-bind 表达式，详见: <a href=\"https://cn.vuejs.org/v2/guide/filters.html\">过滤器</a>。</li>\n</ol>\n<h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><ol>\n<li>开发中基本都是单文件组件，一个 <a href=\"https://codesandbox.io/s/o29j95wx9\">Demo</a>，详见: <a href=\"https://cn.vuejs.org/v2/guide/single-file-components.html\">单文件组件</a>。</li>\n<li>关注点分离不等于文件类型分离。</li>\n<li>Vue 测试工具，详见: <a href=\"https://cn.vuejs.org/v2/guide/testing.html\">测试</a>。</li>\n<li>Vue 提供了 TypeScript 的支持，详见: <a href=\"https://cn.vuejs.org/v2/guide/typescript.html\">TypeScript支持</a>。</li>\n<li>Vue 生产环境一般需要做一些特别的配置，以提高访问效率，详见: <a href=\"https://cn.vuejs.org/v2/guide/deployment.html\">生产环境部署</a>。</li>\n</ol>\n<h1 id=\"规模化\"><a href=\"#规模化\" class=\"headerlink\" title=\"规模化\"></a>规模化</h1><ol>\n<li><a href=\"https://cn.vuejs.org/v2/guide/routing.html\">路由</a>，对于大多数的单页面应用，都推荐使用官方支持的 <a href=\"https://router.vuejs.org/zh/\">Vue Router</a>。</li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/state-management.html\">状态管理</a>，由于状态零散地分布在许多组件和组件之间的交互中，大型应用复杂度也经常逐渐增长，为了解决这个问题，Vue 提供 <a href=\"https://vuex.vuejs.org/zh/\">Vuex</a>。</li>\n<li>Vuex 是 <a href=\"https://facebook.github.io/flux/\">Flux架构</a> 的实现之一，<a href=\"https://github.com/reduxjs/reduxhttps://github.com/reduxjs/redux\">Redux</a> 是 React 生态中最流行的 Flux 实现。 </li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/ssr.html\">服务端渲染</a> 可以解决 SPA 应用的 SEO 问题和首屏渲染慢的问题，知乎上的相关 <a href=\"https://www.zhihu.com/question/59578433\">讨论</a>。</li>\n<li>永远不要将不可信任的内容（一般指用户提供的字符串）作为模板内容使用，其等价于执行任意的 JS 代码，易受到 XSS 攻击，如果使用服务端渲染，甚至可能导致服务器被攻破，为了避免此问题，<strong>应该确保 Vue 模板的内容始终是可信的且完全由自己掌控</strong>。</li>\n<li>如果需要展示用户提供的 HTML，可以使用 v-html，但要注意，永远不要认为用户提供的 HTML 是 100% 安全的，除非它是在一个 iframe 沙盒里或者应用中只有编写这些 HTML 的用户可以接触到它。除此之外，允许用户撰写其自己的 Vue 模板会带来类似的危险。</li>\n<li>注入 HTML、URL、CSS、JS 等安全相关知识，详见: <a href=\"https://cn.vuejs.org/v2/guide/security.html\">安全</a>。</li>\n</ol>\n<h1 id=\"响应式原理\"><a href=\"#响应式原理\" class=\"headerlink\" title=\"响应式原理\"></a>响应式原理</h1><ol>\n<li>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter，详见: <a href=\"https://cn.vuejs.org/v2/guide/reactivity.html#%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E5%8F%98%E5%8C%96\">如何追踪变化</a>。</li>\n<li>由于 JS 的限制，Vue 不能检测数组和对象的变化，尽管如此还是有一些办法来回避这些限制并保证它们的响应性，详见: <a href=\"https://cn.vuejs.org/v2/guide/reactivity.html#%E6%A3%80%E6%B5%8B%E5%8F%98%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">检测变化的注意事项</a>。</li>\n</ol>\n<p><br><br></p>\n","categories":["前端"],"tags":["JavaScript","Vue.js"]},{"title":"Vue.js 学习笔记之基础篇","url":"https://zhouxelf.com/2019/09/04/Vue.js 学习笔记之基础篇/","content":"<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><ol>\n<li>当 Vue 实例被创建时就已经存在于 data 中的属性才是响应式的。</li>\n<li>不要在属性或回调上使用箭头函数，箭头函数没有 this。</li>\n<li>Vue 提供一系列生命周期钩子函数供调用，created、mounted、destroyed 等。</li>\n<li>不要在模版表达式中访问用户自定义的全局变量。</li>\n<li>一些指令可以接收一个参数，在指令名称之后以冒号表示，比如 v-bind:href=”url”、v-on:click=”doSomething”。</li>\n<li>Vue 2.6.0 开始，可以使用动态参数，比如 v-bind:[attrname]=”url”、v-on:[eventname]=”doSomething”，注意 避免使用大写字符来命名键名。</li>\n<li>修饰符指明以特殊方式绑定，比如 v-on:submit.prevent=”onSubmit”，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()。</li>\n<li>指令缩写，v-bind:href=”url” =&gt; :href=”url” 动态参数 :[key]=”url”，v-on:click=”doSomething” =&gt; @click=”doSomething” 动态参数 @[event]=”doSomething”。</li>\n<li>对于一些复杂的且需要在多个地方用到的属性计算逻辑，推荐使用 计算属性 computed。</li>\n<li>可以像普通属性一样在模板绑定计算属性，计算属性的值依赖于原始值，原始值变，计算属性跟着变。</li>\n<li>计算属性完全可以用方法实现，但是<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>，只在相关的响应式依赖改变时才会重新计算求值，但是换成方法实现的话每次都会执行，如果不希望有缓存，请使用方法实现。</li>\n<li>需要数据在变化时执行异步或开销较大的操作时，可以使用侦听器 watch。</li>\n<li>v-bind 用于 class 和 style 时，表达式的结果除了字符串，还可以是对象、数组或计算属性。</li>\n<li>v-bind:style 的值是一个 JS 对象，CSS 的属性使用驼峰命名访问。</li>\n<li>条件渲染，如果想切换多个元素，可以使用 <code>&lt;template&gt;</code> 元素包裹多个元素，然后在 template 上使用 v-if 指令。</li>\n<li>不需要复用的元素，可以显示的使用 key 来声明。</li>\n<li>v-if 和 v-show 指令都可以用来控制展示元素，不同的是，v-show 的元素始终会被渲染并保留在 DOM 中，v-show 只是简单的切换元素的 CSS 属性 display。</li>\n<li>v-show 不支持 <code>&lt;template&gt;</code> 元素，也不支持 v-else。</li>\n<li>v-if 是真正的条件渲染，它会确保切换过程中条件块内的事件监听器和子组件适当地重建或销毁。</li>\n<li>v-if 也是惰性的，如果初始条件为假，则什么也不做，知道条件第一次为真时才渲染。</li>\n<li>v-show 不管初始条件如何，始终被渲染，只是进行简单的基于 CSS 进行切换。</li>\n<li>如果选择？v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。如果频繁切换，使用 v-show，如果运行时条件很少改变，使用 v-if。</li>\n<li><strong>不推荐</strong>同时使用 v-if 和 v-for，如果一起使用，v-for 具有比 v-if 更高的优先级。</li>\n<li>v-for 遍历数组时，支持一个可选的第二个参数，即当前项的索引 index。</li>\n<li>v-for 遍历对象时，支持一个可选的第二个参数，即当前项的键名 key，支持一个可选的第三个参数，即当前项的索引 index。</li>\n<li>尽可能在使用 v-for 时绑定 :key 属性，不要使用数组或对象之类的非基本类型值作为 v-for 的 key，请用字符串或数值类型的值，注: Vue 2.2.0+ 版本里，当在组件上使用 v-for 时，key 是必须的。</li>\n<li><strong>变更方法</strong> Vue 将被监听的数组的变更方法进行了包裹，使用这些数组方法也会触发视图更新，这些方法包括: push()、pop()、shift()、unshift()、splice()、sort()、reverse()。</li>\n<li><strong>非变更方法</strong>，总是返回一个新数组，所以不会触发视图更新，如果想做到触发视图更新，可以用把返回的新数组赋值到旧数组。</li>\n<li>显示一个数组经过过滤或排序后的版本，而不改变原始数组，这是可以使用计算属性，来返回过滤或排序后的数组。</li>\n<li>类似于 v-if，可以利用带有 v-for 的 <code>&lt;template&gt;</code> 元素来循环渲染一段包含多个元素的内容。</li>\n<li>v-on 事件处理中，如果方法无参数，可以使用 event 访问原生 DOM 事件，如果有参数，可以在方法调用时显式地传递 $event 参数来访问原生 DOM 事件。</li>\n<li>事件修饰符，Vue 为 v-on 提供了事件修饰符，详见 <a href=\"https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6\">事件修饰符</a>。</li>\n<li>按键修饰符，Vue 允许为 v-on 在监听键盘事件时添加按键修饰符，详见 <a href=\"https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6\">按键修饰符</a>。</li>\n<li>v-model 指令在 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定，它会根据控件类型自动选取正确的方法来更新元素。</li>\n<li>v-model 会忽略所有表单元素的 value、checked、selected 属性的初始值，而总是将 Vue 实例的数据作为数据来源。</li>\n<li>v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件，text 和 textarea 元素使用 value 属性和 input 事件，checkbox 和 radio 使用 checked 属性和 change 事件，select 将 value 作为 prop 并将 change 作为事件。</li>\n<li>如果想把值绑定到 Vue 实例的一个动态属性上，可以使用 v-bind 实现，并且这个属性可以不是字符串。</li>\n<li>修饰符，v-model 在每次 input 事件触发后同步数据，可以使用 v-model.lazy，从而转为在 change 事件之后触发。</li>\n<li>如果需要自动将用户的输入值转换为数值类型，可以使用 v-model.number。</li>\n<li>如果需要自动过滤用户输入的首尾空白字符，可以使用 v-model.trim。</li>\n<li>组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等，仅有的例外是像 el 这样的选项是根实例特有的。</li>\n<li>一个组件的 data 选项必须是一个函数。</li>\n<li>组件分为全局注册和局部注册，全局注册的组件可以用在其被注册之后的任何（通过 new Vue）新创建的 Vue 根实例，也包括其组件树的所有子组件的模块中。</li>\n<li>可以使用 Prop 向子组件传递数据。</li>\n<li>每个组件都必须只有一个根元素，所有内容可以放到一个 div 内。</li>\n<li>当组件的 prop 越来越多时，可以声明一个 object，传递一个 object 类型的数组到组件。</li>\n<li>监听子组件事件，子组件可以通过调用内建的 $emit 方法并传入一个事件名来触发一个父级组件的事件。</li>\n<li>子组件调用内建的 $emit 方法时，可以传入第二个参数，父组件使用 $event 变量名来获取子组件传递的值，这个事件处理函数是一个方法，那么这个值将会作为第一个参数传入这个方法。</li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/components.html#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-v-model\">在组件上使用 v-model</a>。</li>\n<li>如果需要向一个组件传递内容，可以在子组件里使用插槽 slot。</li>\n<li>如果需要在不同组件之间进行动态切换，可以使用动态组件，<a href=\"https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6\">动态组件</a>。</li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/components.html#%E8%A7%A3%E6%9E%90-DOM-%E6%A8%A1%E6%9D%BF%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">解析 DOM 模板时的注意事项</a>。</li>\n</ol>\n<h1 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h1><ol>\n<li>直接在 DOM 中使用时，自定义组件名字母全小写且必须包含一个连字符，避免和当前以及未来的 HTML 元素冲突。</li>\n<li>全局注册，在组件注册之后，可以用在任何新创建的 Vue 根实例（new Vue）的模板中，在所有的子组件内也都可以相互使用。</li>\n<li>全局注册，意味着即使已经不用某个组件了，该组件依然被包含在最终的构建结果中，这就造成了用户下载 JS 的无谓增加，所以尽量选择按需引入。</li>\n<li>局部注册，局部注册的组件在子组件中不可用，除非显式地声明，<a href=\"https://cn.vuejs.org/v2/guide/components-registration.html\">局部注册</a>。</li>\n<li>如果通过 import 或 require 使用一个模块系统，那么可以方便的局部注册，清晰的组织组件目录结构，详见: <a href=\"https://cn.vuejs.org/v2/guide/components-registration.html#%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F\">模块系统</a>。</li>\n<li>对于一些基础组件想要使用自动化的全局注册，如果使用了 webpack，那么可以使用 require.context 注册，参见: <a href=\"https://cn.vuejs.org/v2/guide/components-registration.html#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C\">基础组件的自动化全局注册</a>。</li>\n<li>全局注册的行为必须在根 Vue 实例（new Vue）创建之前发生。</li>\n<li>Prop 的大小写，在 DOM 中使用组件时，camelCase（驼峰命名法）的 prop 名需要使用其等价的 kebab-case（短横线分隔命名）。</li>\n<li>Prop 类型，如果希望每个 prop 都有指定类型，那么可以用对象形式列出 prop，key 对应属性名，value 对应属性类型，详见: <a href=\"https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E7%B1%BB%E5%9E%8B\">Prop 类型</a>。</li>\n<li>如果需要传入一个对象的所有属性到组件，可以简写成 v-bind=”post”，不必一个个 bind 属性。</li>\n<li>单向数据流，所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定，即父级 prop 的更新会向下流动到子组件，但是反过来不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。<strong>不应该在一个子组件内部改变改变 prop</strong>。</li>\n<li><strong>注意在 JavaScript 中对象和数组是通过引用传入的</strong>，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态。</li>\n<li>Prop 验证，如果知道 prop 的属性类型，可以定义验证规则，如果一个需求没被满足，（开发环境构建版本的）Vue 将会发出警告，详见: <a href=\"https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81\">Prop验证</a>。</li>\n<li><strong>注意那些 prop 会在一个组件实例创建之前进行验证，所以实例的 property (如 data、computed 等) 在 default 或 validator 函数中是不可用的</strong>。</li>\n<li>替换/合并已有的 Attribute，对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 type=”text” 就会替换掉 type=”date” 并把它破坏！庆幸的是，class 和 style attribute 会稍微智能一些，即两边的值会被合并起来，详见: <a href=\"https://cn.vuejs.org/v2/guide/components-props.html#%E6%9B%BF%E6%8D%A2-%E5%90%88%E5%B9%B6%E5%B7%B2%E6%9C%89%E7%9A%84-Attribute\">替换-合并已有的-Attribute</a>。</li>\n<li>禁用 Attribute 继承，如果不希望组件的根元素继承 attribute，可以在组件的选项中设置 inheritAttrs: false，同时配合 $attrs 就可以决定哪些 attribute 继承，哪些不继承，inheritAttrs: false 选项不会影响 style 和 class 的绑定，详见: <a href=\"https://cn.vuejs.org/v2/guide/components-props.html#%E7%A6%81%E7%94%A8-Attribute-%E7%BB%A7%E6%89%BF\">禁用-Attribute-继承</a>。</li>\n<li>事件名没有命名方式的自动转换，只会自动转换为全小写，所以推荐<strong>始终使用短线分隔的事件命名方式</strong>。</li>\n<li>自定义组件的 v-model，使用 model 选项来避免冲突，详见: <a href=\"https://vuejs.bootcss.com/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model\">自定义组件的 v-model</a>。</li>\n<li>如果需要对一个 prop 在父子组件间进行双向绑定，推荐使用 .sync 修饰符，但需注意版本，以及某些表达式是不能使用的，详见: <a href=\"https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6\">.sync 修饰符</a>。</li>\n<li>如果子组件里没有 <code>&lt;slot&gt;</code> 标签，则在使用子组件的地方，子组件标签之间的内容都会被抛弃。</li>\n<li>编译作用域，父级模板的所有内容都是在父级作用域中编译的，子模板里的所有内容都是在子作用域中编译的。</li>\n<li>插槽 slot 可以提供后备（也就是默认的）内容，使用带插槽的组件但没传内容时，插槽将显示后备内容。</li>\n<li>具名插槽，对于组件，如果包含多个 slot，可以为每个 slot 起个别名，调用的时候在 template 上使用 v-slot 指令，分别插入对应的部分，注意 v-slot 只能用在 template 上，详见: <a href=\"https://cn.vuejs.org/v2/guide/components-slots.html#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD\">具名插槽</a>。</li>\n<li>具名插槽可以缩写为 #header。</li>\n<li>动态组件可以使用 keep-alive。</li>\n<li>组件，处理边界情况，详见: <a href=\"https://cn.vuejs.org/v2/guide/components-edge-cases.html\">处理边界情况</a>。</li>\n<li>父组件里直接访问一个子组件，可以使用 ref，详见: <a href=\"https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E6%88%96%E5%AD%90%E5%85%83%E7%B4%A0\">访问子组件或子元素</a>。</li>\n</ol>\n<p><br><br></p>\n","categories":["前端"],"tags":["JavaScript","Vue.js"]},{"title":"JavaScript 学习笔记","url":"https://zhouxelf.com/2019/08/12/JavaScript 学习笔记/","content":"<h3 id=\"基础部分\"><a href=\"#基础部分\" class=\"headerlink\" title=\"基础部分\"></a>基础部分</h3><ol>\n<li>Js 严格区分大小写</li>\n<li>Js 不区分整数和浮点数，统一用 Number 表示</li>\n<li><strong>==</strong> 自动转换数据类型再比较，**===** 不会转换数据类型，应始终坚持用 <strong>===</strong> 比较</li>\n<li>NaN 非数字值 (Not a Number) 检测使用 <strong>isNaN()</strong> 函数</li>\n<li>null 和 undefined 基本同义，大多数情况下都应该用 null，null 表示”没有对象”，即此处不应该有值，undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义，详见<a href=\"http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html\">阮一峰</a></li>\n<li>数组用 <strong>[ ]</strong> 表示，也可以用 <strong>Array()</strong> 函数实现，使用索引访问</li>\n<li>JS 对象，键是字符串类型，值任意类型<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">    name:<span class=\"string\">&#x27;Bob&#x27;</span>,</span><br><span class=\"line\">    age:<span class=\"number\">20</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>判断一个对象的属性是否存在(含继承) <strong>in</strong>，(不含继承) <strong>hasOwnProperty()</strong></li>\n<li><strong>strict 模式</strong>会强制 <strong>var</strong> 关键字申明变量，详见<a href=\"http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html\">阮一峰</a></li>\n<li>多行字符串，使用 <strong>\\n</strong> 转义，最新 <strong>ES6</strong> 可以使用反引号 <strong>···</strong></li>\n<li>字符串连接，使用 **+**，最新 <strong>ES6</strong> 可以使用 **${变量名}**，必须使用反引号</li>\n<li>判断条件，JavaScript把 <strong>null、undefined、0、NaN、’ ‘</strong> 视为 false，其他值一概视为 true</li>\n<li>循环输出，<strong>for…in</strong> 输出对象的所有属性，输出数组的索引</li>\n<li>循环输出，<strong>for···of</strong> 输出数组的值 <strong>ES6</strong> </li>\n<li><strong>ES6</strong> 中新增的数据类型 <strong>Map、Set</strong>，以及 <strong>iterable</strong> ，<strong>Set</strong> 只存储键，键不能重复，<strong>Map、Set、Array</strong> 均属于 <strong>iterable</strong> 类型，均可通过 <strong>forEach()</strong> 遍历<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">    [<span class=\"string\">&#x27;Michael&#x27;</span>, <span class=\"number\">95</span>],</span><br><span class=\"line\">    [<span class=\"string\">&#x27;Bob&#x27;</span>, <span class=\"number\">75</span>],</span><br><span class=\"line\">    [<span class=\"string\">&#x27;Tracy&#x27;</span>, <span class=\"number\">85</span>]</span><br><span class=\"line\">]);</span><br><span class=\"line\">m.set(<span class=\"string\">&#x27;Adam&#x27;</span>, <span class=\"number\">67</span>); <span class=\"comment\">//添加新元素</span></span><br><span class=\"line\">m.get(<span class=\"string\">&#x27;Bob&#x27;</span>); <span class=\"comment\">//获取元素</span></span><br><span class=\"line\">m.has(<span class=\"string\">&#x27;Bob&#x27;</span>); <span class=\"comment\">//判断存在</span></span><br><span class=\"line\">m.delete(<span class=\"string\">&#x27;Bob&#x27;</span>); <span class=\"comment\">//删除元素</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">a.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element, index, array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// element:指向当前元素的值</span></span><br><span class=\"line\">    <span class=\"comment\">// index:指向当前索引</span></span><br><span class=\"line\">    <span class=\"comment\">// array:指向 Array 对象本身</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>]);</span><br><span class=\"line\">b.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element, sameElement, set</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 前两个参数均为当前元素</span></span><br><span class=\"line\">    <span class=\"comment\">// set:指向当前 Set</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"number\">1</span>, <span class=\"string\">&#x27;x&#x27;</span>], [<span class=\"number\">2</span>, <span class=\"string\">&#x27;y&#x27;</span>], [<span class=\"number\">3</span>, <span class=\"string\">&#x27;z&#x27;</span>]]);</span><br><span class=\"line\">c.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, key, map</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// value: 指向当前元素的值</span></span><br><span class=\"line\">    <span class=\"comment\">// key: 指向当前元素的键</span></span><br><span class=\"line\">    <span class=\"comment\">// map: 指向当前 Map</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"16\">\n<li>函数内部关键字 <strong>arguments</strong>，永远指向当前函数的调用者传入的所有参数</li>\n<li>变量提升，JavaScript 的函数定义特点，先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部</li>\n<li>var和let，<strong>let</strong> 声明块级作用域，<strong>const</strong> 声明常量</li>\n<li>高阶函数 <strong>map()<strong>、</strong>reduce()</strong><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pow = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x*x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr.map(pow);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">alert(b); <span class=\"comment\">//返回 15</span></span><br></pre></td></tr></table></figure>\n<ol start=\"20\">\n<li><strong>filter()</strong> 接收一个函数，将函数作用于 Array 中的每一个元素，根据返回值是 true 或 false，来决定是否保留该元素<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = arr.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">alert(b); <span class=\"comment\">//返回 2,4</span></span><br></pre></td></tr></table></figure></li>\n<li>闭包，函数作为返回值，并且相关参数和变量都保存在返回的函数中；使用闭包时，返回函数不要引用任何循环变量，或者后续会发生变化的变量，如若使用，须创建一个函数，用该函数的参数绑定循环变量当前的值<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">        arr.push(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i*i;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> results = count();</span><br><span class=\"line\"><span class=\"keyword\">var</span> f1 = results[<span class=\"number\">0</span>];  </span><br><span class=\"line\"><span class=\"keyword\">var</span> f2 = results[<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> f3 = results[<span class=\"number\">2</span>];</span><br><span class=\"line\">f1(); <span class=\"comment\">// 16</span></span><br><span class=\"line\">f2(); <span class=\"comment\">// 16</span></span><br><span class=\"line\">f3(); <span class=\"comment\">// 16</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">        arr.push((<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> n * n;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> results = count();</span><br><span class=\"line\"><span class=\"keyword\">var</span> f1 = results[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> f2 = results[<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> f3 = results[<span class=\"number\">2</span>];</span><br><span class=\"line\">f1(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">f2(); <span class=\"comment\">// 4</span></span><br><span class=\"line\">f3(); <span class=\"comment\">// 9</span></span><br></pre></td></tr></table></figure>\n<ol start=\"22\">\n<li>创建一个匿名函数并立刻执行<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;)(<span class=\"number\">3</span>); <span class=\"comment\">//9</span></span><br></pre></td></tr></table></figure></li>\n<li>箭头函数完全修复了函数内部使用 <strong>this</strong> 关键字的指向问题</li>\n<li>关于包装对象<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 不要使用new Number()、new Boolean()、new String()创建包装对象</span><br><span class=\"line\">2. 用parseInt()或parseFloat()来转换任意类型到number</span><br><span class=\"line\">3. 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法</span><br><span class=\"line\">4. 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) &#123;...&#125;</span><br><span class=\"line\">5. typeof操作符可以判断出number、boolean、string、function和undefined</span><br><span class=\"line\">6. 判断Array要使用Array.isArray(arr)</span><br><span class=\"line\">7. 判断null请使用myVar &#x3D;&#x3D;&#x3D; null</span><br><span class=\"line\">8. 判断某个全局变量是否存在用typeof window.myVar &#x3D;&#x3D;&#x3D; &#39;undefined&#39;</span><br><span class=\"line\">9. 函数内部判断某个变量是否存在用typeof myVar &#x3D;&#x3D;&#x3D; &#39;undefined&#39;</span><br></pre></td></tr></table></figure></li>\n<li>面向对象编程，<strong>原型链</strong>，JavaScipt 的原型链和 Java 的 Class 的区别就在，它没有 “Class” 的概念，所有的对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Student = &#123; <span class=\"comment\">// 原型对象</span></span><br><span class=\"line\">    name: <span class=\"string\">&#x27;Robot&#x27;</span>,</span><br><span class=\"line\">    height: <span class=\"number\">1.8</span>,</span><br><span class=\"line\">    run: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name + <span class=\"string\">&#x27; is running...&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStudent</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基于 Student 原型创建一个新对象</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> s = <span class=\"built_in\">Object</span>.create(Student);</span><br><span class=\"line\">    <span class=\"comment\">// 初始化新对象</span></span><br><span class=\"line\">    s.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> xiaoming = createStudent(<span class=\"string\">&#x27;小明&#x27;</span>);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><br><br></p>\n","categories":["前端"],"tags":["JavaScript"]},{"title":"Redis 复制、持久化、附加功能","url":"https://zhouxelf.com/2019/07/03/Redis 复制、持久化、附加功能/","content":"<h1 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h1><h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>在分布式系统中为了解决单点问题，通常会把数据复制多个副本部署到其他机器，满足故障恢复和负载均衡等需求。</p>\n<h3 id=\"建立复制\"><a href=\"#建立复制\" class=\"headerlink\" title=\"建立复制\"></a>建立复制</h3><p>参与复制的 Redis 实例划分为主节点（master）和从节点（slave），默认情况下，Redis 都是主节点。每个主节点只能有一个主节点，而主节点可以同时具有多个从节点。复制的数据流是单向的，只能由主节点复制到从节点。</p>\n<p>配置复制的方式有以下三种</p>\n<ul>\n<li>在配置文件中加入 slaveof 项，随 Redis 启动生效</li>\n<li>在 redis-server 启动命令后加入 –slaveof 生效</li>\n<li>直接使用命令 slaveof 生效</li>\n</ul>\n<p>slaveof 配置都是在从节点发起的，可以使用 info replication 命令查看复制相关状态。</p>\n<h3 id=\"断开复制\"><a href=\"#断开复制\" class=\"headerlink\" title=\"断开复制\"></a>断开复制</h3><p>在从节点上执行 slaveof no one 命令断开与主节点的复制关系，从节点断开后数据会保留，只是无法再从主节点获取。</p>\n<p>命令 slaveof 还可以进行主节点的切换，但要注意，<strong>切换主节点会清空之前所有的数据</strong> 。</p>\n<h2 id=\"拓扑\"><a href=\"#拓扑\" class=\"headerlink\" title=\"拓扑\"></a>拓扑</h2><p>一主一从、一主多从、树状主从</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>复制过程大致分为 6 个过程：</p>\n<ol>\n<li>保存主节点信息</li>\n<li>主从建立 socket 连接</li>\n<li>发送 ping 命令</li>\n<li>权限验证</li>\n<li>同步数据集</li>\n<li>命令持续复制</li>\n</ol>\n<h1 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h1><p>Redis 支持 RDB 和 AOF 两种持久化机制，持久化功能有效的避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化的文件即可实现数据恢复。</p>\n<h2 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h2><p>RDB 持久化是把当前进程数据生成快照保存到硬盘的过程，触发 RDB 持久化的过程分为手动触发和自动触发。</p>\n<h3 id=\"手动触发\"><a href=\"#手动触发\" class=\"headerlink\" title=\"手动触发\"></a>手动触发</h3><p><strong>bgsave</strong> 该命令会 fork 一个子进程，RDB 的持久化过程由子进程完成，而且阻塞只发生在 fork 阶段，一般时间很短。</p>\n<p>save 命令会阻塞当前 Redis 服务，一般不采用。</p>\n<p>RDB 文件名和文件路径由配置项在 dir 和 dbfilename 指定，若要修改，可以使用 config set 动态修改。</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p><strong>优点</strong></p>\n<ol>\n<li>RDB 是一个紧凑压缩的二进制文件，代表 Redis 在某个时间节点上的数据快照，非常适用于备份，全景复制等场景。</li>\n<li>Redis 加载 RDB 恢复数据远远快于 AOF 的方式。</li>\n</ol>\n<p><strong>缺点</strong></p>\n<ol>\n<li>RDB 方式数据没法做到实时持久化 / 秒级持久化，因为 bgsave 每次运行都要执行 fork 操作创建子进程，属于重量级操作，频繁执行成本过高。</li>\n<li>RDB 文件使用特定的二进制格式保存，存在老版本 Redis 无法兼容新版 RDB 格式的问题。</li>\n</ol>\n<h2 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h2><p>AOF（append only file） 持久化：以独立日志的方式记录每次写命令，重启时再重新执行 AOF 文件中的命令达到恢复数据的目的。AOF 是目前 Redis 持久化的主流方式。</p>\n<p>开启 AOF 功能需要设置配置：appendonly yes，默认不开启；AOF 文件名通过 appendfilename 配置，默认为 appendonly.aof；保存路径同样由 dir 指定。</p>\n<h3 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h3><ol>\n<li>命令写入（append）</li>\n<li>文件同步（sync）</li>\n<li>文件重写（rewrite）</li>\n<li>重启加载（load）</li>\n</ol>\n<p><strong>命令写入</strong></p>\n<p>AOF 命令写入会把所有的写入命令追加到 aof_buf（缓冲区），写入的内容直接是文本协议格式。</p>\n<p><strong>文件同步</strong></p>\n<p>Redis 提供了多种 AOF 缓冲区同步文件策略，由配置项 appendfsync 指定，可配置值有 always、everysec、no。eyerysec 是默认的配置值，也是建议的配置值，能做到兼顾性能和数据安全性。</p>\n<p><strong>重写机制</strong></p>\n<p>随着命令不断写入 AOF，文件会越来越大，为了解决这个问题，Redis 引入 AOF 重写机制压缩文件体积。</p>\n<blockquote>\n<p>重写后的 AOF 文件为什么可以变小？</p>\n</blockquote>\n<ol>\n<li>进程内已经超时的数据不再写入文件；</li>\n<li>旧的 AOF 文件含有无效命令，如 del key 等，重写使用进程内数据直接生成，这样新的 AOF 文件只保留最终数据的写入命令；</li>\n<li>多条写命令可以合并为一个。</li>\n</ol>\n<p>AOF 的重写过程有手动触发和自动触发两种方式</p>\n<ul>\n<li>手动触发 直接调用 bgrewriteaof 命令</li>\n<li>自动触发 根据 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 参数确定自动触发时机</li>\n</ul>\n<p><strong>重启加载</strong></p>\n<p>开启了 AOF 后，Redis 在服务重启时会自动加载 AOF 文件，将数据导入内存。</p>\n<h1 id=\"附加功能\"><a href=\"#附加功能\" class=\"headerlink\" title=\"附加功能\"></a>附加功能</h1><h2 id=\"慢查询分析\"><a href=\"#慢查询分析\" class=\"headerlink\" title=\"慢查询分析\"></a>慢查询分析</h2><p>慢查询日志是系统在命令执行前后计算每条命令的执行时间，当超过预设阀值，就将这条命令的相关信息（例如：发生时间，耗时，命令的详细信息）记录下来，Redis 也提供了类似的功能。</p>\n<h3 id=\"两个配置参数\"><a href=\"#两个配置参数\" class=\"headerlink\" title=\"两个配置参数\"></a>两个配置参数</h3><ul>\n<li>slowlog-log-slower-than 预设阀值，默认值 10000 微秒</li>\n<li>slowlog-max-len 允许日志存储的最大条数</li>\n</ul>\n<p>slowlog-max-len 是一个列表，当列表满时，第一条日志出列；两个配置可以通过 config set 来修改，如果要将配置写入配置文件，须执行 config rewrite 。</p>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ul>\n<li>slowlog get 获取当前 redis 的慢查询</li>\n<li>slowlog len 获取当前慢查询日志列表的长度</li>\n<li>slowlog 慢查询日志重置</li>\n</ul>\n<h2 id=\"Redis-Shell\"><a href=\"#Redis-Shell\" class=\"headerlink\" title=\"Redis Shell\"></a>Redis Shell</h2><p>Redis 提供了 redis-server、redis-cli、redis-benchmark 等 Shell 工具。</p>\n<h3 id=\"redis-benchmark\"><a href=\"#redis-benchmark\" class=\"headerlink\" title=\"redis-benchmark\"></a>redis-benchmark</h3><p>redis-benchmark 可以为 Redis 做基准性能测试。</p>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><ul>\n<li>-c 指定客户端的并发数量</li>\n<li>-n 指定所有客户端的请求总量</li>\n<li>-q 仅显示 requests per second 信息</li>\n<li>-t 对指定命令进行基准测试</li>\n</ul>\n<h2 id=\"Pipeline-流水线\"><a href=\"#Pipeline-流水线\" class=\"headerlink\" title=\"Pipeline 流水线\"></a>Pipeline 流水线</h2><p>发送命令和返回结果所耗费的时间称为 Round Trip Time（RTT，往返时间）。Pipeline 能将一组 Redis 命令进行组装，通过一次 RTT 传输给 Redis，再将这组 Redis 命令的执行结果按顺序返回给客户端。</p>\n<h3 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h3><ol>\n<li>Pipeline 执行速度一般比逐条执行要快</li>\n<li>客户端与服务器的网络时延越大，Pipeline 的效果越明显</li>\n</ol>\n<h3 id=\"原生批量命令与-Pipeline-对比\"><a href=\"#原生批量命令与-Pipeline-对比\" class=\"headerlink\" title=\"原生批量命令与 Pipeline 对比\"></a>原生批量命令与 Pipeline 对比</h3><ol>\n<li>原生批量命令是原子的，Pipeline 是非原子的</li>\n<li>原生批量命令是一个命令对应多个 key，Pipeline 支持多个命令</li>\n<li>原生批量命令是 Redis 服务端支持实现的，而 Pipeline 需要服务端和客户端的共同实现</li>\n</ol>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>为了保证多个命令组合的原子性，可以使用事务。</p>\n<p>multi 代表事务开始，exec 代表事务结束，命令执行。 </p>\n<h2 id=\"Lua-脚本\"><a href=\"#Lua-脚本\" class=\"headerlink\" title=\"Lua 脚本\"></a>Lua 脚本</h2><h3 id=\"在-Redis-中使用-Lua\"><a href=\"#在-Redis-中使用-Lua\" class=\"headerlink\" title=\"在 Redis 中使用 Lua\"></a>在 Redis 中使用 Lua</h3><ul>\n<li>eval </li>\n<li>evalsha</li>\n</ul>\n<h3 id=\"管理-Lua-脚本\"><a href=\"#管理-Lua-脚本\" class=\"headerlink\" title=\"管理 Lua 脚本\"></a>管理 Lua 脚本</h3><ul>\n<li>script load 将脚本加载到内存</li>\n<li>script exists 判断 sha1 是否加载</li>\n<li>script flush 清除加载的所有脚本</li>\n<li>script kill 杀掉正在执行的脚本</li>\n</ul>\n<h2 id=\"Bitmaps\"><a href=\"#Bitmaps\" class=\"headerlink\" title=\"Bitmaps\"></a>Bitmaps</h2><p>Bitmaps 不是一种数据结构类型，实际上就是字符串，可以对它的位进行操作。</p>\n<h3 id=\"命令-1\"><a href=\"#命令-1\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ul>\n<li>setbit 设置值</li>\n<li>getbit 获取值</li>\n<li>bitcount 获取 Bitmaps 指定范围为 1 的个数</li>\n<li>bitop and | or | not | xor Bitmaps 间的运算</li>\n<li>bitpos 计算 Bitmaps 中第一个值为 0 | 1 的偏移量</li>\n</ul>\n<h2 id=\"HyperLogLog\"><a href=\"#HyperLogLog\" class=\"headerlink\" title=\"HyperLogLog\"></a>HyperLogLog</h2><p>HyperLogLog 也不是一种新的数据结构类型（实际类型为字符串类型），而是一种基数算法，通过 HyperLogLog 可以利用极小的内存空间完成独立总数的统计，数据集可以是 IP、Email、ID 等。</p>\n<ol>\n<li>只为了计算独立总数，不需要获取单条数据</li>\n<li>可以容忍一定的误差率</li>\n</ol>\n<h3 id=\"命令-2\"><a href=\"#命令-2\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ul>\n<li>pfadd 添加元素</li>\n<li>pfcount 计算独立用户数</li>\n<li>prmerge 求几个 HyperLogLog 的并集</li>\n</ul>\n<h2 id=\"发布订阅\"><a href=\"#发布订阅\" class=\"headerlink\" title=\"发布订阅\"></a>发布订阅</h2><p>Redis 提供了基于 「发布/订阅」 模式的消息机制，此种模式下，消息发布者和订阅者不进行直接通信，发布者客户端向指定的频道（channel）发布消息，订阅该频道的每个客户端都可以收到该消息。</p>\n<h3 id=\"命令-3\"><a href=\"#命令-3\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ul>\n<li>publish 向指定频道发布一条消息</li>\n<li>subscribe 订阅一个或多个频道</li>\n<li>unsubscribe 取消对指定频道的订阅</li>\n<li>psubscribe punsubscribe 按照频道订阅和取消订阅</li>\n<li>pubsub channels | numsub | numpat 查询 活跃的频道 | 频道订阅数 | 模式订阅数</li>\n</ul>\n<h2 id=\"GEO\"><a href=\"#GEO\" class=\"headerlink\" title=\"GEO\"></a>GEO</h2><p>Redis 3.2 版本提供了 GEO（地理信息定位）功能，支持存储地理位置信息来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。GEO 的数据结构类型是 ZSet。</p>\n<h3 id=\"命令-4\"><a href=\"#命令-4\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ul>\n<li>geoadd 添加地理位置信息，包括经度、纬度、地名</li>\n<li>geopos 获取地理位置信息</li>\n<li>geodist 获取两个地理位置的距离 m 米 | km 公里 | mi 英里 | ft 英尺</li>\n<li>georadius georadiusbymember 获取指定位置范围内的地理信息位置集合</li>\n<li>geohash 获取 geohash，Redis 使用 geohash 将二维经纬度转换为一维字符串</li>\n<li>zrem 删除地理位置信息</li>\n</ul>\n<p><br><br></p>\n","categories":["后端"],"tags":["Redis","Database","NoSQL"]},{"title":"Redis 基础","url":"https://zhouxelf.com/2019/05/11/Redis 基础/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><h2 id=\"全局命令\"><a href=\"#全局命令\" class=\"headerlink\" title=\"全局命令\"></a>全局命令</h2><ul>\n<li>keys * 查看所有键</li>\n<li>dbsize 查看键总数</li>\n<li>exists 检查键是否存在</li>\n<li>del 删除键</li>\n<li>expire 键过期</li>\n<li>type 键的数据类型</li>\n</ul>\n<h2 id=\"数据结构和内部编码\"><a href=\"#数据结构和内部编码\" class=\"headerlink\" title=\"数据结构和内部编码\"></a>数据结构和内部编码</h2><p>五种数据结构类型分别是：string（字符串-键值对）、hash（哈希-键值对集合）、list（列表-可重复有序值）、set（集合-不可重复无序值）、zset（有序列表-可重复有序值-关联分数）</p>\n<p>每种数据类型都有自己的内部编码实现，而且是多种实现。</p>\n<h2 id=\"单线程架构\"><a href=\"#单线程架构\" class=\"headerlink\" title=\"单线程架构\"></a>单线程架构</h2><p>Redis 使用了单线程架构和 I/O 多路复用模型来实现高性能的内存数据库服务。</p>\n<p>Redis 是面向快速执行场景的数据库。</p>\n<h1 id=\"五种基本数据结构\"><a href=\"#五种基本数据结构\" class=\"headerlink\" title=\"五种基本数据结构\"></a>五种基本数据结构</h1><h2 id=\"String-字符串\"><a href=\"#String-字符串\" class=\"headerlink\" title=\"String 字符串\"></a>String 字符串</h2><p>字符串，最基础的数据结构</p>\n<p>单个的键值对</p>\n<h4 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><ul>\n<li>set 设置值</li>\n<li>get 获取值</li>\n<li>mset 批量设置值</li>\n<li>mget 批量获取值</li>\n<li>incr 自增 decr 自减 incrby 自增指定数字 decrby 自减指定数字 incrbyfloat 自增浮点数</li>\n</ul>\n<h4 id=\"不常用命令\"><a href=\"#不常用命令\" class=\"headerlink\" title=\"不常用命令\"></a>不常用命令</h4><ul>\n<li>append 追加值，向字符串的末尾追加值</li>\n<li>strlen 字符串长度</li>\n<li>getset 设置并返回原值</li>\n<li>setrange 设置指定位置的字符</li>\n<li>getrange 获取部分字符串</li>\n</ul>\n<h4 id=\"内部编码\"><a href=\"#内部编码\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h4><p>字符串类型的内部编码有 3 种，可以使用 object encoding 查看 </p>\n<ul>\n<li>int 8 个字节的长整型</li>\n<li>embstr 小于等于 39 个字节的字符串</li>\n<li>raw 大于 39 个字节的字符串</li>\n</ul>\n<p>注: 3.2 版本之前 39 个字节，3.2 之后的版本 44 个字节</p>\n<h4 id=\"典型使用场景\"><a href=\"#典型使用场景\" class=\"headerlink\" title=\"典型使用场景\"></a>典型使用场景</h4><ol>\n<li>缓存功能</li>\n<li>计数</li>\n<li>共享 Session</li>\n<li>限速</li>\n</ol>\n<h2 id=\"Hash-哈希\"><a href=\"#Hash-哈希\" class=\"headerlink\" title=\"Hash 哈希\"></a>Hash 哈希</h2><p>哈希，也称散列、字典、关联数组</p>\n<p>存储多个键值对，<strong>无顺序，键不能重复，值可以重复</strong></p>\n<h4 id=\"常用命令-1\"><a href=\"#常用命令-1\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><ul>\n<li>hset 设置值</li>\n<li>hget 获取值</li>\n<li>hdel 删除 field</li>\n<li>hlen 计算 field 个数</li>\n<li>hmset hmget 批量设置或获取 field - value</li>\n<li>hexists 判断 field 是否存在</li>\n<li>hkeys 获取所有 field</li>\n<li>hvals 获取所有 value</li>\n<li>hgetall 获取所有的 field - value</li>\n<li>hincrby hincrbyfloat 类 incrby 和 incrbyfloat，作用域为 field</li>\n<li>hstrlen 计算 value 的字符串长度</li>\n</ul>\n<h4 id=\"内部编码-1\"><a href=\"#内部编码-1\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h4><p>哈希类型的内部编码有 2 种</p>\n<ul>\n<li>ziplist 压缩列表</li>\n<li>hashtable 哈希表</li>\n</ul>\n<h2 id=\"List-列表\"><a href=\"#List-列表\" class=\"headerlink\" title=\"List 列表\"></a>List 列表</h2><p>列表，用来存储多个有序的字符串</p>\n<p>类似一个水平的管道，列表内的值<strong>有顺序</strong>，可以通过 Lpush、Rpush 向管道左右两端插值，读取值时从左往右，<strong>值可以重复</strong></p>\n<p>-1 表示列表最后一位的索引</p>\n<h4 id=\"常用命令-2\"><a href=\"#常用命令-2\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><ul>\n<li>rpush 从右端插入元素</li>\n<li>lpush 从左端插入元素</li>\n<li>linsert 向某个元素前或者后插入元素</li>\n<li>lrange 获取指定范围内的元素列表</li>\n<li>lindex 获取指定索引下标的元素</li>\n<li>llen 获取列表长度</li>\n<li>lpop 从列表左侧弹出元素</li>\n<li>rpop 从列表右侧弹出元素</li>\n<li>lrem 删除指定元素</li>\n<li>ltrim 按照索引范围修剪列表</li>\n<li>lset 修改指定索引下标的元素</li>\n</ul>\n<h4 id=\"内部编码-2\"><a href=\"#内部编码-2\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h4><p>列表类型的内部编码有 2 种</p>\n<ul>\n<li>ziplist 压缩列表</li>\n<li>linkedlist 链表</li>\n</ul>\n<h4 id=\"典型使用场景-1\"><a href=\"#典型使用场景-1\" class=\"headerlink\" title=\"典型使用场景\"></a>典型使用场景</h4><ol>\n<li>消息队列</li>\n<li>文章列表</li>\n</ol>\n<h2 id=\"Set-集合\"><a href=\"#Set-集合\" class=\"headerlink\" title=\"Set 集合\"></a>Set 集合</h2><p>集合</p>\n<p>集合内值<strong>无顺序</strong>，不能索引下标获取元素，不能通过操作向集合的某一端插值，只能通过 Sadd、Srem 添加或移除元素，<strong>元素不可以重复</strong></p>\n<h4 id=\"常用命令-3\"><a href=\"#常用命令-3\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><ul>\n<li>sadd 添加元素</li>\n<li>srem 删除元素</li>\n<li>scard 计算元素个数</li>\n<li>sismember 判断元素是否在集合中</li>\n<li>srandmember 随机从集合返回指定个数元素</li>\n<li>spop 随机从集合弹出元素</li>\n<li>smembers 获取所有元素</li>\n<li>sinter 求多个集合的交集</li>\n<li>sunion 求多个集合的并集</li>\n<li>sdiff 求多个集合的差集</li>\n<li>sinterstore | sunionstore | sdiffstore <em>destination key</em> 将交集、并集、差集的结果保存</li>\n</ul>\n<h4 id=\"内部编码-3\"><a href=\"#内部编码-3\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h4><p>集合类型的内部编码有 2 种</p>\n<ul>\n<li>intset 整数集合</li>\n<li>hashtable 哈希表</li>\n</ul>\n<h2 id=\"ZSet-有序集合\"><a href=\"#ZSet-有序集合\" class=\"headerlink\" title=\"ZSet 有序集合\"></a>ZSet 有序集合</h2><p>有序集合</p>\n<p>ZSet 类似 Set ，但是添加元素之前，要赋一个分值，分值必须为浮点数，<strong>无索引顺序，有范围，元素不能重复，分值可以重复</strong></p>\n<h4 id=\"常用命令-4\"><a href=\"#常用命令-4\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><ul>\n<li>zadd 添加元素</li>\n<li>zcard 计算元素个数</li>\n<li>zscore 查看某个元素分值</li>\n<li>zrank zrevrank 计算元素排名，rank 低到高，revrank 高到低，从 0 开始</li>\n<li>zrem 删除元素</li>\n<li>zincrby 增加元素的分数</li>\n<li>zrange zrevrange 返回指定排名范围的元素，默认低到高，rev 高到低</li>\n<li>zrangebyscore zrevrangebyscore 返回指定分数范围的元素</li>\n<li>zcount 返回指定分数范围成员个数</li>\n<li>zremrangebyrank 删除指定排名内的升序元素</li>\n<li>zremrangebyscore 删除指定分数范围的元素</li>\n<li>zinterstore | zunionstore <em>destination numskey weights aggregate</em> 交集、并集，参数有权重、汇总</li>\n</ul>\n<h4 id=\"内部编码-4\"><a href=\"#内部编码-4\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h4><p>有序集合类型的内部编码有 2 种</p>\n<ul>\n<li>ziplist 压缩列表</li>\n<li>skiplist 跳跃表</li>\n</ul>\n<h2 id=\"List、Set、ZSet-三者比较\"><a href=\"#List、Set、ZSet-三者比较\" class=\"headerlink\" title=\"List、Set、ZSet 三者比较\"></a>List、Set、ZSet 三者比较</h2><table>\n<thead>\n<tr>\n<th>数据结构</th>\n<th>是否重复</th>\n<th>有序</th>\n<th>有序实现方式</th>\n<th>应用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>List 列表</td>\n<td>是</td>\n<td>是</td>\n<td>索引下标</td>\n<td>时间轴、消息队列等</td>\n</tr>\n<tr>\n<td>Set 集合</td>\n<td>否</td>\n<td>否</td>\n<td>无</td>\n<td>标签、社交等</td>\n</tr>\n<tr>\n<td>ZSet 有序集合</td>\n<td>否</td>\n<td>是</td>\n<td>分值</td>\n<td>排行榜系统、社交等</td>\n</tr>\n</tbody></table>\n<h1 id=\"键管理\"><a href=\"#键管理\" class=\"headerlink\" title=\"键管理\"></a>键管理</h1><h2 id=\"单个键管理\"><a href=\"#单个键管理\" class=\"headerlink\" title=\"单个键管理\"></a>单个键管理</h2><ul>\n<li>rename 重命名键</li>\n<li>randomkey 随机返回一个键</li>\n<li>expire expireat 键在 x 秒后过期，键在秒级时间戳后过期</li>\n<li>pexpire pexpireat 键在 x 毫秒后过期，键在毫秒级时间戳后过期</li>\n<li>ttl pttl 查看键剩余过期时间</li>\n<li>persist 清除键的过期时间</li>\n</ul>\n<h2 id=\"遍历键\"><a href=\"#遍历键\" class=\"headerlink\" title=\"遍历键\"></a>遍历键</h2><ul>\n<li>keys 全量遍历键</li>\n<li>scan 渐进式遍历</li>\n</ul>\n<h2 id=\"数据库管理\"><a href=\"#数据库管理\" class=\"headerlink\" title=\"数据库管理\"></a>数据库管理</h2><ul>\n<li>select 切换数据库，一般不用</li>\n<li>flushdb flushall 清除数据库，清除当前、清除所有</li>\n</ul>\n<p><br><br></p>\n","categories":["后端"],"tags":["Redis","Database","NoSQL"]},{"title":"这个假期有点长","url":"https://zhouxelf.com/2019/02/25/这个假期有点长/","content":"<p>今天是 2 月 25 日，年后上班的第一天，这个年假修的有点长。</p>\n<p>刚入职时，就想着大四了，今年过年要多请几天假，在家好好休息休息，多陪陪家人，毕竟以后作为正式员工，想请长假基本不可能了。年前半个月，就给老大提前说了下，年前请了一周，年后请了两周，法定七天，所以这个年一共在家一个月的时间。说实话，请了这么久，我都觉得自己有点儿过分了，感谢老大。</p>\n<p>年前一周，过的还是比较快的，因为有个聚会的任务，初中毕业七八年，第一次组织了班级聚会。说个有意思的，除了在微信群里吆喝一声就确定参加的同学，还有一部分是我一个一个私聊过来的，此外，有个同学问都有谁，我说有谁谁谁，她说，有谁谁谁，我就不去了。我回复她，这都毕业多少年了，还记得呢，她说，人早就忘了，事儿还记得。有个女生说，我就不去了，我现在太胖了，去了你们谁见我都会说我胖，这都算理由吗？还有个点，来的绝大多数都是还没结婚的，结婚的，有孩子的，似乎不怎么愿意来。餐桌上，大家还是像当初那样侃，都没怎么变，挺好的。聚会来的人有四分之一，已经很满意了，结束之后第二天，有个女生给我发消息说，「不是你组织这次聚会，有些人可能一辈子都见不到了，谢谢你」，哈哈，满足，骄傲。不管怎样，聚会已经结束了，大家似乎还比较满意，也算了却了我的一桩心愿吧。下次聚会，不知道又要到什么时候了，可能来的人会更少，不过我还是会去做的，那时候，大家应该都已经结婚了吧。</p>\n<p>休假之前，用工资给老妈买了一个手机，过年带回去，教她用微信、爱奇艺、腾讯视频，但是效果似乎不怎么好，看到网上有人将微信使用教程画出来，我这画工，画出来估计更迷糊了吧。第一年工作，给老爷子、外公外婆准备了红包，一人 500，钱虽然不多，也算是一份心意吧，谁知道我好说歹说，硬是都不要我的钱。老人啊，什么时候都是首先为孩子们考虑，什么时候才能优先自己啊。</p>\n<p>过年啊，什么都好，唯有一件事儿，让我很是头疼，就是被逼着去相亲。说什么，再过几年，年龄大不好找了，什么介绍的知根知底，什么今年见了合适明年就能结婚了，我的天呐，就这么着急吗？我天天在家听这些，耳朵都生茧了，而且不管你说的再有理由，总是能以各种理由反驳你，之前都没发现，我妈口才居然这么厉害，没去做销售真是屈才了。不会说你有对象了吗，对不起，肯定马上就要看照片，明年肯定就让往家带，明年过年我租一个吗？我说，你操劳了半辈子了，我也马上要毕业了，你不用辛苦了，找人打打麻将，落个清闲自在，多好啊，没用。一直说就说呗，开始我还会反驳，后来我就放弃挣扎了。没人帮你介绍也就算了，可偏偏有一些「好心人」很上心你的婚事儿，说和谁谁比较合适，让去见见，我去，来真的啊。迫于压力就去见了，唉，就不说了，心塞。</p>\n<p>最后的一周在家，实在是难熬啊，想念我的小伙伴儿，想开黑，想一块儿侃。开始上班的前三天，就过来了，在家休息了一天，周六一行十多个人去长城，在北十二楼拍了照片。晚上回来，一起的一个朋友那天过生日，就去他家吃了饭，回来就已经十一点了。一天走了两万多步，微信运动第一次占领了封面，就是回来后的第二天，那酸爽，过瘾，今天上班腿还有点儿小疼。</p>\n<p>再上一个月班就回学校了，很想回学校。</p>\n<p>这篇文章流水账，随便记一下，完。</p>\n<blockquote>\n<p>原文链接：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUxMzA0OTY4MA==&mid=2247483687&idx=1&sn=f2c11d79ab91469de944a70322c0b4e3&chksm=f95a5418ce2ddd0e7f7a58318a7566d2c7a337ac2727a25acd8e5e1ecce9258523e0f5c59b56&token=758365972&lang=zh_CN#rd\">这个假期有点长</a></p>\n</blockquote>\n<p><br><br></p>\n","categories":["随笔"],"tags":["随便"]},{"title":"Laravel 中 Session 的使用问题","url":"https://zhouxelf.com/2019/01/11/Laravel 中 Session 的使用问题/","content":"<p>写这篇文章，是因为前段时间在 Laravel 中使用 Session， 突然出现了很诡异的问题，找了好久才发现问题所在，特此记录一下。</p>\n<p>HTTP 协议是无状态的协议，两个请求之间是没有任何关联的，为了让服务器保存用户的状态信息，所以引入了 Session 的概念。</p>\n<p>在 Laravel 中使用 Session 有两种方式，通过 Request 实例或者通过全局辅助函数，我一般使用全局辅助函数，像下面这样</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存储数据到 session</span></span><br><span class=\"line\">session([<span class=\"string\">&#x27;user&#x27;</span> =&gt; <span class=\"string\">&#x27;mrzhouxiaofei&#x27;</span>]);</span><br><span class=\"line\">                      </span><br><span class=\"line\"><span class=\"comment\">// 从 session 获取数据</span></span><br><span class=\"line\"><span class=\"variable\">$value</span> = session(<span class=\"string\">&#x27;user&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>前段时间，在 Laravel 中使用 Session，类似下面这样</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setSession</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    session([<span class=\"string\">&#x27;user&#x27;</span> =&gt; <span class=\"string\">&#x27;mrzhouxiaofei&#x27;</span>]);</span><br><span class=\"line\">    dd(session(<span class=\"string\">&#x27;user&#x27;</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSession</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    dd(session(<span class=\"string\">&#x27;user&#x27;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先，访问方法 setSession() 存储数据到 session，同时使用全局辅助函数 dd() 将刚存进 session 的值显示出来，这里是没问题的。之后访问 getSession() 将 session 里的值显示出来，这里有问题，刚存进 session 的值并没有显示出来。</p>\n<p>之前在 Laravel 中使用 Session 并没有出现这样的问题，我在网上搜了一圈，没找到结果。翻了 Laravel 的文档，找到了下面的一段话。</p>\n<blockquote>\n<p>Laravel 并没有使用 PHP 内置的 Session 功能，而是自己实现了一套更加灵活更加强大的 Session 机制，核心逻辑请参考 Illuminate\\Session\\Middleware\\StartSession 这个中间件，因此在 Laravel 应用中不要试图通过 $_SESSION 方式去获取应用的 Session 值，这是徒劳的。     </p>\n<p>内容来自：Laravel 学院</p>\n</blockquote>\n<p>Laravel 中的 Session 是自己实现的，没有使用 PHP 原生的那套机制，可是你即使自己实现，一个会话期间，共享 Session 是肯定的啊，还是没有解决问题。</p>\n<p>尝试了几次之后，发现方法 setSession 中的 dd() 函数删掉，Session 就正常了。。。</p>\n<p>原来是 dd() 函数搞的鬼。知道原因之后，通过关键字 <strong>Laravel Session dd()</strong> 一下就搜出来好多结果，随便点一个就找到原因了。</p>\n<p><a href=\"https://stackoverflow.com/questions/44350777/laravel-5-4-session-is-not-being-set-if-dd-method-is-used\">Laravel 5.4 session is not being set if dd method is used</a></p>\n<blockquote>\n<p>有人回复：dd() 表示 “dump &amp; die”，die() 函数在 dd() 实现中被调用，它会立即结束框架，并且不允许 Laravel 完成请求并保存 Session。如果想这样用，可以使用 dump() 代替 dd()。</p>\n</blockquote>\n<p>Laravel 中 dd() 和 dump() 的实现如下</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dd() 实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dd</span>(<span class=\"params\">...<span class=\"variable\">$vars</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"variable\">$vars</span> <span class=\"keyword\">as</span> <span class=\"variable\">$v</span>) &#123;</span><br><span class=\"line\">        VarDumper::dump(<span class=\"variable\">$v</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">    <span class=\"keyword\">die</span>(<span class=\"number\">1</span>); <span class=\"comment\">// 调用了 die()</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\"><span class=\"comment\">// dump() 实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dump</span>(<span class=\"params\"><span class=\"variable\">$var</span>, ...<span class=\"variable\">$moreVars</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    VarDumper::dump(<span class=\"variable\">$var</span>);</span><br><span class=\"line\">                   </span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"variable\">$moreVars</span> <span class=\"keyword\">as</span> <span class=\"variable\">$v</span>) &#123;</span><br><span class=\"line\">        VarDumper::dump(<span class=\"variable\">$v</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">                     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span> &lt; func_num_args()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func_get_args();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">                     </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable\">$var</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原因找到了，Laravel 会首先收集需要写入 Session 的所有数据，并在用户的代码执行后自动调用 session()-&gt;save() 方法写入这些数据。这里调用了 dd() 直接终止了整个框架，值根本没有存进去，其它的方法当然取不到了。</p>\n<p>所以开始的问题可以像下面这样解决</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 dump() 代替 dd()</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setSession</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    session([<span class=\"string\">&#x27;user&#x27;</span> =&gt; <span class=\"string\">&#x27;mrzhouxiaofei&#x27;</span>]);</span><br><span class=\"line\">    dump(session(<span class=\"string\">&#x27;user&#x27;</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">                 </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSession</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    dump(session(<span class=\"string\">&#x27;user&#x27;</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">                 </span><br><span class=\"line\"><span class=\"comment\">// 或者在 dd() 之前显示的调用 session()-&gt;save()</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setSession</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    session([<span class=\"string\">&#x27;user&#x27;</span> =&gt; <span class=\"string\">&#x27;mrzhouxiaofei&#x27;</span>]);</span><br><span class=\"line\">    session()-&gt;save();</span><br><span class=\"line\">    dd(session(<span class=\"string\">&#x27;user&#x27;</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">               </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSession</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    dd(session(<span class=\"string\">&#x27;user&#x27;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Laravel 中的 Session 是自己实现的，有这个问题，那原生 PHP 的 Session 有这个问题吗？试了一下</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// setSession.php </span></span><br><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">session_start();</span><br><span class=\"line\"><span class=\"variable\">$_SESSION</span>[<span class=\"string\">&#x27;user&#x27;</span>] = <span class=\"string\">&#x27;mrzhouxiaofei&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">die</span>();</span><br><span class=\"line\">                 </span><br><span class=\"line\"><span class=\"comment\">// getSession.php</span></span><br><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">session_start();</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"variable\">$_SESSION</span>[<span class=\"string\">&#x27;user&#x27;</span>];</span><br></pre></td></tr></table></figure>\n\n<p>首先访问文件 setSession.php，然后访问 getSession.php，看到值被输出，看来 PHP 的原生 Session 机制并没有这个问题。</p>\n<blockquote>\n<p>原文链接：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUxMzA0OTY4MA==&mid=2247483682&idx=1&sn=faf3fbfdd97731c5e8b557a9754e3ee4&chksm=f95a541dce2ddd0b3da2b002d4af0c6ae9e143cdfdd8f7e11b013a27f64ce2841b6987f098ca&token=1657082127&lang=zh_CN#rd\">Laravel 中 Session 的使用问题</a></p>\n</blockquote>\n<p><br><br></p>\n","categories":["后端"],"tags":["PHP","Laravel","Session"]},{"title":"2018 这一年","url":"https://zhouxelf.com/2019/01/02/2018 这一年/","content":"<p>关注了很多公众号，这几天收到最多的推送，就是公众号主个人的年终总结和未来一年的展望，我亦不能免俗。几个月前，我给自己定了几个长期任务，其中之一便是每年年末写一下年终总结，简单回顾一下一年来的得与失。如果能长期坚持下去，就可以让这些总结见证自己的成长，我感觉这种方式很好。新的一年，也算是给自己一个新的开始吧，希望自己能坚持下去。</p>\n<p>2018 年上半年，是我大三的下学期。按照往年的传统，我们一行十几人会在暑假期间去北京找工作。所以，上半年来，主要就是在为了找工作做准备。说是做准备，其实心里还是比较虚的。记得当时，我们几个后端的经常聚在一起开会，制定复习内容和计划。最后的效果，实在是不怎么好，除了一张知识图谱之外，现在已经记不住有什么其它的产出了。</p>\n<p>期间，老师组织了一次去廊坊师范学院交流学习。这次交流，给我带来的惊喜还是蛮大的，见识了不一样的模式，不一样的学习和思考方式。</p>\n<p>此外，现在看来比较重要，当时却没有意识到的事情是 3、4 月份的春招。每年的春招，各大公司除了对上年没有招够的岗位进行补录外，还有一项重要工作就是招收下一届的实习生。如果能在这个时候拿到大公司的实习机会，也是很不错的。考完试，暑假就可以直接去公司实习了，实习两三个月，如果表现好的话，公司直接就给你发校招 offer 了，即使不行，也不会错过 9、10 月份各大公司大规模的秋招，况且，因为有了实习经历，反而会更有优势。在这个阶段的同学，到时候可以关注下。</p>\n<p>上半年，感觉很快就过去了，自己能记住的实在不多。下半年，7 月 9 日，考完试之后，开始了北漂生涯。</p>\n<p>最开始的 21 天，还是挺轻松的，因为这 21 天，是我们院里集中安排的实习时间，地点是在北京的一家培训机构。说是实习，其实就是让你在培训机构学 21 天，结束后，感觉还行，就留在那培训了。事实上，21 天后，确实有一批同学留下参加了培训。本不想参加这个所谓实习，奈何学院强制安排，说是教学课程的一部分，胳膊拧不过大腿，我们也就服从了安排。我们一行本就是要来北京实习的，现在有个落脚点先熟悉下北京，也是能接受的。</p>\n<p>在实习的 21 天，除非有领导过来检查，基本上没在听老师讲什么，都是按自己的计划学习。期间，有同学开始了投简历，我认为自己还没准备好，就没有投。</p>\n<p>实习期间，我们提前找好了房子，实习结束，7 月 28 号，就直接搬了过去。搬过去之后，投简历就开始了，岗位是 PHP 开发实习生，平台就是拉勾、实习僧、BOSS 直聘等等这些。第一次面试邀约是 8 月 7 号，感觉表现不太好的我，最后拿到了实习 offer，还是很开心的，毕竟是第一个 offer，当时还写了一片文章记录一下。那段时间，基本上都是一周几个面试，面试回来之后总结一下记录下来，面过多次之后，基本上会问的点都碰到了，后面就是一直查漏补缺就行了。</p>\n<p>根据往年学姐、学长的经验，我们对能否直接拿到校招 offer 还是持怀疑的，因为他们基本上都是先找的实习，最后拿到了校招 offer。所以，开始我们还是按照这个路子来，先找实习。后来发现这样是不行的，人家基本上都是全力在为校招准备，尤其是北京这边的学生。老师也多次给我们强调，可以找实习，但是主要的精力要在校招上。后面就是投各个公司了，填简历，做笔试，笔试过了是最少三轮的面试，过了又是等意向书，等 offer 邮件。整个校招季从 9 月初大规模开始，一直持续到 10 月底，期间被各个公司笔试轮番轰炸，面试各种血虐。</p>\n<p>8、9 这两个月，应该是这一年最忙碌的了，面试回来后的知识总结写了一大堆，有时候看看自己写的东西，还是很欣慰的。</p>\n<p>我是 9 月 4 号面的现在这家公司的，实习岗，面试通过后，9 月 13 号入的职，到今天已经实习快 4 个月了。实习到 1 个月的时候，我们老大找我谈了谈，说要给我发校招 offer，我接受了，很开心。</p>\n<p>10 月底一直到现在，基本上都是按部就班的实习了。在公司，还是比较轻松的，可能是实习生的原因，并不会给你安排太多太重的任务，任务完成之后，还有时间学习自己的东西，挺舒服的。</p>\n<p>除了找工作之外，说说生活。因为住的比较偏，小区周围设施不太全，所以我们要自己买菜，自己做饭。住的房间呢，也很拥挤，估计只有大一寒假住的地方能与之“媲美”了吧。我们人比较多，所以面试技巧，知识总结，都能在一起交流，空闲之余，还能一块深入交流感情，这一点，大多数北漂的人都没有这个优势。</p>\n<p>好了，2018 这一年，基本上写完了，有点啰嗦，总的来说，上半年，浑浑噩噩，鲜有收获，下半年，比较充实，收获颇丰。</p>\n<p>2018 年写完了，写下 2019 年，我想要做的事儿，对于一些无法量化的、比较虚的就不写了，只写一些可以量化的目标。</p>\n<p>排序不分先后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给老妈换个手机（已经买过了）；</span><br><span class=\"line\">过年给老爷子、外公、外婆包红包；</span><br><span class=\"line\">组织初中同学聚会；</span><br><span class=\"line\">用工资买一台 MacBook Pro；</span><br><span class=\"line\">听一场相声；</span><br><span class=\"line\">看一场 RNG 的比赛；</span><br><span class=\"line\">听一场李宗盛的演唱会；</span><br><span class=\"line\">顺利毕业拿到双证；</span><br><span class=\"line\">毕业出去旅行；</span><br><span class=\"line\">回学校期间组织在新乡的老同学聚会；</span><br><span class=\"line\">每月至少更新一篇博客；</span><br><span class=\"line\">尝试运营一个公众号；</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>第一条，5 月份的时候，老师要加父母的微信，老妈不会上网就没有加，后来老师给我们开会说，这个时代不会上网怎么能行，假期回去一定要教会父母上网，不然他们会和这个时代的距离越来越远，大概是这个意思。我突然意识到这个问题的重要性，不怪他们总是不能理解你，你至少得让他们知道现在是个什么样的时代吧，所以，这个假期，最重要的任务就是教会老妈上网。</p>\n<p>第三条，初中我当了三年的班长，毕业这么多年还没组织过一次聚会，实在是不太称职，今年一定要组织一次。</p>\n<p>第七条，实现几率很小，不知道李宗盛下次开演唱会会是哪一年。</p>\n<p>第十条，15 年一起来新乡上学的有几个同学，毕业之前想把大家聚起来一次，再次分别，不知道什么时候才能再见了。</p>\n<p>第十一条，已经在做了，坚持。</p>\n<p>第十二条，这一条有点难，先给自己立个 flag，能不能坚持下去，就不一定了。</p>\n<p>这篇总结来的有点晚，希望自己 19 年赶紧摆脱懒癌发作。</p>\n<p>完。。。</p>\n<blockquote>\n<p>原文链接：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUxMzA0OTY4MA==&mid=2247483664&idx=1&sn=7654cdb7efeef238b66ab1313fb47fd4&chksm=f95a542fce2ddd3939d3e1e7a35082f5440d7433df71d68903c3829e978eb87a43ee62ced3c1&token=686581160&lang=zh_CN#rd\">2018 这一年</a></p>\n</blockquote>\n<p><br><br></p>\n","categories":["总结"],"tags":["年终总结"]},{"title":"cURL 使用指南","url":"https://zhouxelf.com/2018/12/16/cURL 使用指南/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>cURL，全称 CommandLine Uniform Resource Locator，是一个利用 URL 语法在命令行下工作的文件传输工具。</p>\n<p>大多情况下，我们会使用 cURL 用于文件的下载，就像使用 wget 一样，然而它的功能不仅仅于此。利用 cURL，可以在命令行下模拟发出各种网络请求，通过添加适当的参数，可以得到和提取返回的数据，非常方便。</p>\n<p>cURL 支持很多通信协议，基本上能想到的都支持。</p>\n<h1 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h1><p><strong>查看帮助</strong></p>\n<p>cURL 支持很多参数，使用 –help 可以查看所有参数的用法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl --help</span><br></pre></td></tr></table></figure>\n\n<p><strong>获得页面</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl www.sina.com</span><br></pre></td></tr></table></figure>\n\n<p>如果想将该页面保存下来，可以使用 -o 参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -o sina.html www.sina.com</span><br></pre></td></tr></table></figure>\n\n<p><strong>自动跳转</strong></p>\n<p>有的网址使用了重定向，使用 -L 参数，就可以跟踪重定向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -L www.sina.com</span><br></pre></td></tr></table></figure>\n\n<p><strong>显示头信息</strong></p>\n<p>如果想要查看响应头信息，可以使用 -i 参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -i www.sina.com</span><br></pre></td></tr></table></figure>\n\n<p>如果想只显示响应头信息，可以使用 -I 参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -I www.sina.com</span><br></pre></td></tr></table></figure>\n\n<p><strong>显示通信过程</strong></p>\n<p>添加 -v 参数可以显示一次通信的整个过程，包括了端口连接和请求头信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -v www.sina.com</span><br></pre></td></tr></table></figure>\n\n<p>其中 &gt; 表示发送的部分，&lt; 表示接收的部分。</p>\n<p><strong>提交表单</strong></p>\n<p>表单提交支持 GET 和 POST 两种方法，GET 比较简单，数据直接跟在网址后面即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl example.com&#x2F;form.php?data&#x3D;xxx</span><br></pre></td></tr></table></figure>\n\n<p>POST 方法必须把数据和网址分开，并使用 –data 参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X POST --data &quot;data&#x3D;xxx&quot; example.com&#x2F;form.php</span><br></pre></td></tr></table></figure>\n\n<p><strong>HTTP 动词</strong></p>\n<p>curl 默认的 HTTP 动词是 GET，使用 -X 参数可以支持其它动词</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X POST www.example.com</span><br><span class=\"line\"></span><br><span class=\"line\">curl -X DELETE www.example.com</span><br></pre></td></tr></table></figure>\n\n<p><strong>文件上传</strong></p>\n<p>假设文件上传的表单如下面这样</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;POST enctype=&quot;</span><span class=\"attr\">multipart</span>/<span class=\"attr\">form-data</span>&quot; <span class=\"attr\">action</span>=<span class=\"string\">&quot;form.php&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">file</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;uoload&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">submit</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;press&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;OK&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>那么就可以使用 curl 像下面这样上传文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -F upload&#x3D;@localfilename -F press&#x3D;OK [URL]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Referer 字段</strong></p>\n<p>如果需要在请求头信息里，提供一个 referer 字段，表示从哪里跳转过来的，可以使用 –referer 参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl --referer www.example.com mail.example.com</span><br></pre></td></tr></table></figure>\n\n<p><strong>User Agent 字段</strong></p>\n<p>这个字段用来表示客户端的设备信息，服务器有时会根据这个字段，针对不同的设备，返回不同格式的网页，比如手机版和桌面版。</p>\n<p>curl 可以使用 –user-agent 参数模拟不同的设备</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl --user-agent &quot;[User Agent]&quot; [URL]</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用 cookie</strong></p>\n<p>利用 –cookie 参数，curl 可以发送 cookie</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl --cookie &quot;name&#x3D;xxx&quot; www.example.com</span><br></pre></td></tr></table></figure>\n\n<p>至于具体的 cookie 值，可以从响应头信息的 Set-Cookie 字段中得到。</p>\n<p><strong>增加头信息</strong></p>\n<p>有时需要在请求头信息里增加一个字段，这时可以使用 –header 参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl --header &quot;Content-Type:application&#x2F;json&quot; www.example.com</span><br></pre></td></tr></table></figure>\n\n<p><strong>HTTP 认证</strong></p>\n<p>有些网域需要 HTTP 认证，这时 curl 就需要使用 –user 参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl --user name:password www.example.com</span><br></pre></td></tr></table></figure>\n\n<p>以上内容参考阮老师文章：<a href=\"http://www.ruanyifeng.com/blog/2011/09/curl.html\">curl网站开发指南</a></p>\n<p>关于 cURL 的更多信息：<a href=\"http://man.linuxde.net/curl\">curl命令</a></p>\n<h1 id=\"在-PHP-中使用-cURL\"><a href=\"#在-PHP-中使用-cURL\" class=\"headerlink\" title=\"在 PHP 中使用 cURL\"></a>在 PHP 中使用 cURL</h1><p>PHP 开启 cURL 扩展之后，就可以使用各种 cURL 函数了。</p>\n<p>在 PHP 里执行 cURL，需要遵循一个套路，学会这个套路，所有的请求就都学会了，套路很简单，如下</p>\n<ol>\n<li>创建会话</li>\n<li>配置参数</li>\n<li>执行会话</li>\n<li>关闭会话</li>\n</ol>\n<p>没错，就是这个简单。</p>\n<p>下面列出几个步骤对应的函数</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl_init()  初始化一个 cURL 会话</span><br><span class=\"line\">curl_setopt() 设置一个 cURL 会话的传输选项</span><br><span class=\"line\">curl_exec() 执行一个 cURL 会话</span><br><span class=\"line\">curl_close() 关闭一个 cURL 会话</span><br></pre></td></tr></table></figure>\n\n<p><strong>发送 GET 请求</strong></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    <span class=\"comment\">// 创建 cURL 会话</span></span><br><span class=\"line\">    <span class=\"variable\">$ch</span> = curl_init();</span><br><span class=\"line\">    <span class=\"comment\">// 设置 URL</span></span><br><span class=\"line\">    curl_setopt(<span class=\"variable\">$ch</span>, CURLOPT_URL, <span class=\"string\">&quot;http://www.baidu.com&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 设置响应结果返回类型</span></span><br><span class=\"line\">    curl_setopt(<span class=\"variable\">$ch</span>, CURLOPT_RETURNTRANSFER, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 执行 cURL 会话</span></span><br><span class=\"line\">    curl_exec(<span class=\"variable\">$ch</span>);</span><br><span class=\"line\">    <span class=\"comment\">//关闭 cURL 会话</span></span><br><span class=\"line\">    curl_close(<span class=\"variable\">$ch</span>);</span><br></pre></td></tr></table></figure>\n\n<p>访问该文件，将会看到百度首页，其中第三步设置响应结果返回类型为 0，表示将执行结果直接输出，才看到了百度首页，设为 1 时，表示将结果存到变量里。</p>\n<p>curl_setopt() 函数的参数非常之多，执行 cURL 会话之前的各种设置，比如 设置请求头、设置 URL、设置最长访问时间等等，都是通过该函数来实现，关于所有参数含义，见 <a href=\"http://php.net/manual/zh/function.curl-setopt.php\">官方文档</a>。</p>\n<p><strong>发送 POST 请求</strong></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    <span class=\"variable\">$ch</span> = curl_init();</span><br><span class=\"line\">    </span><br><span class=\"line\">    curl_setopt(<span class=\"variable\">$ch</span>, CURLOPT_URL, <span class=\"string\">&quot;http://localhost/xxx.php&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 设置参数</span></span><br><span class=\"line\">    curl_setopt(<span class=\"variable\">$ch</span>, CURLOPT_POSTFIELDS, <span class=\"string\">&quot;user=mrzhouxiaofei&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 设置请求方法为 POST</span></span><br><span class=\"line\">    curl_setopt(<span class=\"variable\">$ch</span>, CURLOPT_POST, <span class=\"literal\">TRUE</span>);</span><br><span class=\"line\">    curl_setopt(<span class=\"variable\">$ch</span>, CURLOPT_RETURNTRANSFER, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    curl_exec(<span class=\"variable\">$ch</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    curl_close(<span class=\"variable\">$ch</span>);</span><br></pre></td></tr></table></figure>\n\n<p>和 GET 方法相比，多设置了参数 CURLOPT_POSTFIELDS 和 CURLOPT_POST。</p>\n<p>本文只给出最基本的 GET 和 POST 方法，至于其它使用方法，如 文件上传、HTTP 认证、使用 Cookie 等等，可以自己试着去探索。<br><br><br></p>\n","categories":["后端"],"tags":["Linux","PHP","cURL"]},{"title":"利用 Webhooks 实现代码的自动拉取","url":"https://zhouxelf.com/2018/11/17/利用 Webhooks 实现代码的自动拉取/","content":"<p>很长时间没有更新博客了，前段时间一直都在忙着找工作，最近才稳定下来，后面有机会的话再说说找工作的经历。</p>\n<p>以前做完一个项目，要放到服务器上运行，最开始使用 Xftp 将代码传上去，中间如果需要修改代码，都是在本地调试完再传到服务器，覆盖原来的文件生效，非常麻烦。</p>\n<p>后来使用 Git 做版本管理，配合代码托管平台，就不用一个个的传文件了，每次修改完代码 push 到远程版本库以后，只需要登陆到服务器上，pull 一下，最新的代码就被拉下来了，比之前方便了许多。</p>\n<p>进了公司在发现，之前的方法还是太笨了，Github 提供了一个功能 Webhooks，利用它可以实现代码的自动拉取，每次 push 完代码，再也不用登陆服务器手动拉代码了，非常方便。</p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Webhooks 是代码托管平台提供的一个功能，对于任意一个项目，可以设置一个 URL，同时选择一些事件，当触发了这些事件时，代码托管平台会自动请求该 URL，并带上一些必要的参数。简单点说，Webhooks 就是一个项目的钩子函数，当你执行一些事件时，会自动调用这个钩子函数，事件就是 push、pull request、fork 等等这些操作。</p>\n<p>代码托管平台有很多，常见的第三方的 GitHub、码云、Coding，或者自己搭建的 GitLab 都提供了 Webhooks 功能，设置方法基本都差不多，本文以 GitHub 为例讲解。 </p>\n<h1 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h1><h2 id=\"设置回调-URL，选择事件\"><a href=\"#设置回调-URL，选择事件\" class=\"headerlink\" title=\"设置回调 URL，选择事件\"></a>设置回调 URL，选择事件</h2><p>登陆 GitHub，新建一个版本库，命名为 Webhooks，依次点击 <strong>Settings</strong> -&gt; <strong>Webhooks</strong> -&gt; <strong>Add webhook</strong>，之后如下图</p>\n<p><img src=\"/images/Webhooks_1.png\"></p>\n<p>三个参数：</p>\n<ul>\n<li>Payload URL：必填，回调的 URL，每次检测到事件时，都会向该 URL 发送一个 POST 请求；</li>\n<li>Content type：POST 携带数据的方式，GitHub 上提供 application/json 和 application/x-www-form-urlencoded 两种，如果只是实现简单的拉代码，选哪一种无所谓，其它的代码托管平台可能只提供 json 方式；</li>\n<li>Secret：密钥，用于验证，现在先不填。</li>\n</ul>\n<p>下面就是事件选择，默认 push 的时候触发，一般这样就可以了，如果想选择其它事件，点第三个按钮就可以看到所有的事件，选择合适的事件后，点 <strong>Add webhook</strong> 按钮即可。</p>\n<h2 id=\"添加-Deploy-keys\"><a href=\"#添加-Deploy-keys\" class=\"headerlink\" title=\"添加 Deploy keys\"></a>添加 Deploy keys</h2><p><strong>两个公钥</strong></p>\n<ul>\n<li>用户公钥：SSH keys，认证用户身份，添加用户公钥后，对该用户的所有项目拥有读写权限，用于开发机；</li>\n<li>部署公钥：Deploy keys，对项目进行授权，拥有只读权限，一般用于生产或测试服务器。</li>\n</ul>\n<p>详情：<a href=\"https://cnbin.github.io/blog/2015/06/18/coding-zhong-bu-shu-gong-chi-he-ssh-gong-chi-qu-bie/\">Coding 中部署公匙和 SSH 公匙区别</a></p>\n<p>知道两个公钥的区别后，通过 SSH 登陆服务器，执行以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir &#x2F;var&#x2F;www&#x2F;.ssh</span><br><span class=\"line\">sudo chown -R www-data:www-data &#x2F;var&#x2F;www&#x2F;.ssh</span><br><span class=\"line\">sudo -Hu www-data ssh-keygen -t rsa -C &quot;your_name@example.com&quot;</span><br></pre></td></tr></table></figure>\n\n<p>第二条命令表示将目录 .ssh 的拥有者、所属组修改为 www-data，第三条命令表示在 /var/www/.ssh 目录下生成密钥，同时将该密钥的拥有者、所属组修改为 www-data，为什么这么做呢？因为在 Ubuntu 中，PHP 运行时的用户为 www-data，如果不修改，PHP 运行时的用户是读不到这个部署公钥的，也就拉不了代码了。</p>\n<p>如果不确定系统的 PHP 运行时使用的哪个用户，可以随便新建一个 PHP 文件，写下面的代码，访问一下就知道了。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    system(<span class=\"string\">&quot;whoami&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>部署公钥生成后，执行下面的代码查看公钥，复制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cat &#x2F;var&#x2F;www&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>\n\n<p>依次点击项目的 <strong>Setting</strong> -&gt; <strong>Deploy keys</strong> -&gt; <strong>Add deploy key</strong>，将公钥粘进去，点击 <strong>Add key</strong> 添加完成。</p>\n<h2 id=\"准备钩子文件\"><a href=\"#准备钩子文件\" class=\"headerlink\" title=\"准备钩子文件\"></a>准备钩子文件</h2><p>在 GitHub 上操作完成后，下面的操作都在服务器上。</p>\n<p>在刚才设置的 URL 指向的目录下，新建一个 index.php 文件，代码如下</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    shell_exec(<span class=\"string\">&quot;cd /var/www/html/Webhooks &amp;&amp; git pull 2&gt;&amp;1&quot;</span>);  <span class=\"comment\">// 切换到项目目录，执行 git pull，加上 2&gt;&amp;1 会输出一些错误信息，便于调试</span></span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>需要说明的是，我上面设置的回调地址 webhooks.mrzhouxiaofei.com 指向了服务器上 /var/www/html/webhooks 这个地址，所以新建的 index.php 文件也在这个目录下，GitHub 回调地址时，自然就访问到了这个文件。</p>\n<p>如果你设置的回调地址不一样，可以根据地址访问的目录新建文件。</p>\n<p>同样的，也需要为目录和文件设置拥有者、所属组，命令如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown -R www-data:www-data &#x2F;var&#x2F;www&#x2F;html&#x2F;webhooks</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"克隆项目文件\"><a href=\"#克隆项目文件\" class=\"headerlink\" title=\"克隆项目文件\"></a>克隆项目文件</h2><p>克隆项目，同时修改项目的拥有者、所属组，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo -Hu www-data git clone git@github.com:mrzhouxiaofei&#x2F;Webhooks.git</span><br></pre></td></tr></table></figure>\n\n<p>执行完后，服务器的 /var/www/ 目录结构如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----&#x2F;var&#x2F;www</span><br><span class=\"line\">------------&#x2F;.ssh   部署公钥，拥有者、所属组为 www-data</span><br><span class=\"line\">------------&#x2F;html</span><br><span class=\"line\">----------------&#x2F;webhooks&#x2F;index.php 钩子文件，拥有者、所属组为 www-data</span><br><span class=\"line\">----------------&#x2F;Webhooks 项目目录，拥有者、所属组为 www-data</span><br></pre></td></tr></table></figure>\n\n<p>到此为止，服务器应该就能自动拉取项目文件了，可以在 GitHub 上的 Webhooks 项目里新建一个文件，然后看下服务器的项目目录里有没有拉取新文件。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>打开项目，点击 <strong>Setting</strong> -&gt; <strong>Webhooks</strong>，可以看到刚刚设置的回调 URL，点进去拉到最下面 Recent  Deliveries，可是看到所有的被触发事件的请求，任意点击一个查看，如下图所示</p>\n<p><img src=\"/images/Webhooks_2.png\"></p>\n<ul>\n<li>Request<ul>\n<li>Headers：请求头，包含一些基本信息；</li>\n<li>Payload：触发这次事件的所有信息都包含在这里面，包括项目名、commit、用户名等等，如果服务器上的钩子文件要做一些高级操作，就可以解析这个字段。</li>\n</ul>\n</li>\n<li>Response<ul>\n<li>Headers：响应头</li>\n<li>Body：服务器钩子文件的返回信息，调试输出信息可以写到钩子文件里，请求后在这里查看。</li>\n</ul>\n</li>\n</ul>\n<p>每一种事件发送的 Payload 格式是不一样的，关于 Payload 更多信息，请看官方文档: <a href=\"https://developer.github.com/v3/activity/events/types/\">Event Types &amp; Payloads</a></p>\n<h2 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h2><p>对于基本的项目拉取代码，以上的内容已经足够了。</p>\n<p>但是很容易就能想到一个问题，如果别人知道了你回调的 URL，然后他在自己项目的 Webhooks 里填上你的 URL，然后疯狂 push 怎么办？尽管没办法获取你的代码，但是你的服务器会执行一些不必要的 git pull，显然这是我们不能容忍的。</p>\n<p>这个时候，<strong>Secret</strong> 就派上用场了。添加 Webhooks 的时候，<strong>Secret</strong> 列填上一个随机字符串，在服务器上的钩子文件里再写个验证就可以了，这样就可以挡住恶意的攻击了。</p>\n<p>具体来说，在 <strong>Secret</strong> 里填上一个字符串，比如说填上 mrzhouxiaofei，登陆服务器，编辑 /var/www/html/webhooks 目录下的钩子文件 index.php，内容如下</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"variable\">$secret</span> = <span class=\"string\">&quot;mrzhouxiaofei&quot;</span>;  <span class=\"comment\">//密钥，和 GitHub 上对应</span></span><br><span class=\"line\"><span class=\"variable\">$path</span> = <span class=\"string\">&quot;/var/www/html/Webhooks&quot;</span>;  <span class=\"comment\">//服务器上的项目文件目录</span></span><br><span class=\"line\"><span class=\"variable\">$signature</span> = <span class=\"variable\">$_SERVER</span>[<span class=\"string\">&quot;HTTP_X_HUB_SIGNATURE&quot;</span>];  <span class=\"comment\">//获取散列字符串</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"variable\">$signature</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable\">$rawPost</span> = file_get_contents(<span class=\"string\">&quot;php://input&quot;</span>);  <span class=\"comment\">//获取收到的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">list</span>(<span class=\"variable\">$algo</span>, <span class=\"variable\">$hash</span>) = explode(<span class=\"string\">&quot;=&quot;</span>, <span class=\"variable\">$signature</span>, <span class=\"number\">2</span>);  <span class=\"comment\">//获取散列算法、散列值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable\">$hash</span> === hash_hmac(<span class=\"variable\">$algo</span>, <span class=\"variable\">$rawPost</span>, <span class=\"variable\">$secret</span>)) &#123;  <span class=\"comment\">//验证</span></span><br><span class=\"line\">\t\tshell_exec(<span class=\"string\">&quot;cd /var/www/html/Webhooks &amp;&amp; git pull 2&gt;&amp;1&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">echo</span> <span class=\"string\">&quot;代码拉取成功&quot;</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Secret 验证失败&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&quot;请输入 Secret&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，每次触发事件，GitHub 会使用 SHA-1 将发送的数据和 <strong>Secret</strong> 一起散列，生成一个散列字符串，在钩子文件中需要对这个散列字符串进行验证。 </p>\n<p>对于其它代码托管平台，有的不提供 Secret 字段，有的 Secret 在钩子文件中直接验证，至于使用哪一种，看对应的官方文档就行了。<br><br><br></p>\n","categories":["效率"],"tags":["环境搭建","GitHub","Webhooks"]},{"title":"HTTP 缓存","url":"https://zhouxelf.com/2018/08/28/HTTP 缓存/","content":"<blockquote>\n<p>声明：这是 Google Developers 上的一篇文章，感觉很棒，但是需要科学上网才能访问，特转了过来，望周知。</p>\n<p>原地址：<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\">HTTP 缓存</a></p>\n</blockquote>\n<p>通过网络获取内容速度缓慢又开销巨大，较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。</p>\n<p>好在每个浏览器都自带了 HTTP 缓存实现功能，您只需要确保每个服务器响应都提供正确的 HTTP 标头指令，以指示浏览器何时可以缓存响应以及可以缓存多久即可。</p>\n<blockquote>\n<p>Note: 如果您在应用中使用 Webview 来获取和显示网页内容，可能需要提供额外的配置标志，以确保 HTTP 缓存得到启用、其大小根据用例进行了合理设置并且缓存将持久保存。务必查看平台文档并确认您的设置！</p>\n</blockquote>\n<p><img src=\"/images/HTTP%E7%BC%93%E5%AD%98_1.png\"></p>\n<p>当服务器返回响应时，还会发出一组 HTTP 标头，用于描述响应的内容类型、长度、缓存指令、验证令牌等。例如，在上图的交互中，服务器返回一个 1024 字节的响应，指示客户端将其缓存最多 120 秒，并提供一个验证令牌「x234dff」，可在响应过期后用来检查资源是否被修改。</p>\n<h1 id=\"通过-ETag-验证缓存的响应\"><a href=\"#通过-ETag-验证缓存的响应\" class=\"headerlink\" title=\"通过 ETag 验证缓存的响应\"></a>通过 ETag 验证缓存的响应</h1><ul>\n<li>服务器使用 ETag HTTP 标头传递验证令牌；</li>\n<li>验证令牌可实现高效的资源更新检查：资源未发生变化时不会传送任何数据。</li>\n</ul>\n<p>假定在首次获取资源 120 秒后，浏览器又对该资源发起了新的请求。首先，浏览器会检查本地缓存并找到之前的响应，遗憾的是，该响应现已过期，浏览器无法使用。此时，浏览器可以直接发出新的请求并获取新的完整响应，不过，这样做效率较低，因为如果资源未发生变化，那么下载与缓存中已有的完全相同的信息就毫无道理可言。</p>\n<p>这正是验证令牌（在 ETag 标头中指定）旨在解决的问题。服务器生成并返回的随机令牌通常是文件内容的哈希值或某个其他指纹。客户端不需要了解指纹是如何生成的，只需在下一次请求时将其发送至服务器，如果指纹仍然相同，则表示资源未发生变化，您就可以跳过下载。</p>\n<p><img src=\"/images/HTTP%E7%BC%93%E5%AD%98_2.png\"></p>\n<p>在上例中，客户端自动在「If-None-Match」HTTP 标头内提供 ETag 令牌。服务器根据当前资源核对令牌，如果它未发生变化，服务器将返回「304 Not Modified」响应，以告知浏览器缓存中的响应未发生变化，可以再延用 120 秒。请注意，您不必再次下载响应，这节约了时间和带宽。</p>\n<p>作为网络开发者，您如何利用高效的重新验证？浏览器会替我们完成所有工作：它会自动检测之前是否指定了验证令牌，它会将验证令牌追加到发出的请求上，并且它会根据从服务器接收的响应在必要时更新缓存时间戳。<strong>我们唯一要做的就是确保服务器提供必要的 ETag 令牌，检查您的服务器文档中有无必要的配置标志。</strong></p>\n<blockquote>\n<p>Note: 提示：HTML5 Boilerplate 项目包含所有最流行服务器的<a href=\"https://github.com/h5bp/server-configs\">配置文件样例</a>，其中为每个配置标志和设置都提供了详细的注解。在列表中找到您喜爱的服务器，查找合适的设置，然后复制/确认您的服务器配置了推荐的设置。</p>\n</blockquote>\n<h1 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h1><ul>\n<li>每个资源都可通过 Cache-Control HTTP 标头定义其缓存策略；</li>\n<li>Cache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久。</li>\n</ul>\n<p>从性能优化的角度来说，<strong>最佳请求是无需与服务器通信的请求</strong>：您可以通过响应的本地副本消除所有网络延迟，以及避免数据传送的流量费用。为实现此目的，HTTP 规范允许服务器返回 Cache-Control 指令，这些指令控制浏览器和其他中间缓存如何缓存各个响应以及缓存多久。</p>\n<blockquote>\n<p>Note: Cache-Control 标头是在 HTTP/1.1 规范中定义的，取代了之前用来定义响应缓存策略的标头（例如 Expires）。所有现代浏览器都支持 Cache-Control，因此，使用它就够了。</p>\n</blockquote>\n<p><img src=\"/images/HTTP%E7%BC%93%E5%AD%98_3.png\"></p>\n<p><strong>no-cache 和 no-store</strong></p>\n<p>no-cache 表示必须先与服务器确认返回的响应是否发生了变化，然后才能使用该响应来满足后续对同一网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，但如果资源未发生变化，则可避免下载。</p>\n<p>相比之下，no-store 则要简单得多。它直接禁止浏览器以及所有中间缓存存储任何版本的返回响应，例如，包含个人隐私数据或银行业务数据的响应。每次用户请求该资产时，都会向服务器发送请求，并下载完整的响应。</p>\n<p><strong>public 和 private</strong></p>\n<p>如果响应被标记为 public，则即使它有关联的 HTTP 身份验证，甚至响应状态代码通常无法缓存，也可以缓存响应。大多数情况下，public 不是必需的，因为明确的缓存信息（例如 max-age）已表示响应是可以缓存的。</p>\n<p>相比之下，浏览器可以缓存 private 响应，不过，这些响应通常只为单个用户缓存，因此不允许任何中间缓存对其进行缓存。例如，用户的浏览器可以缓存包含用户私人信息的 HTML 网页，但 CDN 却不能缓存。</p>\n<p><strong>max-age</strong></p>\n<p>指令指定从请求的时间开始，允许获取的响应被重用的最长时间（单位：秒），例如，max-age=60 表示可在接下来的 60 秒缓存和重用响应。</p>\n<h1 id=\"定义最佳-Cache-Control-策略\"><a href=\"#定义最佳-Cache-Control-策略\" class=\"headerlink\" title=\"定义最佳 Cache-Control 策略\"></a>定义最佳 Cache-Control 策略</h1><p><img src=\"/images/HTTP%E7%BC%93%E5%AD%98_4.png\"></p>\n<p>按照以上决策树为您的应用使用的特定资源或一组资源确定最佳缓存策略。在理想的情况下，您的目标应该是在客户端上缓存尽可能多的响应，缓存尽可能长的时间，并且为每个响应提供验证令牌，以实现高效的重新验证。</p>\n<p><img src=\"/images/HTTP%E7%BC%93%E5%AD%98_5.jpg\"></p>\n<p>根据 HTTP Archive，在排名最高的 300,000 个网站（按照 Alexa 排名）中，所有下载的响应中几乎有半数可由浏览器缓存，这可以大量减少重复的网页浏览和访问。当然，这并不意味着您的特定应用有 50% 的资源可以缓存。一些网站的资源 90% 以上都可以缓存，而其他网站可能有许多私密或时效要求高的数据根本无法缓存。</p>\n<p><strong>请审核您的网页，确定哪些资源可以缓存，并确保它们返回正确的 Cache-Control 和 ETag 标头。</strong></p>\n<h1 id=\"废弃和更新缓存的响应\"><a href=\"#废弃和更新缓存的响应\" class=\"headerlink\" title=\"废弃和更新缓存的响应\"></a>废弃和更新缓存的响应</h1><ul>\n<li>在资源「过期」之前，将一直使用本地缓存的响应；</li>\n<li>您可以通过在网址中嵌入文件内容指纹，强制客户端更新到新版本的响应；</li>\n<li>为获得最佳性能，每个应用都需要定义自己的缓存层次结构。</li>\n</ul>\n<p>浏览器发出的所有 HTTP 请求会首先路由到浏览器缓存，以确认是否缓存了可用于满足请求的有效响应。如果有匹配的响应，则从缓存中读取响应，这样就避免了网络延迟和传送产生的流量费用。</p>\n<p><strong>不过，如果您想更新或废弃缓存的响应，该怎么办？</strong> 例如，假定您已告诉访问者将某个 CSS 样式表缓存长达 24 小时 (max-age=86400)，但设计人员刚刚提交了一个您希望所有用户都能使用的更新，您该如何通知拥有现在「已过时」的 CSS 缓存副本的所有访问者更新其缓存？在不更改资源网址的情况下，您做不到。</p>\n<p>浏览器缓存响应后，缓存的版本将一直使用到过期（由 max-age 或 expires 决定），或一直使用到由于某种其他原因从缓存中删除，例如用户清除了浏览器缓存。因此，构建网页时，不同的用户可能最终使用的是文件的不同版本：刚获取了资源的用户将使用新版本的响应，而缓存了早期（但仍有效）副本的用户将使用旧版本的响应。</p>\n<p><strong>所以，如何才能鱼和熊掌兼得：客户端缓存和快速更新？</strong> 您可以在资源内容发生变化时更改它的网址，强制用户下载新响应。通常情况下，可以通过在文件名中嵌入文件的指纹或版本号来实现 - 例如 style.x234dff.css。</p>\n<p><img src=\"/images/HTTP%E7%BC%93%E5%AD%98_6.png\"></p>\n<p>因为能够定义每个资源的缓存策略，所以您可以定义「缓存层次结构」，这样不但可以控制每个响应的缓存时间，还可以控制访问者看到新版本的速度。</p>\n<p>为了进行说明，我们一起分析一下上面的示例：</p>\n<ul>\n<li>HTML 被标记为 no-cache，这意味着浏览器在每次请求时都始终会重新验证文档，并在内容变化时获取最新版本。此外，在 HTML 标记内，您在 CSS 和 JavaScript 网址中嵌入指纹，如果这些文件的内容发生变化，网页的 HTML 也会随之改变，并会下载 HTML 响应的新副本。</li>\n<li>允许浏览器和中间缓存（例如 CDN）缓存 CSS，并将 CSS 设置为 1 年后到期。请注意，您可以放心地使用 1 年的「远期过期」，因为您在文件名中嵌入了文件的指纹，CSS 更新时网址也会随之变化。</li>\n<li>JavaScript 同样设置为 1 年后到期，但标记为 private，这或许是因为它包含的某些用户私人数据是 CDN 不应缓存的。</li>\n<li>图像缓存时不包含版本或唯一指纹，并设置为 1 天后到期。</li>\n</ul>\n<p>您可以组合使用 ETag、Cache-Control 和唯一网址来实现一举多得：较长的过期时间、控制可以缓存响应的位置以及随需更新。</p>\n<h1 id=\"缓存检查清单\"><a href=\"#缓存检查清单\" class=\"headerlink\" title=\"缓存检查清单\"></a>缓存检查清单</h1><p>不存在什么最佳缓存策略，您需要根据通信模式、提供的数据类型以及应用特定的数据更新要求，为每个资源定义和配置合适的设置，以及整体的「缓存层次结构」。</p>\n<p>在制定缓存策略时，您需要牢记下面这些技巧和方法：</p>\n<ul>\n<li><strong>使用一致的网址</strong>，如果您在不同的网址上提供相同的内容，将会多次获取和存储这些内容。提示：请注意，网址区分大小写。</li>\n<li>**确保服务器提供验证令牌 (ETag)**，有了验证令牌，当服务器上的资源未发生变化时，就不需要传送相同的字节。</li>\n<li><strong>确定中间缓存可以缓存哪些资源</strong>，对所有用户的响应完全相同的资源非常适合由 CDN 以及其他中间缓存进行缓存。</li>\n<li><strong>为每个资源确定最佳缓存周期</strong>，不同的资源可能有不同的更新要求，为每个资源审核并确定合适的 max-age。</li>\n<li><strong>确定最适合您的网站的缓存层次结构</strong>，您可以通过为 HTML 文档组合使用包含内容指纹的资源网址和短时间或 no-cache 周期，来控制客户端获取更新的速度。</li>\n<li><strong>最大限度减少搅动</strong>，某些资源的更新比其它资源频繁。如果资源的特定部分（例如 JavaScript 或 CSS）会经常更新，可以考虑将其代码作为单独的文件提供，这样一来，每次获取更新时，其余内容（例如变化不是很频繁的内容库代码）可以从缓存获取，从而最大限度减少下载的内容大小。<br><br><br></li>\n</ul>\n","categories":["前端"],"tags":["HTTP","缓存"]},{"title":"远行","url":"https://zhouxelf.com/2018/04/26/远行/","content":"<p><audio src=\"http://videos.mrzhouxiaofei.com/%E8%BF%9C%E8%A1%8C.mp3\" controls=\"controls\"></audio></p>\n<p><strong>歌词如下</strong></p>\n<blockquote>\n<p>亲亲我爱多么希望你会明白<br>我需要安静下来 想像未来怎么安排<br>时间飞快时间飞快 来不及抹去昨日尘埃<br>时间它不让我等待 就这样迎面而来<br>不舍你那黑白分明亮亮的眼睛<br>只是你年纪还小 无从明了我的心情<br>时间不停 时间不停 原谅我依然决定远行<br>当所有等待都变成曾经<br>我会说好多精彩的故事给你听<br>就要离开 虽然我心中有无限伤怀<br>就要离开 虽然我心中有难言悲哀<br>明知寂寞叫人难以忍耐<br>也许一切就此从头再来<br>虽然不知何时回来<br>我只盼望你会明白 你会明白<br>喔 你会明白  </p>\n<p>回想过去 曾经黯淡 几许光采<br>有时候我不知道这样决定应不应该<br>时间飞快该来的会来<br>我从来不曾这样坦白<br>啊往日绚烂的梦已不再<br>我已经累了 我需要离开这舞台<br>就要离开 虽然我心中有无限伤怀<br>就要离开 虽然我心中有难言悲哀<br>明知寂寞叫人难以忍耐<br>也许一切就此从头再来<br>虽然不知何时回来<br>我只盼望你会明白<br>你会明白 喔 你会明白<br>你会明白 喔 你会明白 喔<br>你会明白</p>\n</blockquote>\n<p><br><br></p>\n","categories":["随笔"],"tags":["随笔"]},{"title":"MySQL 之索引部分","url":"https://zhouxelf.com/2018/04/16/MySQL 之索引部分/","content":"<h1 id=\"索引概述\"><a href=\"#索引概述\" class=\"headerlink\" title=\"索引概述\"></a>索引概述</h1><h2 id=\"索引的本质及作用\"><a href=\"#索引的本质及作用\" class=\"headerlink\" title=\"索引的本质及作用\"></a>索引的本质及作用</h2><p>索引（也称「键」）是为了加速表中数据行的检索而创建的一种分散的数据结构。</p>\n<p>数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为 O(n) 的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>\n<h2 id=\"索引的优缺点\"><a href=\"#索引的优缺点\" class=\"headerlink\" title=\"索引的优缺点\"></a>索引的优缺点</h2><p><strong>优点</strong></p>\n<ol>\n<li>大大加快数据的检索速度；</li>\n<li>创建唯一性索引，能保证数据库表中每一行数据的唯一性；</li>\n<li>加速表与表之间的连接；</li>\n<li>在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。</li>\n</ol>\n<p><strong>缺点</strong></p>\n<ol>\n<li>索引需要占用额外的物理空间；</li>\n<li>当对表中的数据进行增加、删除和修改时，索引也需要动态的维护，降低了数据的维护速度。</li>\n</ol>\n<h1 id=\"索引的类型\"><a href=\"#索引的类型\" class=\"headerlink\" title=\"索引的类型\"></a>索引的类型</h1><p>在 MySQL 中，索引是在存储引擎层而不是服务器层实现的，所以，并没有统一的索引标准。不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现方式也可能不同。</p>\n<p>目前 MySQL 提供了常用的四种索引：</p>\n<ul>\n<li>B-Tree 索引：最常见的索引类型，大部分引擎都支持 B-Tree 索引；</li>\n<li>Hash 索引：只有 Memory 引擎支持 Hash 索引，基于 Hash 表实现，使用场景简单；</li>\n<li>R-Tree：空间数据索引，MyISAM 引擎支持，主要用于地理数据存储；</li>\n<li>全文索引：一种特殊类型的索引，类似于搜索引擎的功能。</li>\n</ul>\n<p><strong>说明：</strong> 平时讨论的索引，如果没有特别指明，一般都是指 B-Tree 索引，而且从技术上说，底层实现方式其实是 B+Tree。 B-Tree 索引又分为几种，比如普通索引、唯一索引、主键索引等等。关于全文索引，详见 <a href=\"http://mrzhouxiaofei.com/2018/04/14/MySQL%20%E4%B9%8B%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95/\">MySQL 之全文索引</a></p>\n<h2 id=\"三种常用存储引擎索引支持情况\"><a href=\"#三种常用存储引擎索引支持情况\" class=\"headerlink\" title=\"三种常用存储引擎索引支持情况\"></a>三种常用存储引擎索引支持情况</h2><table>\n<thead>\n<tr>\n<th>索引</th>\n<th>MyISAM</th>\n<th>InnoDB</th>\n<th>Memory</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>B-Tree</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Hash 索引</td>\n<td>No</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>R-Tree 索引</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>全文索引</td>\n<td>Yes</td>\n<td>5.6 之后</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h2 id=\"B-Tree-索引\"><a href=\"#B-Tree-索引\" class=\"headerlink\" title=\"B-Tree 索引\"></a>B-Tree 索引</h2><ul>\n<li>普通索引：创建普通索引时，不限制任何条件（唯一、非空等限制），该类型的索引可以创建在任何数据类型上。</li>\n<li>唯一索引：UNIQUE，唯一索引，就是限制被索引的值必须是唯一的。当为表中某个字段设置主键或唯一性约束时，系统会自动创建关联该字段的唯一索引。</li>\n<li>主键索引：PRIMARY，主键索引，一种特殊的唯一索引，不允许有空值。</li>\n</ul>\n<p><strong>说明：</strong> 关于唯一索引和唯一约束的探讨，详见 <a href=\"http://mrzhouxiaofei.com/2018/03/27/%E8%B0%88%E8%B0%88%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95/\">谈谈唯一约束和唯一索引</a></p>\n<h1 id=\"索引的操作\"><a href=\"#索引的操作\" class=\"headerlink\" title=\"索引的操作\"></a>索引的操作</h1><h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><p>三种创建方式</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span> <span class=\"number\">1.</span> 建表时创建</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> 表名 (</span><br><span class=\"line\">    id <span class=\"type\">int</span>(<span class=\"number\">11</span>),</span><br><span class=\"line\">    xxx xxx,</span><br><span class=\"line\">    [索引类型] index<span class=\"operator\">|</span>key [索引名] (属性名<span class=\"number\">1</span> [(长度)] [<span class=\"keyword\">ASC</span><span class=\"operator\">|</span><span class=\"keyword\">DESC</span>]) </span><br><span class=\"line\">);</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span> <span class=\"number\">2.</span> 直接创建</span><br><span class=\"line\"><span class=\"keyword\">create</span> index 索引名</span><br><span class=\"line\">    <span class=\"keyword\">on</span> 表名 (属性名 [(长度)] [<span class=\"keyword\">ASC</span><span class=\"operator\">|</span><span class=\"keyword\">DESC</span>]);</span><br><span class=\"line\">           </span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span> <span class=\"number\">3.</span> 修改表创建</span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> 表名</span><br><span class=\"line\">    <span class=\"keyword\">add</span> [索引类型] index<span class=\"operator\">|</span>key [索引名] (属性名<span class=\"number\">1</span> [(长度)] [<span class=\"keyword\">ASC</span><span class=\"operator\">|</span><span class=\"keyword\">DESC</span>]);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong> 不能使用第二种方式创建主键索引</p>\n<h2 id=\"修改\"><a href=\"#修改\" class=\"headerlink\" title=\"修改\"></a>修改</h2><p>没必要修改，直接删除重建即可。</p>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>两种删除方式</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span> <span class=\"number\">1.</span> 直接删除</span><br><span class=\"line\"><span class=\"keyword\">drop</span> index 索引名</span><br><span class=\"line\">    <span class=\"keyword\">on</span> 表名;</span><br><span class=\"line\">          </span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span> <span class=\"number\">2.</span> 修改表删除</span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> 表名</span><br><span class=\"line\">    <span class=\"keyword\">drop</span> index 索引名;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看\"><a href=\"#查看\" class=\"headerlink\" title=\"查看\"></a>查看</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> index<span class=\"operator\">|</span>keys <span class=\"keyword\">from</span> 表名 </span><br></pre></td></tr></table></figure>\n\n<p>列的意义：</p>\n<ul>\n<li>Table：表名</li>\n<li>Non_unique：如果索引值唯一，则为 0，否则为 1</li>\n<li>Key_name：索引名</li>\n<li>Seq_in_index：索引中列的序列号，从 1 开始</li>\n<li>Column_name：列名</li>\n<li>Collation：列在索引中的存储形式，在 MySQL 中，值「A」（升序）或 NULL（无分类）</li>\n<li>Cardinality：索引中唯一值数目的估计值</li>\n<li>Sub_part：如果列只是被部分地编入索引，则为被编入索引的字符的数目，如果整列被编入索引，则为 NULL</li>\n<li>Packed：说明关键字如何被压缩，如果没有被压缩，则为 NULL</li>\n<li>Null：如果列含有 NULL，则值为 YES，如果没有，则该列为 NO</li>\n<li>Index_type：索引类型（BTREE，FULLTEXT，HASH，RTREE）</li>\n<li>Comment：更多评论</li>\n</ul>\n<h1 id=\"索引的选择\"><a href=\"#索引的选择\" class=\"headerlink\" title=\"索引的选择\"></a>索引的选择</h1><h2 id=\"索引选择原则\"><a href=\"#索引选择原则\" class=\"headerlink\" title=\"索引选择原则\"></a>索引选择原则</h2><ol>\n<li>较频繁的作为查询条件的字段应该创建索引；</li>\n<li>唯一性太差的字段（比如性别）不适合单独创建索引，即使频繁作为查询条件；</li>\n<li>更新非常频繁的字段不适合创建索引；</li>\n<li>不会出现在 Where 子句中的字段不该创建索引。</li>\n</ol>\n<h2 id=\"索引选择原则细述\"><a href=\"#索引选择原则细述\" class=\"headerlink\" title=\"索引选择原则细述\"></a>索引选择原则细述</h2><ul>\n<li>性能优化过程中，选择在哪个列上创建索引是最非常重要的。可以考虑使用索引的主要有两种类型的列：<strong>在 where 子句中出现的列，在 join 子句中出现的列，</strong> 而不是在 select 关键字后选择列表的列。</li>\n<li>索引列的基数越大，索引的效果越好。例如，存放出生日期的列具有不同的值，很容易区分行，而用来记录性别的列，只有「男」和「女」，对此进行索引没有多大用处，因为不管搜索哪个值，都会得出大约一半的行。</li>\n<li>使用短索引，如果对字符串列进行索引，应该指定一个前缀长度，可节省大量索引空间，提升查询速度。</li>\n<li>利用最左前缀原则。</li>\n</ul>\n<h2 id=\"索引选择注意事项\"><a href=\"#索引选择注意事项\" class=\"headerlink\" title=\"索引选择注意事项\"></a>索引选择注意事项</h2><p>既然索引可以加快查询速度，那么是不是只要查询语句需要，就创建索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL 在运行时也要消耗资源维护索引，因此索引并不是越多越好。</p>\n<p><strong>一般下面两种情况不建议建索引：</strong></p>\n<ol>\n<li>表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了；</li>\n<li>索引的选择性较低，所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：<strong>Index Selectivity = Cardinality / #T</strong> 显然选择性的取值范围为 (0, 1]，选择性越高的索引价值越大，这是由 B+Tree 的性质决定的。</li>\n</ol>\n<p>除此之外，还有两个点需要注意：</p>\n<ol>\n<li>MySQL 只对以下操作符才使用索引：&lt;、&lt;=、=、&gt;、&gt;=、between、in，以及某些时候的 like（不以通配符 % 或 _ 开头)；</li>\n<li>不要过度索引，只保持需要的索引。每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能。在修改表的内容时，索引必须进行更新，有时可能需要重构，因此，索引越多，所花的时间越长。</li>\n</ol>\n<h1 id=\"索引是最好的解决方案？\"><a href=\"#索引是最好的解决方案？\" class=\"headerlink\" title=\"索引是最好的解决方案？\"></a>索引是最好的解决方案？</h1><p>索引并不总是最好的解决方案。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，大部分情况下简单的全表扫描更高效。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价将随之增长。这种情况下，则需要一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条记录地匹配。这是就要使用分表、分库等分区技术了。</p>\n<p><strong>参考文章</strong></p>\n<p><a href=\"http://blog.codinglabs.org/articles/theory-of-mysql-index.html\">MySQL索引背后的数据结构及算法原理</a><br><a href=\"http://book.51cto.com/art/200906/132452.htm\">索引的利弊与如何判定，是否需要索引</a><br>高性能 MySQL（第三版）<br><br><br></p>\n","categories":["后端"],"tags":["MySQL","索引"]},{"title":"MySQL 之全文索引","url":"https://zhouxelf.com/2018/04/14/MySQL 之全文索引/","content":"<p>最近在复习数据库索引部分，看到了 fulltext，也即全文索引，虽然全文索引在平时的业务中用到的不多，但是感觉它有点儿意思，所以花了点时间研究一下，特此记录。</p>\n<h1 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>通过数值比较、范围过滤等就可以完成绝大多数我们需要的查询，但是，如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。</p>\n<p>你可能会说，用 like + % 就可以实现模糊匹配了，为什么还要全文索引？like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。</p>\n<p>你可能没有注意过全文索引，不过至少应该对一种全文索引技术比较熟悉：各种的搜索引擎。虽然搜索引擎的索引对象是超大量的数据，并且通常其背后都不是关系型数据库，不过全文索引的基本原理是一样的。</p>\n<h2 id=\"版本支持\"><a href=\"#版本支持\" class=\"headerlink\" title=\"版本支持\"></a>版本支持</h2><p>开始之前，先说一下全文索引的版本、存储引擎、数据类型的支持情况</p>\n<ol>\n<li>MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；</li>\n<li>MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;</li>\n<li>只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。</li>\n</ol>\n<p>测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。</p>\n<h1 id=\"操作全文索引\"><a href=\"#操作全文索引\" class=\"headerlink\" title=\"操作全文索引\"></a>操作全文索引</h1><p>索引的操作随便一搜都是，这里还是再啰嗦一遍。</p>\n<h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><ol>\n<li>创建表时创建全文索引</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> fulltext_test (</span><br><span class=\"line\">    id <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">    content text <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    tag <span class=\"type\">varchar</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">    <span class=\"keyword\">PRIMARY</span> KEY (id),</span><br><span class=\"line\">    FULLTEXT KEY content_tag_fulltext(content,tag)  <span class=\"operator\">/</span><span class=\"operator\">/</span> 创建联合全文索引列</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>MyISAM <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在已存在的表上创建全文索引</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> fulltext index content_tag_fulltext</span><br><span class=\"line\">    <span class=\"keyword\">on</span> fulltext_test(content,tag);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>通过 SQL 语句 ALTER TABLE 创建全文索引</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> fulltext_test</span><br><span class=\"line\">    <span class=\"keyword\">add</span> fulltext index content_tag_fulltext(content,tag);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"修改\"><a href=\"#修改\" class=\"headerlink\" title=\"修改\"></a>修改</h2><p>修改个 O，直接删掉重建。</p>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><ol>\n<li>直接使用 DROP INDEX 删除全文索引</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">drop</span> index content_tag_fulltext</span><br><span class=\"line\">    <span class=\"keyword\">on</span> fulltext_test;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>通过 SQL 语句 ALTER TABLE 删除全文索引</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> fulltext_test</span><br><span class=\"line\">    <span class=\"keyword\">drop</span> index content_tag_fulltext;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"使用全文索引\"><a href=\"#使用全文索引\" class=\"headerlink\" title=\"使用全文索引\"></a>使用全文索引</h1><p>和常用的模糊匹配使用 like + % 不同，全文索引有自己的语法格式，使用 match 和 against 关键字，比如</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> fulltext_test </span><br><span class=\"line\">    <span class=\"keyword\">where</span> <span class=\"keyword\">match</span>(content,tag) against(<span class=\"string\">&#x27;xxx xxx&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong> match() 函数中指定的列必须和全文索引中指定的列完全相同，否则就会报错，无法使用全文索引，这是因为全文索引不会记录关键字来自哪一列。如果想要对某一列使用全文索引，请单独为该列创建全文索引。</p>\n<h1 id=\"测试全文索引\"><a href=\"#测试全文索引\" class=\"headerlink\" title=\"测试全文索引\"></a>测试全文索引</h1><h2 id=\"添加测试数据\"><a href=\"#添加测试数据\" class=\"headerlink\" title=\"添加测试数据\"></a>添加测试数据</h2><p>有了上面的知识，就可以测试一下全文索引了。</p>\n<p>首先创建测试表，插入测试数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> test (</span><br><span class=\"line\">    id <span class=\"type\">int</span>(<span class=\"number\">11</span>) unsigned <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> auto_increment,</span><br><span class=\"line\">    content text <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">    <span class=\"keyword\">primary</span> key(id),</span><br><span class=\"line\">    fulltext key content_index(content)</span><br><span class=\"line\">) engine<span class=\"operator\">=</span>MyISAM <span class=\"keyword\">default</span> charset<span class=\"operator\">=</span>utf8;</span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> test (content) <span class=\"keyword\">values</span> (<span class=\"string\">&#x27;a&#x27;</span>),(<span class=\"string\">&#x27;b&#x27;</span>),(<span class=\"string\">&#x27;c&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> test (content) <span class=\"keyword\">values</span> (<span class=\"string\">&#x27;aa&#x27;</span>),(<span class=\"string\">&#x27;bb&#x27;</span>),(<span class=\"string\">&#x27;cc&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> test (content) <span class=\"keyword\">values</span> (<span class=\"string\">&#x27;aaa&#x27;</span>),(<span class=\"string\">&#x27;bbb&#x27;</span>),(<span class=\"string\">&#x27;ccc&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> test (content) <span class=\"keyword\">values</span> (<span class=\"string\">&#x27;aaaa&#x27;</span>),(<span class=\"string\">&#x27;bbbb&#x27;</span>),(<span class=\"string\">&#x27;cccc&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>按照全文索引的使用语法执行下面查询</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test <span class=\"keyword\">where</span> <span class=\"keyword\">match</span>(content) against(<span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test <span class=\"keyword\">where</span> <span class=\"keyword\">match</span>(content) against(<span class=\"string\">&#x27;aa&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test <span class=\"keyword\">where</span> <span class=\"keyword\">match</span>(content) against(<span class=\"string\">&#x27;aaa&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>根据我们的惯性思维，应该会显示 4 条记录才对，然而结果是 1 条记录也没有，只有在执行下面的查询时</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> test <span class=\"keyword\">where</span> <span class=\"keyword\">match</span>(content) against(<span class=\"string\">&#x27;aaaa&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>才会搜到 <em>aaaa</em> 这 1 条记录。</p>\n<p>为什么？这个问题有很多原因，其中最常见的就是 <strong>最小搜索长度</strong> 导致的。另外插一句，使用全文索引时，测试表里至少要有 4 条以上的记录，否则，会出现意想不到的结果。</p>\n<p>MySQL 中的全文索引，有两个变量，最小搜索长度和最大搜索长度，对于长度小于最小搜索长度和大于最大搜索长度的词语，都不会被索引。通俗点就是说，想对一个词语使用全文索引搜索，那么这个词语的长度必须在以上两个变量的区间内。</p>\n<p>这两个的默认值可以使用以下命令查看</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%ft%&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到这两个变量在 MyISAM 和 InnoDB 两种存储引擎下的变量名和默认值</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span> MyISAM</span><br><span class=\"line\">ft_min_word_len <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">ft_max_word_len <span class=\"operator\">=</span> <span class=\"number\">84</span>;</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span> InnoDB</span><br><span class=\"line\">innodb_ft_min_token_size <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">innodb_ft_max_token_size <span class=\"operator\">=</span> <span class=\"number\">84</span>;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到最小搜索长度 MyISAM 引擎下默认是 4，InnoDB 引擎下是 3，也即，MySQL 的全文索引只会对长度大于等于 4 或者 3 的词语建立索引，而刚刚搜索的只有 <em>aaaa</em> 的长度大于等于 4。</p>\n<h2 id=\"配置最小搜索长度\"><a href=\"#配置最小搜索长度\" class=\"headerlink\" title=\"配置最小搜索长度\"></a>配置最小搜索长度</h2><p>全文索引的相关参数都无法进行动态修改，必须通过修改 MySQL 的配置文件来完成。修改最小搜索长度的值为 1，首先打开 MySQL 的配置文件 /etc/my.cnf，在 [mysqld] 的下面追加以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">innodb_ft_min_token_size &#x3D; 1</span><br><span class=\"line\">ft_min_word_len &#x3D; 1</span><br></pre></td></tr></table></figure>\n\n<p>然后重启 MySQL 服务器，并修复全文索引。注意，修改完参数以后，一定要修复下索引，不然参数不会生效。</p>\n<p>两种修复方式，可以使用下面的命令修复</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repair <span class=\"keyword\">table</span> test quick;</span><br></pre></td></tr></table></figure>\n\n<p>或者直接删掉重新建立索引，再次执行上面的查询，<em>a、aa、aaa</em> 就都可以查出来了。</p>\n<p>但是，这里还有一个问题，搜索关键字 <em>a</em> 时，为什么 <em>aa、aaa、aaaa</em> 没有出现结果中，讲这个问题之前，先说说两种全文索引。 </p>\n<h1 id=\"两种全文索引\"><a href=\"#两种全文索引\" class=\"headerlink\" title=\"两种全文索引\"></a>两种全文索引</h1><h2 id=\"自然语言的全文索引\"><a href=\"#自然语言的全文索引\" class=\"headerlink\" title=\"自然语言的全文索引\"></a>自然语言的全文索引</h2><p>默认情况下，或者使用 in natural language mode 修饰符时，match() 函数对文本集合执行自然语言搜索，上面的例子都是自然语言的全文索引。</p>\n<p>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索，如果一个词语的在超过 50% 的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。上面提到的，测试表中必须有 4 条以上的记录，就是这个原因。</p>\n<p>这个机制也比较好理解，比如说，一个数据表存储的是一篇篇的文章，文章中的常见词、语气词等等，出现的肯定比较多，搜索这些词语就没什么意义了，需要搜索的是那些文章中有特殊意义的词，这样才能把文章区分开。</p>\n<h2 id=\"布尔全文索引\"><a href=\"#布尔全文索引\" class=\"headerlink\" title=\"布尔全文索引\"></a>布尔全文索引</h2><p>在布尔搜索中，我们可以在查询中自定义某个被搜索的词语的相关性，当编写一个布尔搜索查询时，可以通过一些前缀修饰符来定制搜索。</p>\n<p>MySQL 内置的修饰符，上面查询最小搜索长度时，搜索结果 ft_boolean_syntax 变量的值就是内置的修饰符，下面简单解释几个，更多修饰符的作用可以查手册</p>\n<ul>\n<li><strong>+</strong> 必须包含该词</li>\n<li><strong>-</strong> 必须不包含该词</li>\n<li><strong>&gt;</strong> 提高该词的相关性，查询的结果靠前</li>\n<li><strong>&lt;</strong> 降低该词的相关性，查询的结果靠后</li>\n<li><strong>(*)星号</strong> 通配符，只能接在词后面</li>\n</ul>\n<p>对于上面提到的问题，可以使用布尔全文索引查询来解决，使用下面的命令，<em>a、aa、aaa、aaaa</em> 就都被查询出来了。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> test <span class=\"keyword\">where</span> <span class=\"keyword\">match</span>(content) against(<span class=\"string\">&#x27;a*&#x27;</span> <span class=\"keyword\">in</span> <span class=\"type\">boolean</span> mode);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>好了，差不多写完了，又到了总结的时候。</p>\n<p>MySQL 的全文索引最开始仅支持英语，因为英语的词与词之间有空格，使用空格作为分词的分隔符是很方便的。亚洲文字，比如汉语、日语、汉语等，是没有空格的，这就造成了一定的限制。不过 MySQL 5.7.6 开始，引入了一个 ngram 全文分析器来解决这个问题，并且对 MyISAM 和 InnoDB 引擎都有效。</p>\n<p>事实上，MyISAM 存储引擎对全文索引的支持有很多的限制，例如表级别锁对性能的影响、数据文件的崩溃、崩溃后的恢复等，这使得 MyISAM 的全文索引对于很多的应用场景并不适合。所以，多数情况下的建议是使用别的解决方案，例如 Sphinx、Lucene 等等第三方的插件，亦或是使用 InnoDB 存储引擎的全文索引。</p>\n<h2 id=\"几个注意点\"><a href=\"#几个注意点\" class=\"headerlink\" title=\"几个注意点\"></a>几个注意点</h2><ol>\n<li>使用全文索引前，搞清楚版本支持情况；</li>\n<li>全文索引比 like + % 快 N 倍，但是可能存在精度问题；</li>\n<li>如果需要全文索引的是大量数据，建议先添加数据，再创建索引；</li>\n<li>对于中文，可以使用 MySQL 5.7.6 之后的版本，或者第三方插件。</li>\n</ol>\n<p><strong>参考文章</strong></p>\n<p><a href=\"http://blog.51cto.com/imysqldba/1618465\">mysql全文索引____简介</a><br><a href=\"https://dev.mysql.com/doc/refman/5.7/en/fulltext-search.html\">MySQL 官方参考手册</a><br>高性能 MySQL（第三版）<br><br><br></p>\n","categories":["后端"],"tags":["MySQL","索引","全文索引"]},{"title":"MySQL Explain 命令详解","url":"https://zhouxelf.com/2018/04/06/MySQL Explain 命令详解/","content":"<h1 id=\"Explain-作用\"><a href=\"#Explain-作用\" class=\"headerlink\" title=\"Explain 作用\"></a>Explain 作用</h1><p>Explain 提供了 MySQL 如何执行 SQL 语句的信息，通过这些信息，可以对 SQL 语句做相应的优化，提高执行效率。</p>\n<h1 id=\"Explain-使用\"><a href=\"#Explain-使用\" class=\"headerlink\" title=\"Explain 使用\"></a>Explain 使用</h1><p>调用 Explain，只需要在 SQL 语句前添加 explain 关键字即可。</p>\n<p>一般情况下，添加 explain 关键字后，认为 MySQL 不会执行查询，但是如果在 from 子句中包含子查询，那么 MySQL 实际上会执行子查询，将其子查询的结果放在一个临时表中，然后完成外层查询优化。</p>\n<blockquote>\n<p>MySQL 5.6 之前的版本，只允许解释 select 语句，从 MySQL 5.6 开始，非 select 语句也可以被解释了。</p>\n</blockquote>\n<h1 id=\"Explain-字段\"><a href=\"#Explain-字段\" class=\"headerlink\" title=\"Explain 字段\"></a>Explain 字段</h1><p>调用 Explain 后，MySQL 会返回一行或者多行记录，通过这些记录就可以知道 SQL 语句的执行情况了。</p>\n<p>每行记录都包含了以下几个字段</p>\n<ul>\n<li>id：执行编号，标识 select 所属的行</li>\n<li>select_type：select 查询的类型</li>\n<li>table：查询的是哪个表</li>\n<li>partitions：匹配的分区</li>\n<li>type：关联类型，或者访问类型</li>\n<li>possible_keys：该查询可以选用的索引</li>\n<li>key：该查询选用的索引</li>\n<li>key_len：索引中使用的字节数</li>\n<li>ref：显示上述表的连接匹配条件，即哪些列或常量被用于查询索引列上的值</li>\n<li>rows：估计为了找到所需行而要读取的行数</li>\n<li>filtered：按表条件过滤的行的百分比</li>\n<li>Extra：额外的信息</li>\n</ul>\n<h1 id=\"Explain-字段详解\"><a href=\"#Explain-字段详解\" class=\"headerlink\" title=\"Explain 字段详解\"></a>Explain 字段详解</h1><h2 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h2><p>该列总是包含一个编号，标识 select 所属的行。如果语句当中没有子查询或联合查询，那么只会有唯一的 select，于是每一行在这个列中都将显示一个 1。否则，内层的 select 语句一般会顺序编号，对应于原始语句中的位置。</p>\n<p>id 值越大，越先执行。</p>\n<h2 id=\"select-type\"><a href=\"#select-type\" class=\"headerlink\" title=\"select_type\"></a>select_type</h2><p>该列指明了查询的类型，以下为常见的取值</p>\n<ul>\n<li>SIMPLLE：简单查询，该查询不包含 UNION 或子查询</li>\n<li>PRIMARY：如果查询包含 UNION 或子查询，则最外层的查询被标识为 PRIMARY</li>\n<li>UNION：表示此查询是 UNION 中的第二个或者随后的查询</li>\n<li>DEPENDENT：UNION 满足 UNION 中的第二个或者随后的查询，其次取决于外面的查询</li>\n<li>UNION RESULT：UNION 的结果</li>\n<li>SUBQUERY：子查询中的第一个 select 语句</li>\n<li>DEPENDENT SUBQUERY：子查询中的 第一个 select，同时取决于外面的查询</li>\n<li>DERIVED：派生表 select，包含在 from 字句的子查询中的查询</li>\n<li>UNCACHEABLE SUBQUERY：满足是子查询中的第一个 select 语句，同时意味着 select 中的某些特性阻止结果被缓存于一个 Item_cache 中</li>\n<li>UNCACHEABLE UNION：满足此查询是 UNION 中的第二个或者随后的查询，同时意味着 select 中的某些特性阻止结果被缓存于一个 Item_cache 中</li>\n</ul>\n<h2 id=\"table\"><a href=\"#table\" class=\"headerlink\" title=\"table\"></a>table</h2><p>该列显示了对应行正在访问哪个表，或者该表的别名。</p>\n<h2 id=\"partitions\"><a href=\"#partitions\" class=\"headerlink\" title=\"partitions\"></a>partitions</h2><p>记录将与查询匹配的分区，非分区表的值为NULL。</p>\n<h2 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h2><p>该列称为关联类型或者访问类型，它指明了 MySQL 决定如何查找表中符合条件的行，同时为判断查询是否高效提供了重要的依据。</p>\n<p>以下为常见的取值</p>\n<ul>\n<li>ALL：全表扫描，这个类型是性能最差的查询之一。通常来说，我们的查询不应该出现 ALL 类型，因为这样的查询，在数据量最大的情况下，对数据库的性能是巨大的灾难。</li>\n<li>index：全索引扫描，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型是扫描全部的索引，主要优点是避免了排序，但是开销仍然非常大。如果在 Extra 列看到 Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要少很多。</li>\n<li>range：范围扫描，就是一个有限制的索引扫描，它开始于索引里的某一点，返回匹配这个值域的行。这个类型通常出现在 =、&lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN、IN() 的操作中，key 列显示使用了哪个索引，当 type 为该值时，则输出的 ref 列为 NULL，并且 key_len 列是此次查询中使用到的索引最长的那个。</li>\n<li>ref：一种索引访问，也称索引查找，它返回所有匹配某个单个值的行。此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了最左前缀规则索引的查询。</li>\n<li>eq_ref：使用这种索引查找，最多只返回一条符合条件的记录。在使用唯一性索引或主键查找时会出现该值，非常高效。</li>\n<li>const、system：该表至多有一个匹配行，在查询开始时读取，或者该表是系统表，只有一行匹配。其中 const 用于在和 primary key 或 unique 索引中有固定值比较的情形。</li>\n<li>NULL：在执行阶段不需要访问表。</li>\n</ul>\n<p>该列取不同值的执行效率依次是</p>\n<p>ALL &lt; index &lt; range &lt; ref &lt; eq_ref &lt; const &lt; system &lt; NULL</p>\n<p>一般来说，至少要保证查询达到 range 级别，最好能达到 ref 级别。</p>\n<h2 id=\"possible-keys\"><a href=\"#possible-keys\" class=\"headerlink\" title=\"possible_keys\"></a>possible_keys</h2><p>该列显示了查询可以选用哪些索引，但是列出来的索引，可能对于后续优化过程是没有用的。</p>\n<h2 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h2><p>该列显示了查询选用了哪个索引，如果该索引没有出现在 possible_keys 列中，那么选用它可能出于另外的原因，比如，它可能选择了一个覆盖索引。</p>\n<h2 id=\"key-len\"><a href=\"#key-len\" class=\"headerlink\" title=\"key_len\"></a>key_len</h2><p>该列显示了在索引里使用的字节数，当 key 列的值为 NULL 时，则该列也是 NULL。如果正在使用的只是索引里的某些列，那么可以通过用该列的值算出来具体是哪些列。</p>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p>该列显示了哪些字段或者常量被用来和 key 配合从表中查询记录出来。</p>\n<h2 id=\"rows\"><a href=\"#rows\" class=\"headerlink\" title=\"rows\"></a>rows</h2><p>该列显示了估计要找到所需的行而要读取的行数，这个值是个估计值，原则上值越小越好。</p>\n<h2 id=\"filtered\"><a href=\"#filtered\" class=\"headerlink\" title=\"filtered\"></a>filtered</h2><p>该列表示根据条件过滤的表行的估计百分比，和 rows 相乘，表示和查询计划里前一个表关联的行数。</p>\n<h2 id=\"Extra\"><a href=\"#Extra\" class=\"headerlink\" title=\"Extra\"></a>Extra</h2><p>该列显示了有关 MySQL 如何解析查询的其它信息。</p>\n<p>以下为常见的取值</p>\n<ul>\n<li>Using index：使用覆盖索引，表示查询索引就可查到所需数据，不用扫描表数据文件，往往说明性能不错。</li>\n<li>Using Where：在存储引擎检索行后再进行过滤，使用了 where 从句来限制哪些行将与下一张表匹配或者是返回给用户。</li>\n<li>Using temporary：在查询结果排序时会使用一个临时表，一般出现于排序、分组和多表 join 的情况，查询效率不高，建议优化。</li>\n<li>Using filesort：对结果使用一个外部索引排序，而不是按索引次序从表里读取行，一般有出现该值，都建议优化去掉，因为这样的查询 CPU 资源消耗大。</li>\n</ul>\n<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><p>Explain 不会告诉你触发器、存储过程或用户自定义函数对查询的影响情况；<br>Explain 不会告诉你 MySQL 在查询执行中所做的特定优化；<br>Explain 只是个近似结果；<br>Explain 不会显示关于查询的执行计划的所有信息。<br><br><br></p>\n","categories":["后端"],"tags":["MySQL","索引","优化"]},{"title":"谈谈唯一约束和唯一索引","url":"https://zhouxelf.com/2018/03/27/谈谈唯一约束和唯一索引/","content":"<p>最近在看数据库相关知识，感觉唯一约束和唯一索引好像有点类似，于是研究了一番，于是就有了这篇文章。</p>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>开始之前，先解释一下约束和索引。</p>\n<p><strong>约束</strong> 全称完整性约束，它是关系数据库中的对象，用来存放插入到一个表中一列数据的规则，用来确保数据的准确性和一致性。</p>\n<p><strong>索引</strong> 数据库中用的最频繁的操作是数据查询，索引就是为了加速表中数据行的检索而创建的一种分散的数据结构。可以把索引类比成书的目录，有目录的肯定比没有目录的书，更方便查找。</p>\n<p><strong>唯一约束</strong> 保证在一个字段或者一组字段里的数据都与表中其它行的对应数据不同。和主键约束不同，唯一约束允许为 NULL，只是只能有一行。</p>\n<p><strong>唯一索引</strong> 不允许具有索引值相同的行，从而禁止重复的索引或键值。</p>\n<p>唯一约束和唯一索引都是为了保证表中被限制的字段不允许有重复的值，看起来功能是一样的，那为什么要设计这样两种一样的功能呢？</p>\n<h1 id=\"探究\"><a href=\"#探究\" class=\"headerlink\" title=\"探究\"></a>探究</h1><p>带着这个问题，我在网上搜索了一番。</p>\n<p>最开始，在 Oracle 的社区里看到了下面这个对话，原问题链接：<a href=\"https://community.oracle.com/message/4110430\">https://community.oracle.com/message/4110430</a></p>\n<p><img src=\"/images/%E7%BA%A6%E6%9D%9F%E7%B4%A2%E5%BC%95_1.jpg\"></p>\n<p>大概意思是说，他看了一本关于 Oracle 的书，书中说，唯一约束和唯一索引是不同的，但是书中没解释这两个有什么不同。</p>\n<p>然后下面跟了一个答案如下</p>\n<p><img src=\"/images/%E7%BA%A6%E6%9D%9F%E7%B4%A2%E5%BC%95_2.jpg\"></p>\n<p>大意是说，约束和索引是不同的，约束为优化提供了更多信息，并且允许在唯一约束上建立外键，而唯一索引是不行的，然后还提供了一个小例子。</p>\n<p>不能听他说两句就相信了，本着实践出真理的原则，我做了下面的求证。尽管文章中提到的是 Oracle 数据库，而我本地的是 MySQL，不过还是决定试一遍，按照他给出的例子，在本地做了如下测试。</p>\n<p>首先创建两个字段值一样的表 t1，t2，并为 t1 表中的 col1 列设置唯一约束。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t1 (</span><br><span class=\"line\">    col1 <span class=\"type\">INT</span>(<span class=\"number\">11</span>), </span><br><span class=\"line\">    col2 <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>), </span><br><span class=\"line\">    <span class=\"keyword\">CONSTRAINT</span> t1_uq <span class=\"keyword\">UNIQUE</span> (col1)</span><br><span class=\"line\">);</span><br><span class=\"line\">         </span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t2 (</span><br><span class=\"line\">    col1 <span class=\"type\">INT</span>(<span class=\"number\">11</span>), </span><br><span class=\"line\">    col2 <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<p><img src=\"/images/%E7%BA%A6%E6%9D%9F%E7%B4%A2%E5%BC%95_3.jpg\"></p>\n<p>然后为表 t2 表中的 col1 列设置唯一索引</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">UNIQUE</span> INDEX </span><br><span class=\"line\">    t2_idx <span class=\"keyword\">ON</span> t2 (col1);</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<p><img src=\"/images/%E7%BA%A6%E6%9D%9F%E7%B4%A2%E5%BC%95_4.jpg\"></p>\n<p>创建表 t3，并将 t1 表中的 col1 列设置为 t3 表中 col2 列的外键</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t3 (</span><br><span class=\"line\">    col1 <span class=\"type\">INT</span>(<span class=\"number\">11</span>), </span><br><span class=\"line\">    col2 <span class=\"type\">INT</span>(<span class=\"number\">11</span>), </span><br><span class=\"line\">    col3 <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>), </span><br><span class=\"line\">    <span class=\"keyword\">CONSTRAINT</span> t3_fk <span class=\"keyword\">FOREIGN</span> KEY (col2) <span class=\"keyword\">REFERENCES</span> t1 (col1)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<p><img src=\"/images/%E7%BA%A6%E6%9D%9F%E7%B4%A2%E5%BC%95_5.jpg\"></p>\n<p>创建表 t4，并将 t2 表中的 col1 列设置为 t4 表中 col2 列的外键</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> t4 (</span><br><span class=\"line\">    col1 <span class=\"type\">INT</span>(<span class=\"number\">11</span>), </span><br><span class=\"line\">    col2 <span class=\"type\">INT</span>(<span class=\"number\">11</span>), </span><br><span class=\"line\">    col3 <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>), </span><br><span class=\"line\">    <span class=\"keyword\">CONSTRAINT</span> t4_fk <span class=\"keyword\">FOREIGN</span> KEY (col2) <span class=\"keyword\">REFERENCES</span> t2 (col1)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>重点来了，根据上面回答唯一约束和唯一索引的区别，t4 表应该是建不成功的，因为 t4 表中 col2 列依赖于 t2 表中 col1 列，而 t2 表中的 col1 列建立了唯一索引，并没有建立唯一约束，因此 t4 表应该建立失败。</p>\n<p>然而，运行结果如下</p>\n<p><img src=\"/images/%E7%BA%A6%E6%9D%9F%E7%B4%A2%E5%BC%95_6.jpg\"></p>\n<p>是的，没有看错，表 t4 建立成功了，并没有报错，也没有出现上面回答中提到的结果。</p>\n<p>为什么会这样呢，首先想到的就是不同的数据库对这一点的实现方式不同，Oracle 数据库下会是这样的区别，其它数据库就不一定了。</p>\n<p>正好，电脑上装的有 SQL Server 2008，在 SQL Server 依次执行了一遍，也都成功了，没出现上面提到的问题。</p>\n<p>难道只有 Oracle 数据库里才有那样的区别，如果你电脑上刚好有 Oracle，可以帮我试一下。</p>\n<h1 id=\"再探求\"><a href=\"#再探求\" class=\"headerlink\" title=\"再探求\"></a>再探求</h1><p>难道唯一约束和唯一索引，在 MySQL 和 SQL Server 里真的一点区别都没有吗？</p>\n<p>用 Navicat 打开刚刚在 MySQL 数据库里建好的表，看下表定义</p>\n<p>表 t1 DDL</p>\n<p><img src=\"/images/%E7%BA%A6%E6%9D%9F%E7%B4%A2%E5%BC%95_7.jpg\"></p>\n<p>表 t2 DDL</p>\n<p><img src=\"/images/%E7%BA%A6%E6%9D%9F%E7%B4%A2%E5%BC%95_8.jpg\"></p>\n<p>表 t1 是直接在建表时对 col1 列定义唯一约束的，而表 t2 是建立完成后，通过修改表才对 col1 列建立唯一索引的。但是最终两个表的 DDL 完全一样，说明在 MySQL 数据库里唯一约束和唯一索引只是概念不同，在不同的功能中叫法不同罢了，其实现方式是完全一样的。</p>\n<p>再次用 Navicat 打开刚刚在 SQL Server 数据库里建好的表，看下表定义</p>\n<p>表 t1 DDL</p>\n<p><img src=\"/images/%E7%BA%A6%E6%9D%9F%E7%B4%A2%E5%BC%95_9.jpg\"></p>\n<p>表 t2 DDL</p>\n<p><img src=\"/images/%E7%BA%A6%E6%9D%9F%E7%B4%A2%E5%BC%95_10.jpg\"></p>\n<p>可以看出，和 MySQL 数据库不同，SQL Server 数据库下，表 t1 为 col1 列建立了唯一约束，表 t2 为 col1 列建立了唯一索引，但是表 t3 和 t4 也被成功建立了，可见最终的结果还是一样，也即没有证明上面那个回答。至于 SQL Server 下除此之外，还有没有其它的区别，在我搜索的答案中暂时还没发现，如果你发现了，欢迎回复交流。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>到此为止，基本上就能得出，唯一约束和唯一索引在 MySQL 数据库里区别了</p>\n<ol>\n<li>概念上不同，约束是为了保证数据的完整性，索引是为了辅助查询；</li>\n<li>创建唯一约束时，会自动的创建唯一索引；</li>\n<li>在理论上，不一样，在实际使用时，基本没有区别。</li>\n</ol>\n<p>关于第二条，MySQL 中唯一约束是通过唯一索引实现的，为了保证没有重复值，在插入新记录时会再检索一遍，怎样检索快，当然是建索引了，所以，在创建唯一约束的时候就创建了唯一索引。<br><br><br></p>\n","categories":["后端"],"tags":["MySQL","索引"]},{"title":"MySQL 中的数据类型和几个问题","url":"https://zhouxelf.com/2018/03/26/MySQL 中的数据类型和几个问题/","content":"<p>在 MySQL 中，可以通过存储引擎来决定表的类型，即存储引擎决定了表的存储方式；同时 MySQL 中也提供了几种数据类型，而数据类型决定了表存储数据的类型。在这篇文章里，先来简单的介绍 MySQL 中的数据类型。</p>\n<p>MySQL 支持多种数据类型，大致可以分为三类：数值、日期 \\ 时间、字符串（字符）</p>\n<h1 id=\"数值类型\"><a href=\"#数值类型\" class=\"headerlink\" title=\"数值类型\"></a>数值类型</h1><p>数值类型又分为整数类型、浮点数类型和定点数类型</p>\n<p><img src=\"/images/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_1.jpg\"></p>\n<h1 id=\"日期-时间类型\"><a href=\"#日期-时间类型\" class=\"headerlink\" title=\"日期 / 时间类型\"></a>日期 / 时间类型</h1><p><img src=\"/images/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_2.jpg\"></p>\n<h1 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a>字符串类型</h1><p><img src=\"/images/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_3.jpg\"></p>\n<h1 id=\"几个问题\"><a href=\"#几个问题\" class=\"headerlink\" title=\"几个问题\"></a>几个问题</h1><h2 id=\"int-10-与-int-11-的区别\"><a href=\"#int-10-与-int-11-的区别\" class=\"headerlink\" title=\"int(10) 与 int(11) 的区别\"></a>int(10) 与 int(11) 的区别</h2><p>int 占 4 个字节，存储的数据范围见上表，int 后面的数字表示字符显示宽度</p>\n<ol>\n<li>只要数据类型声明为 int，则该列所能存储的整型数据范围是固定的，不管后面的是 10 还是 11，int 的字符显示宽度大小，和能存储的数据范围大小没有关系；</li>\n<li>zerofill 表示数据小于字符显示宽度时，左边用 0 填充，直至达到定义的字符显示宽度；</li>\n<li>若数据宽度大于等于字符显示宽度时，则正常存储，不处理该数据；</li>\n<li>字符显示宽度必须和 zerofill 配合使用，不然字符显示宽度无意义；</li>\n<li>使用 zerofill 填充时，会隐式的将该列设置为无符号；</li>\n<li>不设置字符显示宽度和 zerofill 时，int 型默认字符显示宽度为 11。</li>\n</ol>\n<h2 id=\"float\"><a href=\"#float\" class=\"headerlink\" title=\"float\"></a>float</h2><p>float 存在许多潜在因素，要 <strong>尽量避免</strong> 使用</p>\n<ol>\n<li>默认只能存储 6 个数字（小数点前后），超过 6 位就会显示为科学记数法，并且 6 位之后的部分会四舍五入舍去；</li>\n<li>设置 float(m)，m &lt;= 24 时，精度和不设置 m 一样，都只能存储 6 个数字，m 超过 24 时，会自动转换为 double；</li>\n<li>设置 float(m,d)，m 表示整数和小数的最大长度，d 表示小数部分，m-d 表示整数部分，整数部分超过 m-d，插入异常，小数部分大于 d，则从第 5 位开始四舍五入去掉后面的部分，小数部分小于 d，用 0 填充，m = d 时，整数部分必须为 0；</li>\n<li>浮点数存在误差问题，对货币等对精度敏感的数据，应该使用定点数存储。</li>\n</ol>\n<h2 id=\"double-与-decimal-区别\"><a href=\"#double-与-decimal-区别\" class=\"headerlink\" title=\"double 与 decimal 区别\"></a>double 与 decimal 区别</h2><ol>\n<li>double 浮点型，decimal 定点型；</li>\n<li>double 不指定精度，默认按实际的精度显示；</li>\n<li>decimal 不指定精度，默认 m = 10，d = 0；</li>\n<li>decimal 可以存储比 bigint 更大的整数。</li>\n</ol>\n<h2 id=\"datetime-与-timestamp-区别\"><a href=\"#datetime-与-timestamp-区别\" class=\"headerlink\" title=\"datetime 与 timestamp 区别\"></a>datetime 与 timestamp 区别</h2><ol>\n<li>存储范围不同，datetime 范围更大；</li>\n<li>所占空间大小不同，timestamp 只占 4 字节；</li>\n<li>datetime 和时区无关，timestamp 和时区有关；</li>\n<li>timestamp 将时间从当前时区转化为 UTC 进行存储，查询时又转化为当前时区，datetime 原样存储； </li>\n<li>都可以设置默认值为 CURRENT_TIMESTAMP，在插入和更新时会自动使用当前时间填充；</li>\n<li>timestamp 可以指定长度，精度到毫秒级，datetime 不可以；</li>\n<li>对于跨时区的业务，timestamp 更适合。</li>\n</ol>\n<h2 id=\"char-4-与-varchar-4-区别\"><a href=\"#char-4-与-varchar-4-区别\" class=\"headerlink\" title=\"char(4) 与 varchar(4) 区别\"></a>char(4) 与 varchar(4) 区别</h2><ol>\n<li>能存储的最大字符数都是 4 个，超过自动截取，字符包括汉字、英文字母和数字；</li>\n<li>char 存储低于 4 个，依然占 4 个字节，varchar 存储低于 4 个，占字符数 + 1 个字节；</li>\n<li>varchar 存储的字符数小于等于 255 个时，用 1 个字节记录字符串长度，大于 255 个时，用 2 个字节记录字符串长度。</li>\n</ol>\n<h2 id=\"汉字占字节大小\"><a href=\"#汉字占字节大小\" class=\"headerlink\" title=\"汉字占字节大小\"></a>汉字占字节大小</h2><ol>\n<li>一般每个汉字 3 个字节；</li>\n<li>和编码有关。</li>\n</ol>\n<h2 id=\"其他类型\"><a href=\"#其他类型\" class=\"headerlink\" title=\"其他类型\"></a>其他类型</h2><p><strong>boolean 与 bool</strong> MySQL 中没有 boolean 类型，使用 0 和 1 代表 false 和 true，设置一列为 boolean 类型，将会自动转换成 tinyint(1)；</p>\n<p><strong>enum</strong> 枚举类型，从给定的几个值中挑选一个；</p>\n<p><strong>set</strong> 枚举类型，从给定的几个值中挑选一个或多个；</p>\n<p><strong>numeric</strong> 同 decimal 类型一样，没有任何区别。<br><br><br></p>\n","categories":["后端"],"tags":["MySQL","数据类型"]},{"title":"年少不听李宗盛 听懂已是不惑年","url":"https://zhouxelf.com/2018/02/03/年少不听李宗盛 听懂已是不惑年/","content":"<p><img src=\"/images/%E5%B9%B4%E5%B0%91%E4%B8%8D%E5%90%AC%E6%9D%8E%E5%AE%97%E7%9B%9B_1.jpg\"></p>\n<p>2008 年，李宗盛 50 岁。50 岁是个标志性的年龄，人生开始转暗，你不得不跟很多事情妥协，身体、老去、时代的发展。都说，年少不听李宗盛，听懂的时候，你也成了有故事的人。</p>\n<p>2006 年 5 月，李宗盛启动了《理性与感性作品音乐会》个人演唱会。没有绚丽的舞台，华丽的服装，只有真诚的歌声，周华健、张艾嘉、张信哲、梁静茹等纷纷助阵。他曾经说过一句狂话：不管你给我什么乱七八糟的人，给我什么歌手，只要到我李宗盛手上，我就会让他红！这是一句实话。</p>\n<p><img src=\"/images/%E5%B9%B4%E5%B0%91%E4%B8%8D%E5%90%AC%E6%9D%8E%E5%AE%97%E7%9B%9B_2.jpg\"></p>\n<p>在那个时代，李宗盛的好友赵传歌唱得很好，但因为样貌原因一直不被关注。于是，李宗盛为他量身创作了《我是一只小小鸟》、《我很丑，可是我很温柔》，两首歌写尽了那些平凡男性的心酸。赵传说，这两首歌自己唱的时候真的像发泄一样，完完全全说的心中事。虽然歌曲灵感来自赵传，但这些歌其实是写给那些富裕起来的，已经买得起车的中产阶级听的。</p>\n<p><img src=\"/images/%E5%B9%B4%E5%B0%91%E4%B8%8D%E5%90%AC%E6%9D%8E%E5%AE%97%E7%9B%9B_3.jpg\"></p>\n<p>天后梁静茹，最初只是个来自马来西亚的乡下妹，一个爱唱歌的小姑娘。在一次歌唱比赛中，她和同学组合拿了第三名，而当时只是和声。这场比赛被收录在滚石马来西亚分公司的一张 CD 中。后来李宗盛去马来西亚分公司选材，从堆积如山的 CD 中挑中了这张。</p>\n<p>当时主管推荐的是这个组合的主唱，但是李宗盛一摆手，说：不，让那个和声的姑娘来。</p>\n<p><img src=\"/images/%E5%B9%B4%E5%B0%91%E4%B8%8D%E5%90%AC%E6%9D%8E%E5%AE%97%E7%9B%9B_4.jpg\"></p>\n<p>就这样的一句话，在茫茫的 CD 中，小姑娘梁静茹被大哥挑出来。她进了滚石，被李宗盛认作干女儿。李宗盛为这块璞玉，连续制作了《一夜长大》、《勇气》和《美丽人生》三张专辑，把她送进天后的行列。在《理性与感性音乐会》上，梁静茹挑起大梁，《不必在乎我是谁》、《诱惑的街》、《为你我受冷风吹》，李宗盛说 Sandy 的每一首歌都不好唱，辛苦静茹了。梁静茹说，老豆在旁边看着，我压力好大呀，只能好好唱。</p>\n<p>一代歌后陈淑桦，李宗盛曾说：她是最会唱歌的人。《梦醒时分》、《滚滚红尘》、《问》、《笑红尘》都出自她的口，与李宗盛合作过专辑《女人心》，成为了李宗盛的知己。</p>\n<p>2006 年，李宗盛要开理性与感性音乐会的消息传出，歌手纷纷报名，张艾嘉、周华健、梁静茹、张信哲，甚至成龙都抢着要来当嘉宾。但李宗盛最想邀请的，是他的红颜知己陈淑桦。而当时的陈淑桦，正因深爱的母亲去世而患上自闭症，拒绝与外界的一切联络。</p>\n<p>面对这样的好友，李宗盛内心溢满伤痛，用尽一切办法鼓励她振作。演唱会上，梁静茹唱了陈淑桦的代表作《梦醒时分》，鞠躬退场，大荧幕上出现李宗盛写给陈淑桦的信：</p>\n<blockquote>\n<p>淑桦，一切还好吗<br>但愿你已从失去母亲的深切哀伤里平复过来<br>不管我们乐不乐意<br>随着岁月增长<br>我们都得渐渐的去看见<br>人生更完整的面貌<br>我们所有的获得或失去<br>恐怕都不是生命的本意<br>反而是经历一切之后<br>从而发现自己</p>\n<p>这些年少有机会见你<br>在办公室碰见也只是擦身而过匆匆来去<br>记得小小黑黑的臭臭的录音室吧<br>对，我还在那里<br>记得不厌其烦<br>一再要你重来的小李吧<br>是的，我还是坚持<br>我要的自有道理<br>我仍然在为每一首歌<br>每一个艺人<br>每一个案子尽力<br>在绚烂舞台，惑人声名之外<br>尽力完成自己</p>\n<p>好久不见，淑桦<br>你在台下看吗<br>看小李变成真正的老李拉<br>头发没了，胡子白了<br>人漂泊了，心沧桑了<br>却依然要大声唱歌<br>好像当年一样<br>没关系的<br>日子会顺顺的往下去的<br>我们会再见面，唱歌<br>就像当年一样</p>\n</blockquote>\n<p>然而一代歌后还是不能走出母亲去世的伤痛，再未重现江湖，在台北过着平静平凡人的生活。</p>\n<p><img src=\"/images/%E5%B9%B4%E5%B0%91%E4%B8%8D%E5%90%AC%E6%9D%8E%E5%AE%97%E7%9B%9B_5.jpg\"></p>\n<p>李宗盛最懂女人心，不然也写不出这么多情歌。林忆莲亲身体会说：李宗盛是个很可怕的人，好像能看穿所有女人的心事。那时，辛晓琪与相恋 11 年的男友结婚后又分手，正遭遇人生中最为痛苦的时期。</p>\n<p>李宗盛写了《领悟》，给辛晓琪唱。</p>\n<blockquote>\n<p>我以为我会哭<br>但是我没有<br>我只是怔怔望着你的脚步<br>给你我最后的祝福<br>这何尝不是一种领悟<br>让我把自己看清楚<br>虽然那无爱的痛苦<br>将日日夜夜<br>在我灵魂最深处<br>…</p>\n</blockquote>\n<p>其实这也是小李写给自己的歌。</p>\n<p>50 岁以后，李宗盛的作品不再量产化，制作的事情也很少管，基本上处于半隐退状态。李宗盛自己说：即使是情歌，它都关乎那个年代的人的喜怒哀乐。</p>\n<p>他的第一张专辑《生命中的精灵》，那时李宗盛 27 岁，这个多愁善感的年轻人从三藩市飞东京成田机场转机回家，哭了一路，就这样为了姑娘的一个眼神，写了一张专辑。</p>\n<p>这是李宗盛第一张专辑，也是很多人最喜欢的一张。专辑里的小李，有着高亢的甚至是带点憨气的声音，还稍显稚嫩的念白式唱腔，年轻人陷入恋爱的热情纯真，这样的歌声，是后来有了很多故事的李再也无法重现的了。</p>\n<p><img src=\"/images/%E5%B9%B4%E5%B0%91%E4%B8%8D%E5%90%AC%E6%9D%8E%E5%AE%97%E7%9B%9B_6.jpg\"></p>\n<p>原文链接：<a href=\"http://oldjimpacific.blogspot.co.uk/2017/01/blog-post_13.html\">年少不听李宗盛，听懂已是不惑年</a><br><br><br></p>\n","categories":["随笔"],"tags":["随笔"]},{"title":"CentOS 7 下解决服务器报 Redis server went away 的错误","url":"https://zhouxelf.com/2018/01/28/CentOS 7 下解决服务器报 Redis server went away 的错误/","content":"<p>这两天在学习 Redis，因为 Redis 在 Windows 上的表现并不好，而且线上环境基本上都是 Linux，所以选择在 CentOS 7 上跑跑例子。在安装完 Redis 的 PHP 客户端 phpredis ，测试连接时，碰到这个问题，特此记录。</p>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>开始在 Redis 上使用 redis-cli 跟着敲命令还没出现问题，后来需要使用 Redis 的 PHP 客户端 phpredis，在测试连接时，出现了问题。</p>\n<p>phpredis 是作为 PHP 的模块安装的，安装完以后，可以在 phpinfo 里看到，模块已经加载成功。</p>\n<p><img src=\"/images/phpredis_1.jpg\"></p>\n<p>打开 redis-server 服务，通过浏览器，使用下面的代码测试连接 Redis 时，死活连不上，打开 F12，点击 Network，报 500。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    <span class=\"comment\">// 连接本地的 Redis 服务</span></span><br><span class=\"line\">    <span class=\"variable\">$redis</span> = <span class=\"keyword\">new</span> Redis();</span><br><span class=\"line\">    <span class=\"variable\">$redis</span>-&gt;connect(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Connection to server sucessfully,&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 查看服务是否运行</span></span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&quot; Server is running: &quot;</span> . <span class=\"variable\">$redis</span>-&gt;ping();</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h1><h2 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h2><p>开始出现这个问题时，我最先想到是版本的问题，因为 PHP 是直接通过 yum 安装的，装完才发现是 5.4 的版本，比较老， 而 phpredis 是使用源码安装的最新版。猜测到可能是版本问题后，我把 PHP 5.4 及其所有的模块都卸载了，然后换源，安装上了 PHP 7.0，同时再次装上了 phpredis。通过浏览器访问测试代码时，依旧连不上，依旧 500，排除掉版本的问题，我已经不知道可能的原因了。</p>\n<p>说一下，我的电脑是 Windows + Ubuntu 的双系统，CentOS 7 是在 Windows 下通过 VMware 访问的。我想着在 Ubuntu 里试一下，重启，切换到 Ubuntu，装 phpredis，测试，直接就连接成功了。CentOS 7 里的问题没有解决，于是再次切换回来。</p>\n<p>不通过浏览器也能执行 PHP 文件，我试着在终端直接执行测试文件，也成功输出了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onnection to server sucessfully, Server is running: +PONG</span><br></pre></td></tr></table></figure>\n\n<p>直接执行可以输出，通过浏览器就不行，报的错误也是 500，基本能确定不是 PHP 和 phpredis 的问题，而是服务器的问题了。服务器的问题，可以查看日志，执行下面的命令可以查看服务器的错误日志。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;var&#x2F;log&#x2F;httpd&#x2F;error_log</span><br></pre></td></tr></table></figure>\n\n<p>执行后可以看到，测试文件报了 Redis 的错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PHP Fatal error:  Uncaught RedisException: Redis server went away in...</span><br></pre></td></tr></table></figure>\n\n<p>有了报错，直接搜索报错信息即可。</p>\n<h2 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h2><p>网上给出的结果：SELinux 的访问控制导致了这个错误，可以通过改变 SELinux 的运行模式或者禁用 SElinux 解决。</p>\n<p>执行下面的命令，找到 SELinux 的配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim &#x2F;etc&#x2F;selinux&#x2F;config</span><br></pre></td></tr></table></figure>\n\n<p>找到 SELINUX=enforcing 这一项，改为 SELINUX=disabled，如果还不行，执行下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;sbin&#x2F;setsebool httpd_can_network_connect&#x3D;1</span><br></pre></td></tr></table></figure>\n\n<p>即可解决问题。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这次碰到的问题，不是一个大问题，但是却耽误了一些时间。SELinux 之前听到过，只是知道它是一个类似防火墙的东西，没有去深究，这次碰上了。准备看一下 SELinux，却在知乎上看到了 <a href=\"https://www.zhihu.com/question/20559538\">Linux 下为何要关闭 SELinux？</a> 这个问题，我表示很气，不过还是打算了解一下。还有 Ubuntu 上为什么没出现这个问题，了解了一下，原来 CentOS、RedHat 等几个 Linux 发行版默认启用了 SELinux，而 Ubuntu 默认没有安装 SELinux。<br><br><br></p>\n","categories":["后端"],"tags":["环境搭建","Linux","PHP","Redis"]},{"title":"CentOS 7 下编译安装 Linux 4.14 内核","url":"https://zhouxelf.com/2018/01/22/CentOS 7 下编译安装 Linux 4.14 内核/","content":"<h1 id=\"编译之前\"><a href=\"#编译之前\" class=\"headerlink\" title=\"编译之前\"></a>编译之前</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>最近在学习 Linux，看到介绍内核，就想着自己编译一下内核，虽然不会搞硬件开发，不会写底层的东西，但还是想看一下编译的整个过程。想着就开始弄，没想到中间还是有很多坑的，尤其是编译之前，选择配置这一部分，配置项太多了，因为只是想看编译的整个过程，所以就没有深究每一个配置项。整个过程比较长，特此记录，避免以后再次踩坑。</p>\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p>开始之前，先介绍一下编译环境。直接在自己常用的 Linux 主机上编译，中间肯定会出现问题，最后可能导致系统崩溃，别不信，我已经吃过几次亏了，所以这次选择在虚拟机软件 VMware Workstation 上安装 Linux 虚拟机进行编译安装。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">虚拟机软件：VMware Workstation 14           </span><br><span class=\"line\">Liunx 发行版：CentOS 7 内置内核 linux 3.10.0</span><br><span class=\"line\">待编译内核：linux 4.14.14</span><br></pre></td></tr></table></figure>\n\n<p>开始编译之前，先把几项准备工作完成。</p>\n<ol>\n<li><p>去 Linux 内核官网 <a href=\"https://www.kernel.org/\">www.kernel.org</a> 下载 Linux 内核文件，选择稳定版（stable），文件名为 linux-4.14.14.tar.xz，去 CentOS 官网 <a href=\"https://www.centos.org/\">www.centos.org</a> 下载最新的 CentOS 7。</p>\n</li>\n<li><p>把 CentOS 在 VMware 里装好，安装过程不在赘述，网上一大堆。这里提醒一句，分给 CentOS 的硬盘空间不要太小，不然内核编译之后，空间可能不够。我第一次编译时，就是因为分的太小了，**/** 目录装完系统之后只剩 6G 多，编译一个多小时，提示空间不足，编译失败，最后不得不重装系统，又耽误了时间。</p>\n</li>\n<li><p>此外，做好宿主机和虚拟机之间文件夹的共享，保证虚拟机可以读取宿主机里下载好的 Linux 内核文件，挂载可以实现，这个不会可以搜一下。</p>\n</li>\n</ol>\n<p>准备工作完成，下面正式开始编译内核，请做好踩坑的准备。</p>\n<h1 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h1><p>开始之前呢，还要啰嗦几句，我先把安装的大致过程说一下，避免做到某一步时，只是在重复，却不知道在做什么。</p>\n<p>编译安装大致分为以下几步：</p>\n<ol>\n<li>解压内核</li>\n<li>编译前，选择配置项，生成 config 文件</li>\n<li>编译内核</li>\n<li>安装模块，安装内核</li>\n<li>更新引导文件</li>\n</ol>\n<h2 id=\"解压内核\"><a href=\"#解压内核\" class=\"headerlink\" title=\"解压内核\"></a>解压内核</h2><p>先把内核文件放在上面提到的宿主机和虚拟机之间的共享文件夹，我的宿主机共享文件夹是 share，挂载到了 CentOS 的 /mnt/hgfs/share/ 目录下。</p>\n<p>切换到 root 权限，将内核文件解压到指定目录，这个目录是没有限定的，哪个都行，这里放到了 /usr/src/ 目录下，这个也是 CentOS 内核所在的目录，后缀 .tar.xz 的文件可以使用下面的命令解压。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar xvJf linux-4.14.14.tar.xz -C &#x2F;usr&#x2F;src&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91_1.jpg\"></p>\n<p>内核解压之后，每个文件夹内包含的是什么代码，可以自行搜索了解一下。</p>\n<h2 id=\"配置项\"><a href=\"#配置项\" class=\"headerlink\" title=\"配置项\"></a>配置项</h2><p>重点来了，解压之后，编译之前要先生成 config 配置文件。这个文件是干什么的呢？它是编译时的必备文件，指明了所有的配置项，编译时就是根据你选择的配置项来定制内核的。在你的 CentOS 内同样有这样一个配置文件，在 /boot/ 目录下有一个 config 开头的文件，就是它，你可以先 cat 一下，会发现都是键值对，所有的配置项都在这。</p>\n<p>配置项非常多，可以随心所欲的定制内核，把不需要的全部关闭，当然也不是随心所欲，某些配置项是必须要选的，否则可能连系统也启动不了。</p>\n<p>选择配置项的方式有以下几种，当然它们的目的都是为了生成 config 文件，所以选择哪种都可以。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make config （基于文本的配置界面）</span><br><span class=\"line\">make menuconfig （基于文本菜单的配置界面）</span><br><span class=\"line\">make xconfig （基于图形窗口的配置界面）</span><br><span class=\"line\">make oldconfig （基于原来内核配置的基础上修改）</span><br></pre></td></tr></table></figure>\n\n<p>以上几种，make xconfig 最为友好，基于窗口操作，但是需要 Xwindow 的支持，CentOS 还好，若是使用其它没有图形界面的发行版就 GG 了。make menuconfig 相对比较友好，又是基于文本菜单，所有的发行版都可以使用，所以这里推荐使用 make menuconfig。</p>\n<p>使用 make menuconfig 需要 ncurses-devel 的支持，如果之前没装过，需要执行下面的命令安装一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install ncurses-devel</span><br></pre></td></tr></table></figure>\n\n<p>执行 make menuconfig，开始选择配置项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make menuconfig</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91_2.jpg\"></p>\n<p>如果执行没有错误的话，会出现下面这个页面</p>\n<p><img src=\"/images/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91_3.jpg\"></p>\n<p>Linux 内核所有的配置项都在这里，我第一次看到时，我去，这也太多了吧，这什么时候能看完。</p>\n<p>为了选择配置项，又开始搜配置项的意思，看了几个比较大的之后，比如基本配置、网络、文件系统等等，就没再看了。我开始是为了看整个编译过程，研究每一配置项，没有太大的意义，并且不同的 CPU 架构，所能配置的配置项也是不一样的。网上有人解释了每个配置项的意义，可能不是最新的内核，感兴趣的可以研究一下 <a href=\"http://www.jinbuguo.com/kernel/longterm-linux-kernel-options.html\">Linux 内核配置选项简介-金步国</a></p>\n<p>内核的编译分为两个部分，核心和模块，对于核心的部分，要编译进核心，可能以后会用到的部分，尽量编译成模块。</p>\n<p>文本菜单选择界面，使用左（←）、右（→）箭头切换底部菜单，上（↑）、下（↓）箭头切换中间的配置项，<strong>空格键</strong> 选择配置项，部分配置项右边有 <strong>—&gt;</strong> 标识，代表有下级子项，可以使用 <strong>Enter</strong> 进去选择。</p>\n<p>同时每一项的前面都有以下标识，可以根据需要选择。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;*&gt;[*]  表示编译进核心</span><br><span class=\"line\">&lt;M&gt;     表示编译成模块</span><br><span class=\"line\">空格    表示不选中此项</span><br></pre></td></tr></table></figure>\n\n<p>当然，如果你只是看一下整个编译过程，不想深究每一项，执行上一步 make menuconfig 之后，直接保存退出就可以了，它会使用 CentOS 内部的配置文件作为这次编译的配置文件，不知道 CentOS 内部配置文件在哪的，自己往前翻。</p>\n<p>保存退出之后的效果如下图</p>\n<p><img src=\"/images/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91_4.jpg\"></p>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><p>配置项选完，config 配置文件生成之后，就可以开始编译了，编译需要 elfutils-libelf-devel 的支持，先执行下面的命令安装一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install elfutils-libelf-devel</span><br></pre></td></tr></table></figure>\n\n<p>内核的编译，执行 make 即可开始编译。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n\n<p>若编译过程中提示 <em>致命错误：openssl/opensslv.h：没有那个文件或目录</em> ，请执行下面的命令安装一下依赖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install openssl-devel</span><br></pre></td></tr></table></figure>\n\n<p>编译时间比较长，如果上面你是自定义配置项，把不需要的配置都关闭，编译会快的多。我这使用的 CentOS 内部的配置文件，CentOS 为了大多数人的使用，开的配置项比较多，所以编译的时间比较长，当然，也和你的电脑配置有关。我记了一下时间，这一部分的编译用了两个半小时，所以请耐心等待，可以去喝个咖啡。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>经过了漫长的等待，终于编译完成，现在可以开始安装了。上面配置项有的编译进核心，有的编译成模块，所以安装也分为两个部分，模块安装和核心安装。</p>\n<p>执行 make modules_install 开始安装模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make modules_install</span><br></pre></td></tr></table></figure>\n\n<p>等待完成，执行 make install 开始安装核心</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n\n<p>执行完成之后，就可以在 /boot/ 目录下看到新编译的内核了。</p>\n<p><img src=\"/images/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91_5.jpg\"></p>\n<h2 id=\"更新引导\"><a href=\"#更新引导\" class=\"headerlink\" title=\"更新引导\"></a>更新引导</h2><p>到现在为止，离成功就差一步更新引导了。可以直接去修改 /boot/grub2/grub.cfg 文件来更新引导，但是非常不建议这样去做。</p>\n<p>推荐使用 grub2-mkconfig 来更新引导文件，下面的命令会根据 /boot/ 目录下的内核文件自动更新 grub 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grub2-mkconfig -o &#x2F;boot&#x2F;grub2&#x2F;grub.cfg</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91_6.jpg\"></p>\n<p>执行完之后，下次启动系统的时候就可以选择我们编译的内核了。如果想修改默认的启动内核，可以通过修改 /etc/default/grub 文件来实现。</p>\n<p>重启系统，如果看到两个内核，说明已经成功了，你可以自由的选择哪个内核。</p>\n<p><img src=\"/images/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91_7.jpg\"></p>\n<p>至此，内核的编译安装就全部结束了，整个过程中，如果出现什么问题，根据报错信息就可以解决了。最后再啰嗦几句，说说这次编译。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>用 Linux 系统也很久了，没去研究过内核，只是知道而已，就是突然心血来潮想要编译一下 Linux 内核，就去搞了，一个简单的编译，还是遇到了不少坑。首先，第一次编译时，CentOS 分区给的太小，导致内核编译了一个多小时后停了下来，一看，好嘛，空间已经用完了。马上删了虚拟机，又重装，这次分了 50G，应该不会出现这个问题了。选择配置项的时候，又研究了一上午，一直在看每个配置项什么意思，总是想把每一项弄明白，看了一部分后，感觉工作量太大了，而且背离了初衷，然后就不看了，直接跳过去了。后面的过程就比较快，一气呵成。比较不足的还是没有定义自己的配置项，把自己编译最大的好处隔过去了，以后需要了再去搞吧，编译应该能节省不少时间。来来回回整了两天，虽然东西不太多，我感觉还是有点意义的。<br><br><br></p>\n","categories":["后端"],"tags":["环境搭建","Linux"]},{"title":"计算机硬件概述","url":"https://zhouxelf.com/2018/01/20/计算机硬件概述/","content":"<p>作为一个计科软件方向的学生，计算机的硬件部分了解的不是太多，今天又看这一部分的内容，简单的做一个总结。</p>\n<h1 id=\"组成部分\"><a href=\"#组成部分\" class=\"headerlink\" title=\"组成部分\"></a>组成部分</h1><p>计算机的组成主要分为三部分</p>\n<p><strong>输入单元：</strong> 包括键盘、鼠标、扫描仪等；<br><strong>中央处理器（CPU）：</strong> 含有算术逻辑、控制、记忆等单元；<br><strong>输出单元：</strong> 包括屏幕、打印机等。</p>\n<p>计算机通过主板将主要组成部分连接在一起，主板上面最重要的是芯片组，芯片组通常又分为两个桥接器来控制各组件的通信，分别是：<strong>北桥</strong> 负责连接速度较快的 CPU 、内存与显卡等组件；<strong>南桥</strong> 负责连接速度较慢的周边接口，包括硬盘、USB 、网卡等。</p>\n<h1 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>中央处理器（CPU）是一个具有特定功能的芯片，里面含有微指令集。CPU 由两个部分构成，分别是算术逻辑单元和控制单元，CPU 计算所需要的数据从 <strong>内存</strong> 读取。</p>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><p>依据 CPU 内部的微指令集，可以把 CPU 分为两类，分别是 <strong>精简指令集（RISC）</strong> 和 <strong>复杂指令集（CISC）</strong>。目前使用范围最广的精简指令集 CPU 就是 ARM 了，几乎所有手机中的处理器都是 ARM 架构的。常见的复杂指令集 CPU 主要有 AMD、Intel 等 x86 架构的 CPU。</p>\n<h2 id=\"主频、外频与倍频\"><a href=\"#主频、外频与倍频\" class=\"headerlink\" title=\"主频、外频与倍频\"></a>主频、外频与倍频</h2><p><strong>主频：</strong> CPU 内核工作的时钟频率，我们经常说的指的就是主频；<br><strong>外频：</strong> 指的是 CPU 与外部组件进行数据传输/运算时的速度；<br><strong>倍频：</strong> CPU 内部用来加速工作性能的一个倍数，两者相乘才是 CPU 的主频。   </p>\n<p>除此之外，还有 <strong>前端总线</strong>、<strong>系统总线</strong></p>\n<p><strong>说明：</strong> 关于系统总线（Bus Speed）、前端总线（Front Side Bus，FSB）和外频，之前比较迷，去网上查，好嘛，更迷了。网上的内容，不是不能理解，而是太乱了，百度百科上说外频不能和前端总线的频率混淆，维基百科上说外频就是前端总线的频率，我表示呵呵。至于它们分别对此的解释，比如 CPU 架构的发展啊，单通道双通道啊等等，我就不再复制粘贴了，需要的可以自行搜索，只说一下我最后得出的结论。<strong>主频 = 系统总线 × 倍频</strong>，你没有看错，同时我们更多人知道的是后面这个公式 <em>主频 = 外频 × 倍频</em>，为了继续使用这个公式，现在你可以认为系统总线的频率就是外频。CPU-Z 是一款检测 CPU 的软件，通过它，你可能会更好的理解以上内容。下面是我的电脑实测图，红框内就是这一部分的数据。</p>\n<p><img src=\"/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%A6%82%E8%BF%B0.jpg\"></p>\n<p>Core Speed 是主频，Multiplier 是倍频系数，Bus Speed 是系统总线的频率，它是个定值，后两项的乘积就是主频。Rated FSB 是额定前端总线频率，我测的没有这一项，网上说是和新的 CPU 架构有关，具体的我也不清楚，谁知道的，望告知。</p>\n<h1 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h1><h2 id=\"DRAM\"><a href=\"#DRAM\" class=\"headerlink\" title=\"DRAM\"></a>DRAM</h2><p>个人计算机的内存主要组件为 <strong>动态随机访问内存（Dynamic Random Access Menmory，DRAM）</strong>，随机访问内存只有在通电时才能记录与使用，断电后数据就消失了。DRAM 根据技术的更新又分为好几代，使用比较广泛有 SDRAM 和 DDR SDRAM 两种。DDR SDRAM 是双倍数据传输速度（Double Data Rate），它可以在一次工作周期中进行两次数据的传递。现在使用的基本都是 DDR 了，而 DDR 也更新了好几代，现在最新的并可以买到的是 DDR4。</p>\n<h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><p>为了加快 CPU 的运行性能，都会 CPU 的内部集成缓存，现在的 CPU 一般会采用三级缓存。一级缓存都内置在 CPU 内部并与 CPU 同速运行，可以有效的提高 CPU 的运行效率。二级缓存，它是为了协调一级缓存和内存之间的速度。三级缓存是为读取二级缓存后未命中的数据设计的—种缓存，在拥有三级缓存的 CPU 中，只有约 5% 的数据需要从内存中调用，这进一步提高了 CPU 的效率。上图红框右面的 Cache 部分就是我的电脑的缓存。</p>\n<h1 id=\"显卡\"><a href=\"#显卡\" class=\"headerlink\" title=\"显卡\"></a>显卡</h1><p>显卡又称为 VGA（Video Graphics Array），它对于图形影像的显示扮演相当重要的角色。一般对于图形影像的显示重点在于分辨率和色彩深度，因为每个图像显示的颜色会占用内存，因此显卡上面会有一个内存的容量，称为显存。一些 3D 的运算早期是交给 CPU 去运行的，但是 CPU 并非完全针对这些 3D 来进行设计，而且 CPU 平时已经非常忙碌了。所以后来显卡厂商直接在显卡上面嵌入一个 3D 加速的芯片，称之为 GPU。</p>\n<p>除了 CPU、内存和显卡外，其他部分如硬盘等，不是核心部分，就不再啰嗦了。</p>\n<p><strong>说明：</strong> 该文章部分内容参考书籍《鸟哥的 Liunx 私房菜-基础学习篇》<br><br><br></p>\n","categories":["硬件"],"tags":["硬件"]},{"title":"Laravel 验证中的正则 regex","url":"https://zhouxelf.com/2017/12/09/Laravel 验证中的正则 regex/","content":"<p>Laravel 的验证功能非常强大，基本上常见的需求都有对应的验证规则，对于一些的特殊的验证需求，Laravel 也提供了正则验证。</p>\n<p>正则验证之前也用过一次，今天再次使用时，发现不行了，又看了一下官方文档，才知道问题出在哪，特此记录下来。</p>\n<p>官方文档：</p>\n<p><strong>regex:pattern</strong></p>\n<p>验证字段必须匹配给定正则表达式</p>\n<blockquote>\n<p>注：使用 regex 模式时，规则必须放在数组中，而不能使用管道分隔符，尤其是正则表达式中已经使用了管道符号时。</p>\n</blockquote>\n<p>之前使用正则验证，使用管道符 <strong>|</strong> 和其它规则分开，今天再次使用正则验证时，没有成功，使用时像下面这样：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rules</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        <span class=\"string\">&#x27;username&#x27;</span> =&gt; <span class=\"string\">&#x27;required|regex:/^[a-zA-Z0-9_-]&#123;4,16&#125;$/&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;month&#x27;</span> =&gt; <span class=\"string\">&#x27;required|regex:/^([1-9]|1[0-2])$/&#x27;</span>,</span><br><span class=\"line\">    ];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看了一下文档，使用正则验证时，规则必须放在数组中，改成下面这样就成功了：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rules</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        <span class=\"string\">&#x27;username&#x27;</span> =&gt; [</span><br><span class=\"line\">            <span class=\"string\">&#x27;required&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;regex:/^[a-zA-Z0-9_-]&#123;4,16&#125;$/&#x27;</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">        <span class=\"string\">&#x27;month&#x27;</span> =&gt; [</span><br><span class=\"line\">            <span class=\"string\">&#x27;required&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;regex:/^([1-9]|1[0-2])$/&#x27;</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">    ];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者这样：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rules</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        <span class=\"string\">&#x27;username&#x27;</span> =&gt; <span class=\"keyword\">array</span>(</span><br><span class=\"line\">            <span class=\"string\">&#x27;required&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;regex:/^[a-zA-Z0-9_-]&#123;4,16&#125;$/&#x27;</span></span><br><span class=\"line\">        ),</span><br><span class=\"line\">        <span class=\"string\">&#x27;month&#x27;</span> =&gt; <span class=\"keyword\">array</span>(</span><br><span class=\"line\">            <span class=\"string\">&#x27;required&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;regex:/^([1-9]|1[0-2])$/&#x27;</span></span><br><span class=\"line\">        ),</span><br><span class=\"line\">    ];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之前能够成功，应该是正则中没有使用管道符 **|**，对于第一个 username 的验证，没有使用管道符，不放在在数组中，也是可以验证的，第二个 month 的验证就必须放在数组中了。不过为了规范起见，使用正则验证时，还是要把验证规则放到数组中。<br><br><br></p>\n","categories":["后端"],"tags":["PHP","Laravel"]},{"title":"PHP 中 this self static 的区别","url":"https://zhouxelf.com/2017/11/27/PHP 中 this self static 的区别/","content":"<h1 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h1><p>最近在做软件工程的课程设计，碰到一个问题，去扒 Laravel 源码，又搜索一番，发现是对 self static 的理解不深，才出现了问题，所以记录下来，避免再次犯同样的错误。</p>\n<h1 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h1><h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><p>this 比较好理解，就是指向当前对象，用于访问当前对象的非静态变量和非静态方法，它是和对象相关的；</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"variable\">$name</span>;</span><br><span class=\"line\">                </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"keyword\">$this</span>-&gt;name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">                </span><br><span class=\"line\"><span class=\"variable\">$p</span> = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"variable\">$p2</span> = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"variable\">$p</span>-&gt;name = <span class=\"string\">&quot;小红&quot;</span>;</span><br><span class=\"line\"><span class=\"variable\">$p2</span>-&gt;name = <span class=\"string\">&quot;小明&quot;</span>;</span><br><span class=\"line\"><span class=\"variable\">$p</span>-&gt;getName();  <span class=\"comment\">// 小红</span></span><br><span class=\"line\"><span class=\"variable\">$p2</span>-&gt;getName();  <span class=\"comment\">// 小明</span></span><br></pre></td></tr></table></figure>\n\n<p>上例中 new 了两个对象，并分别设置对象的 name 属性，getName() 中使用了 this 访问当前对象的 name 属性，所以分别输出了 name 的值。所以说，this 就是指向当前对象，不指向其他对象或类。</p>\n<h2 id=\"self\"><a href=\"#self\" class=\"headerlink\" title=\"self\"></a>self</h2><p>self 和 this 不同，它指向类本身，不指向任何实例化对象，一般用来访问类中的静态变量和静态方法；</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"variable\">$name</span> = <span class=\"string\">&quot;小红&quot;</span>;</span><br><span class=\"line\">                     </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"built_in\">self</span>::<span class=\"variable\">$name</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">           </span><br><span class=\"line\"><span class=\"variable\">$p</span> = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"variable\">$p2</span> = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"variable\">$p</span>::getName();  <span class=\"comment\">// 小红</span></span><br><span class=\"line\"><span class=\"variable\">$p2</span>::getName();  <span class=\"comment\">// 小红</span></span><br><span class=\"line\"><span class=\"variable\">$p</span>::<span class=\"variable\">$name</span> = <span class=\"string\">&quot;小明&quot;</span>;</span><br><span class=\"line\"><span class=\"variable\">$p</span>::getName();  <span class=\"comment\">// 小明</span></span><br><span class=\"line\"><span class=\"variable\">$p2</span>::getName();  <span class=\"comment\">// 小明</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上例中 new 了两个对象，并修改了其中一个对象的 name 属性，另一个对象的 name 属性值也改变了，所以说，self 是指向当前类的，和对象无关，所有的对象共用一个值。</p>\n<h2 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h2><p>static 和 self 一样，都是指向类，一般都用来访问类中的静态变量和静态方法，但是又有一些不一样，具体来讲：self 写在哪个类里，实际调用的就是这个类；static 则是写在父类里，然后通过子类用到了这个 static，这个 static 指向的是这个子类，官方称之为 <strong>后期静态绑定</strong> 。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">saySelf</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">self</span>::say();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">          </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayStatic</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">static</span>::say();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;World&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">                 </span><br><span class=\"line\"><span class=\"variable\">$b</span> = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\"><span class=\"variable\">$b</span>-&gt;say();  <span class=\"comment\">// World</span></span><br><span class=\"line\"><span class=\"variable\">$b</span>-&gt;saySelf();  <span class=\"comment\">// Hello</span></span><br><span class=\"line\"><span class=\"variable\">$b</span>-&gt;sayStatic();  <span class=\"comment\">// World</span></span><br></pre></td></tr></table></figure>\n\n<p>上例中可以看到，self 写在 A 类里，调用时就指向了 A 类，static 同样写在 A 类里，但是用 A 类的子类 B 类的对象去调用时，却指向了 B 类，在使用时，static 才确定指向哪个类，这就是 <strong>后期静态绑定</strong> 。</p>\n<p><a href=\"http://php.net/manual/zh/language.oop5.late-static-bindings.php\">后期静态绑定</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>this 指向当前对象，用来访问当前对象的非静态变量和非静态方法；<br>self 指向类，一般用来访问当前类的静态变量和静态方法，运行之前已经确定指向哪个类；<br>static 指向类，一般用来访问当前类的静态变量和静态方法，但又 <strong>不限于</strong> 静态的调用，运行时才确定指向哪个类。<br><br><br></p>\n","categories":["后端"],"tags":["PHP"]},{"title":"Laravel5.5 + Vue2 + Element 环境搭建","url":"https://zhouxelf.com/2017/09/17/Laravel5.5 + Vue2 + Element 环境搭建/","content":"<h1 id=\"更新说明\"><a href=\"#更新说明\" class=\"headerlink\" title=\"更新说明\"></a>更新说明</h1><p><strong>2018 年 1 月 25 日更新</strong></p>\n<p>开始写这篇文章时，Element 的版本还是 1.4，现在已经来到 2.0 了，有些步骤需要修改，特此说明。</p>\n<h2 id=\"第-9-步，修改-Hello-vue-文件，使用-Element-组件-中\"><a href=\"#第-9-步，修改-Hello-vue-文件，使用-Element-组件-中\" class=\"headerlink\" title=\"第 9 步，修改 Hello.vue 文件，使用 Element 组件 中\"></a>第 9 步，<em>修改 Hello.vue 文件，使用 Element 组件</em> 中</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;el-dialog v-model&#x3D;&quot;visible&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>修改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;el-dialog :visible.sync&#x3D;&quot;visible&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第-8-步，引入-Element-中，使用命令\"><a href=\"#第-8-步，引入-Element-中，使用命令\" class=\"headerlink\" title=\"第 8 步，引入 Element 中，使用命令\"></a>第 8 步，<em>引入 Element</em> 中，使用命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i element-ui -S</span><br></pre></td></tr></table></figure>\n\n<p>默认安装的 Element 是 2.0 版本，2.0 版本的主题文件夹，由 theme-default 改为了 theme-chalk，所以下面 <em>修改 resources/assets/js/app.js 文件</em> 中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#39;element-ui&#x2F;lib&#x2F;theme-default&#x2F;index.css&#39;;</span><br></pre></td></tr></table></figure>\n\n<p>要改成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;;</span><br></pre></td></tr></table></figure>\n\n<p>当然，如果你想继续使用 1.4 版本的 Element 也是可以的，使用命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i element-ui@legacy -S</span><br></pre></td></tr></table></figure>\n\n<p>安装的即是 1.4 版，自然的，主题文件夹也不需要修改了。</p>\n<h1 id=\"搭建说明\"><a href=\"#搭建说明\" class=\"headerlink\" title=\"搭建说明\"></a>搭建说明</h1><p>同类的教程网上也有不少，本文不是为了重复造轮子，只是在 Laravel5.5 LTS 推出之际，重新记录自己的搭建过程，避免以后再次踩坑。</p>\n<p>网上的许多教程都是基于 Laravel5 系列的不同版本，虽然大致过程都差不多，但是对于前端编译工具不甚了解的人来说，官方推荐的前端编译工具的改变也着实容易让人迷糊。</p>\n<p>为了便于理解，本文初次搭建时，尽量简单，能运行即可，关于前端编译工具，Vue 路由等等，后面再说。</p>\n<p>本文全部代码，可以到 github 上获取： </p>\n<p><a href=\"https://github.com/mrzhouxiaofei/Larvuent\">https://github.com/mrzhouxiaofei/Larvuent</a></p>\n<h1 id=\"搭建过程\"><a href=\"#搭建过程\" class=\"headerlink\" title=\"搭建过程\"></a>搭建过程</h1><h2 id=\"1-新建-Laravel5-5-项目\"><a href=\"#1-新建-Laravel5-5-项目\" class=\"headerlink\" title=\"1.新建 Laravel5.5 项目\"></a>1.新建 Laravel5.5 项目</h2><p>在 Web 服务器目录下，使用 Composer 建立新项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer create-project --prefer-dist laravel&#x2F;laravel Larvuent &#x2F;&#x2F; 新项目名为 Larvuent</span><br></pre></td></tr></table></figure>\n\n<p>Larvuent 安装完成后，执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd Larvuent</span><br></pre></td></tr></table></figure>\n\n<p><strong>说明：建议配置虚拟主机</strong></p>\n<h2 id=\"2-安装前端依赖库\"><a href=\"#2-安装前端依赖库\" class=\"headerlink\" title=\"2.安装前端依赖库\"></a>2.安装前端依赖库</h2><p>进入 Larvuent 项目后，执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install &#x2F;&#x2F; 速度慢的请自行切换淘宝镜像 cnpm</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-修改-Laravel-路由\"><a href=\"#3-修改-Laravel-路由\" class=\"headerlink\" title=\"3.修改 Laravel 路由\"></a>3.修改 Laravel 路由</h2><p>修改 <strong>routes/web.php</strong> 文件为</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Route::get(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> view(<span class=\"string\">&#x27;index&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-新建-Hello-vue-文件\"><a href=\"#4-新建-Hello-vue-文件\" class=\"headerlink\" title=\"4.新建 Hello.vue 文件\"></a>4.新建 Hello.vue 文件</h2><p>在 <strong>resources/assets/js/components</strong> 目录下新建 Hello.vue 文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;Hello, Larvuent!&lt;/h1&gt;</span><br><span class=\"line\">        &lt;p <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;hello&quot;</span>&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">                             </span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">data</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            msg: <span class=\"string\">&#x27;This is a Laravel with Vue and Element Demo.&#x27;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">                           </span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.hello &#123;</span><br><span class=\"line\">    font-size: 2em;</span><br><span class=\"line\">    color: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-修改-app-js-文件，渲染组件\"><a href=\"#5-修改-app-js-文件，渲染组件\" class=\"headerlink\" title=\"5.修改 app.js 文件，渲染组件\"></a>5.修改 app.js 文件，渲染组件</h2><p>修改 <strong>resources/assets/js/app.js</strong> 文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./bootstrap&#x27;</span>);</span><br><span class=\"line\">       </span><br><span class=\"line\"><span class=\"built_in\">window</span>.Vue = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;vue&#x27;</span>);</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"comment\">// Vue.component(&#x27;example&#x27;, require(&#x27;./components/Example.vue&#x27;)); // 注释掉</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./components/Hello.vue&#x27;</span>; <span class=\"comment\">// 引入Hello 组件</span></span><br><span class=\"line\">       </span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(Hello)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>说明：app.js 是构建 Vue 项目的主文件，最后所有的组件都会被引入到这个文件，在引入所有组件之前，bootstrap.js 文件做了一些初始化的操作。同时，因为有了 window.Vue = require(‘vue’) 这句话，就不再需要使用 import Vue from ‘vue’ 重复导入 Vue 了。</strong></p>\n<h2 id=\"6-新建-Laravel-视图文件，和-Vue-交互\"><a href=\"#6-新建-Laravel-视图文件，和-Vue-交互\" class=\"headerlink\" title=\"6.新建 Laravel 视图文件，和 Vue 交互\"></a>6.新建 Laravel 视图文件，和 Vue 交互</h2><p>在 <strong>resources/views</strong> 目录下新建 index.blade.php 文件</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!doctype <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Larvuent<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">       </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;&#123;&#123; mix(&#x27;js/app.js&#x27;) &#125;&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>说明：你可能在其他教程中看到有的在使用 assets 函数，这两个函数的主要区别就是 assets 函数会直接使用所填路径去 public 文件夹下找文件，而 mix 函数会自动加载带 hash 值的前端资源。这是和 Laravel 前端资源的缓存刷新相关的，如果现在还不明白，不要紧，你记得使用 mix 函数就好了，然后继续往后看。</strong></p>\n<h2 id=\"7-编译前端组件，运行\"><a href=\"#7-编译前端组件，运行\" class=\"headerlink\" title=\"7.编译前端组件，运行\"></a>7.编译前端组件，运行</h2><p>执行以下命令，编译前端资源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run dev </span><br></pre></td></tr></table></figure>\n\n<p>该命令默认会去执行根目录下的 webpack.mix.js 文件，使用 Laravel 提供的 Laravel Mix 编译资源，并将编译好的资源放在根目录 public 文件夹下。 </p>\n<p><strong>说明：前端编译工具有许多，比如 gulp、webpack 等等，Laravel 也为自己提供了开箱即用的编译工具，比如 Laravel5.3 及更早版本提供基于 gulp 的 Laravel Elixir 和从 Laravel5.4 开始提供基于 webpack 的 Laravel Mix，当然你也可以不使用官方提供的工具，自己去配置编译工具。这些编译工具的作用都是一样的，使用方法也大同小异。前面说过，本文第一次安装尽量简单，能运行即可，所以不再去配置前端编译工具，使用官方提供的即可。</strong></p>\n<p>访问项目  </p>\n<p><img src=\"/images/Larvuent_5.jpg\"></p>\n<p>到目前为止，Laravel + Vue 已经完成了，下面开始引入 Element。</p>\n<h2 id=\"8-引入-Element\"><a href=\"#8-引入-Element\" class=\"headerlink\" title=\"8.引入 Element\"></a>8.引入 Element</h2><p>执行命令，安装 ElementUI</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i element-ui -S</span><br></pre></td></tr></table></figure>\n\n<p>修改 <strong>resources/assets/js/app.js</strong> 文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./components/Hello.vue&#x27;</span>; <span class=\"comment\">// 引入Hello 组件</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> ElementUI <span class=\"keyword\">from</span> <span class=\"string\">&#x27;element-ui&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;element-ui/lib/theme-default/index.css&#x27;</span>;</span><br><span class=\"line\">Vue.use(ElementUI);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-修改-Hello-vue-文件，使用-Element-组件\"><a href=\"#9-修改-Hello-vue-文件，使用-Element-组件\" class=\"headerlink\" title=\"9.修改 Hello.vue 文件，使用 Element 组件\"></a>9.修改 Hello.vue 文件，使用 Element 组件</h2><p>修改 <strong>resources/assets/js/components/Hello.vue</strong> 文件为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;Hello, Larvuent!&lt;/h1&gt;</span><br><span class=\"line\">        &lt;el-button @click=<span class=\"string\">&quot;visible = true&quot;</span>&gt;按钮&lt;/el-button&gt;</span><br><span class=\"line\">        &lt;el-dialog v-model=<span class=\"string\">&quot;visible&quot;</span>&gt;</span><br><span class=\"line\">            &lt;p&gt;欢迎使用 Element&lt;/p&gt;</span><br><span class=\"line\">        &lt;/el-dialog&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">data</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            visible: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.hello &#123;</span><br><span class=\"line\">    font-size: 2em;</span><br><span class=\"line\">    color: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-再次编译前端资源，运行\"><a href=\"#10-再次编译前端资源，运行\" class=\"headerlink\" title=\"10.再次编译前端资源，运行\"></a>10.再次编译前端资源，运行</h2><p>执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run dev </span><br></pre></td></tr></table></figure>\n\n<p>访问项目，点击按钮 </p>\n<p><img src=\"/images/Larvuent_2.jpg\"></p>\n<p>好了，到目前为止，Laravel5.5 + Vue2 + Element 的环境搭建已经完成了，为了方便理解，第一次的搭建过程尽量简洁。本文下面的部分将使用 Vue 路由等等，逐步完善，便于后期的开发。</p>\n<h1 id=\"完善\"><a href=\"#完善\" class=\"headerlink\" title=\"完善\"></a>完善</h1><h2 id=\"CSRF-防护\"><a href=\"#CSRF-防护\" class=\"headerlink\" title=\"CSRF 防护\"></a>CSRF 防护</h2><p>环境搭建完成后，访问项目，打开开发者模式，切换到 Console ，会看到以下报错</p>\n<p><img src=\"/images/Larvuent_3.jpg\"></p>\n<p>Laravel 为了避免应用遭到跨站请求伪造攻击(CSRF)，自动为每一个有效用户会话生成一个 CSRF 令牌，该令牌用于验证授权用户和发起请求者是否是同一个人。</p>\n<p>修改 <strong>resources/views/index.blade.php</strong> 文件为</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!doctype <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;csrf-token&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;&#123;&#123; csrf_token() &#125;&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Larvuent<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">       </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;&#123;&#123; mix(&#x27;js/app.js&#x27;) &#125;&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>创建一个 meta 标签并将令牌保存到该 meta 标签中，问题可解决。</p>\n<h2 id=\"使用-Vue-Router\"><a href=\"#使用-Vue-Router\" class=\"headerlink\" title=\"使用 Vue Router\"></a>使用 Vue Router</h2><p>构建大型项目时，使用 Vue Router 将是一个好的方式，它可以帮助你更好的组织代码，优化路由。</p>\n<h3 id=\"1-安装-vue-router\"><a href=\"#1-安装-vue-router\" class=\"headerlink\" title=\"1.安装 vue-router\"></a>1.安装 vue-router</h3><p>执行命令，安装 vue-router</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vue-router --save-dev</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-配置-vue-router\"><a href=\"#2-配置-vue-router\" class=\"headerlink\" title=\"2.配置 vue-router\"></a>2.配置 vue-router</h3><p>在 <strong>resources/assets/js</strong> 目录下新建目录 router ，同时在 router 目录下新建 index.js 文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> VueRouter <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue-router&#x27;</span>;</span><br><span class=\"line\">Vue.use(VueRouter);</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> VueRouter(&#123;</span><br><span class=\"line\">    saveScrollPosition: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&#x27;hello&#x27;</span>,</span><br><span class=\"line\">            path: <span class=\"string\">&#x27;/hello&#x27;</span>,</span><br><span class=\"line\">            component: <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"keyword\">void</span>(<span class=\"built_in\">require</span>([<span class=\"string\">&#x27;../components/Hello.vue&#x27;</span>], resolve))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-引入-vue-router\"><a href=\"#3-引入-vue-router\" class=\"headerlink\" title=\"3.引入 vue-router\"></a>3.引入 vue-router</h3><p>在 <strong>resources/assets/js</strong> 目录下新建 App.vue 文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;Hello, &#123;&#123; msg &#125;&#125;!&lt;/h1&gt;</span><br><span class=\"line\">        &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 路由引入的组件将在这里被渲染 --&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">     </span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">data</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            msg: <span class=\"string\">&#x27;Vue&#x27;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<p>修改 <strong>resources/assets/js/app.js</strong> 文件为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import Hello from &#x27;./components/Hello.vue&#x27;;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./App.vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ElementUI <span class=\"keyword\">from</span> <span class=\"string\">&#x27;element-ui&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;element-ui/lib/theme-default/index.css&#x27;</span>;</span><br><span class=\"line\">Vue.use(ElementUI);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./router/index.js&#x27;</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">    el: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    router,</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(App)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-重新编译\"><a href=\"#4-重新编译\" class=\"headerlink\" title=\"4.重新编译\"></a>4.重新编译</h3><p>执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run dev</span><br></pre></td></tr></table></figure>\n\n<p>通过路由访问 hello 组件   </p>\n<p><img src=\"/images/Larvuent_4.jpg\"></p>\n<p>以后如果要添加组件，只需在 resources/assets/js/components 目录下新建 vue 文件，在 resources/assets/js/router/index.js 文件里引入，然后就可以通过路由访问了。</p>\n<h2 id=\"代码拆分\"><a href=\"#代码拆分\" class=\"headerlink\" title=\"代码拆分\"></a>代码拆分</h2><p>代码拆分是将一些不经常变动的代码提取出来，以避免每次都要重新编译，如果你频繁更新应用的 JavaScript，需要考虑对 vendor 库进行提取和拆分，这样的话，一次修改应用代码不会影响 vendor.js 文件的缓存。</p>\n<p>Laravel Mix 的 extract 方法可以实现这样的功能：</p>\n<p>修改项目根目录下的 webpack.mix.js 文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mix.js(<span class=\"string\">&#x27;resources/assets/js/app.js&#x27;</span>, <span class=\"string\">&#x27;public/js&#x27;</span>)</span><br><span class=\"line\">   .sass(<span class=\"string\">&#x27;resources/assets/sass/app.scss&#x27;</span>, <span class=\"string\">&#x27;public/css&#x27;</span>)</span><br><span class=\"line\">   .extract([<span class=\"string\">&#x27;vue&#x27;</span>,<span class=\"string\">&#x27;axios&#x27;</span>]);</span><br></pre></td></tr></table></figure>\n\n<p>extract 方法接收包含所有库的数组或你想要提取到 vendor.js 文件的模块，使用上述代码作为示例，Mix 将会生成如下文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public&#x2F;js&#x2F;manifest.js  &#x2F;&#x2F; Webpack manifest runtime</span><br><span class=\"line\">public&#x2F;js&#x2F;vendor.js  &#x2F;&#x2F; vendor 库</span><br><span class=\"line\">public&#x2F;js&#x2F;app.js  &#x2F;&#x2F; 应用代码</span><br></pre></td></tr></table></figure>\n\n<p>同时修改 resources/views/index.blade.php 文件为</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!doctype <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;csrf-token&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;&#123;&#123; csrf_token() &#125;&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Larvuent<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;&#123;&#123; mix(&#x27;js/manifest.js&#x27;) &#125;&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;&#123;&#123; mix(&#x27;js/vendor.js&#x27;) &#125;&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;&#123;&#123; mix(&#x27;js/app.js&#x27;) &#125;&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>全局的 mix 函数会根据 public/mix-manifest.json 中的路径去加载对应的文件，同时也要注意引入三个 js 文件的顺序，以避免出错。</p>\n<p>重新执行命令，就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run dev</span><br></pre></td></tr></table></figure>\n\n<p>使用下面的命令，可以监视前端资源的改变，并自动编译。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run watch</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>到目前为止，这篇文章也快写完了，为了便于理解，本文第一次搭建时，尽量简单，能运行即可，成功之后，再添加其它功能。前端编译工具使用基于 webpack 的 Laravel Mix，一般情况下，它可以满足大部分的需求，当然你也可以完全抛弃 Laravel Mix，配置自己的 webpack，后期如果有需求，可以再写一篇相关的文章。</p>\n<p>本文全部代码，可以到 github 上获取： </p>\n<p><a href=\"https://github.com/mrzhouxiaofei/Larvuent\">https://github.com/mrzhouxiaofei/Larvuent</a></p>\n<p>如有疑问，欢迎回复交流。<br><br><br></p>\n","categories":["后端"],"tags":["环境搭建","PHP"]},{"title":"跨域问题解决方案之 JSONP","url":"https://zhouxelf.com/2017/08/09/跨域问题解决方案之 JSONP/","content":"<h2 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h2><p>由于浏览器同源策略的限制，为了保证安全，是不能执行其他网站的脚本的，通俗点来说，就是执行的 URL 不在你的网站下。跨域即绕过同源策略的限制，获取其他网站的数据。</p>\n<p>同源的定义：协议，域名，端口均相同。</p>\n<p>简单说明对 <a href=\"http://mrzhouxiaofei.com/test.js\">http://mrzhouxiaofei.com/test.js</a> 的同源检测情况：</p>\n<p><img src=\"/images/%E5%90%8C%E6%BA%90%E6%A3%80%E6%B5%8B.jpg\"></p>\n<h2 id=\"为什么跨域\"><a href=\"#为什么跨域\" class=\"headerlink\" title=\"为什么跨域\"></a>为什么跨域</h2><p>一般公司内部都会有许多不同的子域，举个例子，比如百度，假设 pan.baibu.com 需要获取用户的信息，就要去 user.baidu.com 下去获取，前者访问后者的数据就属于跨域，除此之外，引用其他网站的各种资源也属于跨域，总之，跨域的使用范围还是很广的。</p>\n<h2 id=\"怎么跨域\"><a href=\"#怎么跨域\" class=\"headerlink\" title=\"怎么跨域\"></a>怎么跨域</h2><p>跨域的方式有许多种，主要有 JSONP，CORS，以及通过 document.domain 来跨子域等等，感兴趣的可以了解一下其它几种跨域方式，本篇文章将主要介绍目前使用较多的 JSONP 方式。</p>\n<h2 id=\"JSON-和-JSONP\"><a href=\"#JSON-和-JSONP\" class=\"headerlink\" title=\"JSON 和 JSONP\"></a>JSON 和 JSONP</h2><p>介绍通过 JSONP 跨域之前，先理解 JSON 和 JSONP 这两个概念。</p>\n<p><strong>JSON</strong> 不用多解释，之前接触的也比较多，它是一种数据交换格式，在它出现之前，XML 曾一统天下，它出现之后，抢夺了 XML 的半壁江山，并且越来越流行。</p>\n<p>JSON 的优点：</p>\n<ol>\n<li>基于纯文本，跨平台传递极其简单；</li>\n<li>JavaScript 原生支持，后台语言几乎全部支持；</li>\n<li>轻量级数据格式，占用字符数量极少，特别适合互联网传递；</li>\n<li>可读性较强</li>\n</ol>\n<p><strong>JSONP</strong> （JSON with Padding）是数据格式 JSON 的一种“使用模式”，可以让网页从别的网域要数据，也即跨域获取数据。简单来说，JSONP 就是一种开发人员创造出的非官方跨域数据交互协议。学过计算机网络的同学，应该比较容易理解什么是协议。</p>\n<h2 id=\"通过-JSONP-跨域\"><a href=\"#通过-JSONP-跨域\" class=\"headerlink\" title=\"通过 JSONP 跨域\"></a>通过 JSONP 跨域</h2><h3 id=\"JSONP-的产生\"><a href=\"#JSONP-的产生\" class=\"headerlink\" title=\"JSONP 的产生\"></a>JSONP 的产生</h3><p>我们知道，通过 ajax 请求文件存在跨域无权访问时，无论你是什么网页，一律不被允许，不过我们一定有过这种情况：</p>\n<ol>\n<li>通过 script 标签引入过域外文件，比如引入百度的 JQuery；</li>\n<li>通过 img 标签引入过于在线的图片；</li>\n</ol>\n<p>通过以上两种情况，我们发现 Web 页面上调用 Js 文件或引用图片是不受跨域影响的，进一步发现，凡是拥有 src 这个属性的标签，都拥有跨域的能力。</p>\n<p>这样以来服务器把客户端需要的数据封装成包含 JSON 的 Js 文件 ，客户端就可以通过 script 标签，调用服务器动态生成的 Js 文件，来实现跨域获取数据了。</p>\n<p>客服端获取数据后，就可以对数据经行处理了，这看起来非常 ajax，但其实并不一样。</p>\n<p>为了便于客户端使用数据，逐渐形成了一种非正式的传输协议，这种协议就是 JSONP，该协议的一个特点就是允许用户传递一个 callback 参数给服务器，然后服务器返回数据时会将这个 callback 参数作为函数名来包裹住 JSON 数据，这样客户端就可以随意定制自己的函数来自动处理返回的数据了。</p>\n<h3 id=\"JSONP-的实现\"><a href=\"#JSONP-的实现\" class=\"headerlink\" title=\"JSONP 的实现\"></a>JSONP 的实现</h3><p>1.假设远程服务器 mrzhouxiaofei.com 根目录下有这样一个文件 test.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(<span class=\"string\">&quot;我是远程数据&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>本地服务器 localhost 下有个 index.html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;http://mrzhouxiaofei.com/test.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>毫无疑问，页面弹出一个提示框，显示跨域调用成功。</p>\n<p>2.假设远程服务器 mrzhouxiaofei.com 根目录下有这样一个文件 test.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething(&#123;<span class=\"string\">&quot;info&quot;</span>: <span class=\"string\">&quot;我是远程数据&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>本地服务器 localhost 下有个 jsonp.html 页面，其中定义了一个函数，然后在远程 test.js 中传入数据进行调用</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      alert(<span class=\"string\">&quot;远程数据：&quot;</span> + data.info)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;http://mrzhouxiaofei.com/test.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行之后，页面弹出提示窗口，并且跨域获取了远程的数据，但是怎么让服务器知道它应该调用哪个客户端的函数呢？</p>\n<p>3.这次先写本地服务器 localhost 下的 jsonp.html 的代码，代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      alert(<span class=\"string\">&quot;远程数据：&quot;</span> + data.info)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;script&#x27;</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">    script.src = <span class=\"string\">&quot;http://mrzhouxiaofei.com/test.js?callback=doSomething&quot;</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">&#x27;body&#x27;</span>)[<span class=\"number\">0</span>].appendChild(script)</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这次的代码不再写死，而是实现了动态查询，而这正是 JSONP 实现的核心部分，通过代码，可以看到，客户端调用的 URL，传入了一个 callback 参数，告诉服务器我的本地函数为 doSomething，这时服务器就会把客户端需要的数据传入到这个函数内，供客户端的调用，这样就完成了一次请求过程。</p>\n<p>远程服务器将要返回的数据如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething(&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;id&quot;</span>: <span class=\"number\">1001</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;info&quot;</span>: <span class=\"string\">&quot;我是远程数据&quot;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>到此为止，客户端就能跨域获取数据了，另外一点，<strong>JSONP 只能发送 GET 请求，不能发送 POST 请求</strong>。</p>\n<p><strong>说明：</strong>该文章部分内容参考 <a href=\"http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html\">【原创】说说JSON和JSONP，也许你会豁然开朗，含jQuery用例</a> ,看不懂的，可以看看这篇文章。<br><br><br></p>\n","categories":["前端"],"tags":["JavaScript","跨域","JSONP"]},{"title":"摔跤吧 爸爸","url":"https://zhouxelf.com/2017/07/17/摔跤吧 爸爸/","content":"<p><img src=\"/images/%E6%91%94%E8%B7%A4%E5%90%A7%E7%88%B8%E7%88%B8.jpg\"></p>\n<p>今天下午，小组组织观看了印度电影《摔跤吧 爸爸》，之后进行了亲切而友好的讨论，花了一整个下午的时间，收获颇丰。</p>\n<p>电影讲述了一个全国摔跤冠军，为生活所迫，放弃运动生涯，转而希望培养自己的儿子，无奈生了四个女儿，偶然间发现两个女儿拥有摔跤天赋，继而培养自己的两个女儿成为女子摔跤冠军，打破印度传统的励志故事。这个电影属于那种你看了开头就基本能猜到结局的电影，然而却能做到全程无尿点，让你痴迷于演员的演技，实属不易。</p>\n<p>看完整部电影，给我留下深刻印象的莫过于电影中的音乐了，尽管语言不通，但是适时响起的音乐，还是让我产生了共鸣。在我的印象中，经典的电影不仅仅是故事好，演员演技棒，而且音乐也一定很不错，这部电影满足了我对经典的要求。</p>\n<p>电影中的父亲，梦想着有一天能获得世界摔跤冠军，为印度赢得一块金牌，后来经历一系列的事，转而开始培养自己的两个女儿。在印度那样一个女人露腿都会被人议论纷纷的社会中，可想而知，父亲和两个女儿受到的阻力是巨大的。然而父亲坚定的信念，对金牌的执著，以及两个女儿在听到女伴结婚时说的话之后的顿悟，都是对冲破阻力最大的帮助。在经历一番之后，最终，两个女儿都获得了世界摔跤冠军。</p>\n<p>电影中的父亲为什么对金牌有那么深的执念？其实了解一下印度就知道了，印度一直要成为一个大国，而且随着近年来的高速发展，确实也取得了重大的成就，在一些重要的场合也有了一定的话语权。可是，一到大型的国际运动赛事，印度人就集体消失了，这对于一个大国来说，恐怕是不合适的。曾经我们也是这样，还记得李宁“兵败汉城”之后，甚至有人直接给他寄刀子。我们经过数十年的发展，甚至直到 2008 年奥运会之后，才不再唯金牌论，而是开始关注运动员本身。这样才会有傅园慧，宁泽涛，尽管没有在奥运会上获得金牌，却依然受到大家的喜爱的运动员。对于印度来说，想要度过这样一个阶段，恐怕还需要一些时间。</p>\n<p>电影上映之后，票房尚好，口碑也很不错，然而却有一些不同的声音。比如批评父亲的专权，批评父亲为了让女儿实现自己的梦想，强迫她们做自己不喜欢的事，没有让她们选择自己的未来。其实我们这样说是不合适的，你没有站在那样一个社会中，只是靠了解和倾听，是永远也感受不到的。讲个真事，有一个人早年间逃荒到了黑龙江一个偏远的山村，后来生了七个女儿一个儿子，这个人懂得一点文化，知道知识的重要。于是逼迫孩子们读书，孩子们不听话时，甚至不惜体罚，后来孩子们都考上了大学，离开了山村。女儿们后来谈起父亲，依然会说父亲残忍，专权，不给她们自由，可是却没有一个人埋怨父亲。讲这个例子，可能不太合适，毕竟逼迫孩子们读书和逼迫女儿去练摔跤是不能相提并论的。但是在电影中却是最合适的，首先两个女儿并没有一个明确的目标，如果不是父亲的干预，可能上几年学，然后在十四岁的时候嫁给一个素未谋面的男人；其次他们的父亲曾经是全国摔跤冠军，这是一个极大的资源，父亲有着丰富的经验，能给她们最合适的指导。如果说父亲只是为实现自己的梦想，把女儿当作实现梦想的工具，那么在女儿不听话时，就应该会有体罚的桥段。在电影中，完全没有这样的情节，甚至最生气的一次，女儿去参加别人的婚礼，也只是打了大侄子一巴掌。最重要的是，父亲也定了一年之约，如果一年后，女儿们还没爱上摔跤，就永远放弃。由此可见，父亲是深深的爱着女儿，并尊重她们的选择，所谓专权，是不成立的。</p>\n<p>电影之外：饰演父亲的阿米尔 汗，是印度国宝级演员，不仅主演了多部经典的电影，而且一直致力于公益等社会事业，印度有他，国之甚兴。<br><br><br>    </p>\n","categories":["随笔"],"tags":["影评"]},{"title":"JavaScript 中的数组函数","url":"https://zhouxelf.com/2017/06/10/JavaScript 中的数组函数/","content":"<p><em>JavaScript 中也有很多数组函数：</em></p>\n<p>indexOf()<br>搜索一个指定的元素的位置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&#x27;java&#x27;</span>,<span class=\"string\">&#x27;php&#x27;</span>,<span class=\"string\">&#x27;js&#x27;</span>];</span><br><span class=\"line\">alert(a.indexOf(<span class=\"string\">&#x27;php&#x27;</span>)); <span class=\"comment\">// 返回 1</span></span><br></pre></td></tr></table></figure>\n\n<p>slice()<br>截取数组的部分元素，返回一个新数组<br>该函数类似字符串函数中的 slice()</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&#x27;java&#x27;</span>,<span class=\"string\">&#x27;php&#x27;</span>,<span class=\"string\">&#x27;js&#x27;</span>];</span><br><span class=\"line\">alert(a.slice(<span class=\"number\">1</span>,<span class=\"number\">2</span>)); <span class=\"comment\">// 返回 php</span></span><br></pre></td></tr></table></figure>\n\n<p>push() pop()<br>向数组末尾添加一个或多个元素，删除数组最后一个元素</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&#x27;java&#x27;</span>,<span class=\"string\">&#x27;php&#x27;</span>];</span><br><span class=\"line\">alert(a.push(<span class=\"string\">&#x27;js&#x27;</span>)); <span class=\"comment\">// 返回 3</span></span><br><span class=\"line\">alert(a.pop()); <span class=\"comment\">//返回 js</span></span><br></pre></td></tr></table></figure>\n\n<p>unshift() shift()<br>向数组头部添加一个或多个元素，删除并返回第一个元素</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&#x27;java&#x27;</span>,<span class=\"string\">&#x27;php&#x27;</span>];</span><br><span class=\"line\">alert(a.unshift(<span class=\"string\">&#x27;js&#x27;</span>)); <span class=\"comment\">// 返回 3</span></span><br><span class=\"line\">alert(a.shift()); <span class=\"comment\">//返回 js</span></span><br></pre></td></tr></table></figure>\n\n<p>sort()<br>对数组的元素进行排序</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&#x27;mysql&#x27;</span>,<span class=\"string\">&#x27;php&#x27;</span>,<span class=\"string\">&#x27;js&#x27;</span>];</span><br><span class=\"line\">alert(a.sort()); <span class=\"comment\">// 返回 js,mysql,php</span></span><br></pre></td></tr></table></figure>\n\n<p>reverse()<br>颠倒数组中的元素</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&#x27;java&#x27;</span>,<span class=\"string\">&#x27;php&#x27;</span>,<span class=\"string\">&#x27;js&#x27;</span>];</span><br><span class=\"line\">alert(a.reverse()); <span class=\"comment\">// 返回 js,php,java</span></span><br></pre></td></tr></table></figure>\n\n<p>splice()<br>从指定的索引开始删除若干元素，然后再从该位置添加若干元素</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&#x27;java&#x27;</span>,<span class=\"string\">&#x27;php&#x27;</span>,<span class=\"string\">&#x27;js&#x27;</span>];</span><br><span class=\"line\">a.splice(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"string\">&#x27;mysql&#x27;</span>); </span><br><span class=\"line\">alert(a); <span class=\"comment\">// 返回 java,mysql,php,js</span></span><br></pre></td></tr></table></figure>\n\n<p>concat()<br>连接两个或多个数组，返回新数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\">alert(a.concat(b)); <span class=\"comment\">//返回 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>\n\n<p>join()<br>将数组中每个元素都用指定的字符串连接起来，返回新字符串</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">&#x27;java&#x27;</span>,<span class=\"string\">&#x27;php&#x27;</span>,<span class=\"string\">&#x27;js&#x27;</span>];</span><br><span class=\"line\">alert(a.join(<span class=\"string\">&quot;-&quot;</span>)); <span class=\"comment\">//返回 java-php-js</span></span><br></pre></td></tr></table></figure>\n<p><br><br></p>\n","categories":["前端"],"tags":["JavaScript"]},{"title":"JavaScript 中常用的字符串函数","url":"https://zhouxelf.com/2017/06/03/JavaScript 中常用的字符串函数/","content":"<p><em>JavaScript 中有很多字符串函数，其中一些较常用的总结如下：</em></p>\n<p>toUpperCase()<br>把一个字符串全部转换为大写</p>\n<p>toLowerCase()<br>把一个字符串全部转换为小写</p>\n<p>charAt(index)<br>返回指定位置的字符<br>Js 没有字符数据类型，即 char 类型，所以返回的字符是长度为 1 的字符串</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;Hello,world&#x27;</span>;</span><br><span class=\"line\">alert(a.charAt(<span class=\"number\">0</span>));  <span class=\"comment\">//返回 H</span></span><br></pre></td></tr></table></figure>\n\n<p>concat()<br>用于连接两个或多个字符串<br>通常使用 “+” 运算符会更简便一些</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;Hello&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">&#x27;,&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">&#x27;world&#x27;</span></span><br><span class=\"line\">alert(a.concat(b,c)); <span class=\"comment\">//返回 Hello,world</span></span><br></pre></td></tr></table></figure>\n\n<p>indexOf()<br>返回某个指定的字符串值在字符串中首次出现的位置<br>若未找到，返回 -1</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;Hello,world&#x27;</span>;</span><br><span class=\"line\">alert(a.indexOf(<span class=\"string\">&#x27;l&#x27;</span>)); <span class=\"comment\">//返回 2</span></span><br></pre></td></tr></table></figure>\n\n<p>match()<br>可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;Hello,world&#x27;</span>;</span><br><span class=\"line\">alert(a.match(<span class=\"string\">&#x27;world&#x27;</span>)); <span class=\"comment\">//返回 world</span></span><br><span class=\"line\">alert(a.match(<span class=\"string\">&#x27;WORLD&#x27;</span>)); <span class=\"comment\">//返回 null</span></span><br></pre></td></tr></table></figure>\n\n<p>replace()<br>用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串<br>该函数功能强大</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;Hello,world&#x27;</span>;</span><br><span class=\"line\">alert(a.replace(<span class=\"regexp\">/world/</span>,<span class=\"string\">&#x27;JavaScript&#x27;</span>)); <span class=\"comment\">//返回 Hello,JavaScript</span></span><br></pre></td></tr></table></figure>\n\n<p>search()<br>用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;Hello,world&#x27;</span>;</span><br><span class=\"line\">alert(a.search(<span class=\"regexp\">/world/</span>)); <span class=\"comment\">//返回 6</span></span><br><span class=\"line\">alert(a.search(<span class=\"regexp\">/WORLD/</span>)); <span class=\"comment\">//返回 -1</span></span><br><span class=\"line\">alert(a.search(<span class=\"regexp\">/WORLD/i</span>)); <span class=\"comment\">//返回 6</span></span><br></pre></td></tr></table></figure>\n\n<p>split()<br>用于把一个字符串分割成字符串数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;Hello&#x27;</span>;</span><br><span class=\"line\">alert(a.split(<span class=\"string\">&quot;&quot;</span>));  <span class=\"comment\">//返回 H,e,l,l,o</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三个分割字符串函数\"><a href=\"#三个分割字符串函数\" class=\"headerlink\" title=\"三个分割字符串函数\"></a>三个分割字符串函数</h3><p>slice()<br>提取字符串的某个部分，并以新的字符串返回被提取的部分</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;Hello,world&#x27;</span>;</span><br><span class=\"line\">alert(a.slice(<span class=\"number\">6</span>)); <span class=\"comment\">//返回 world</span></span><br><span class=\"line\">alert(a.slice(<span class=\"number\">6</span>,<span class=\"number\">10</span>)); <span class=\"comment\">//返回 worl</span></span><br></pre></td></tr></table></figure>\n\n<p>substring()<br>用于提取字符串中介于两个指定下标之间的字符<br>该函数不接受负的参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;Hello,world&#x27;</span>;</span><br><span class=\"line\">alert(a.substring(<span class=\"number\">6</span>)); <span class=\"comment\">//返回 world</span></span><br><span class=\"line\">alert(a.substring(<span class=\"number\">6</span>,<span class=\"number\">10</span>)); <span class=\"comment\">//返回 worl</span></span><br></pre></td></tr></table></figure>\n\n<p>substr()<br>可在字符串中抽取从 start 下标开始的指定数目的字符<br>ECMAscript 没有对该方法进行标准化，因此反对使用它</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;Hello,world&#x27;</span>;</span><br><span class=\"line\">alert(a.substr(<span class=\"number\">6</span>,<span class=\"number\">5</span>)); <span class=\"comment\">//返回 world</span></span><br></pre></td></tr></table></figure>\n\n<p>slice()、substring() 和 substr() （不建议使用）都可返回字符串的指定部分。slice() 比 substring() 要灵活一些，因为它允许使用负数作为参数。slice() 与 substr() 有所不同，因为它用两个字符的位置来指定子串，而 substr() 则用字符位置和长度来指定子串。<br><br><br></p>\n","categories":["前端"],"tags":["JavaScript"]},{"title":"PHP 实现邮件发送(PHPMailer+QQ邮箱)","url":"https://zhouxelf.com/2017/03/13/PHP 实现邮件发送(PHPMailer+QQ邮箱)/","content":"<p>最近复习原生 PHP，看到邮件函数这一部分，就试着写一下邮件功能，在网上搜了一下，主要有两种实现方式：</p>\n<ol>\n<li>PHP 自带的 mail() 函数</li>\n<li>封装的 smtp 邮件发送类</li>\n</ol>\n<p>下面来一一介绍</p>\n<h2 id=\"PHP-自带的-mail-函数\"><a href=\"#PHP-自带的-mail-函数\" class=\"headerlink\" title=\"PHP 自带的 mail() 函数\"></a>PHP 自带的 mail() 函数</h2><p>浏览一下 PHP 文档，mail() 函数的注释如下：</p>\n<p><img src=\"/images/PHPMailer_1.png\"></p>\n<p>即若要使用 mail() 函数，需要本地安装一个邮件系统或者必须设置一台不需要中继的邮件发送服务器，但现在要找到一台不需要身份验证的邮件发送中继几乎不可能，所以使用 mail() 函数往往无法成功发送电子邮件，对使用邮件系统感兴趣的，可以自己研究。而使用封装的smtp邮件发送类来实现，则要方便的多。</p>\n<h2 id=\"封装的-smtp-邮件发送类\"><a href=\"#封装的-smtp-邮件发送类\" class=\"headerlink\" title=\"封装的 smtp 邮件发送类\"></a>封装的 smtp 邮件发送类</h2><p>封装的smtp邮件发送类，网上可以找到很多，其中开源的 PHPMailer 是其中比较流行的一个，只需简单配置，即可使用，想了解更多，请移步 <a href=\"http://baike.baidu.com/link?url=gK7jI0Z90YK7TgX-dbAtjva9_5K3J119D2Q2T8zfZY24AC1Q5oWduRHzTPwJiPV7SEQ3MCFtURg4GXb-Dzh8rdit8iiawGyIR9fK8tNCxZ_\">PHPMailer</a> PHPMailer开源地址:<a href=\"https://github.com/PHPMailer/PHPMailer\">https://github.com/PHPMailer/PHPMailer</a></p>\n<p>可以直接把项目 clone 下来，或者下载 zip 压缩文件，在配置之前，需要开启邮箱的 smtp 功能，这里以 QQ 邮箱为例：</p>\n<p>登录 QQ 邮箱，点击<strong>设置</strong></p>\n<p><img src=\"/images/PHPMailer_2.png\"></p>\n<p><strong>账户</strong></p>\n<p><img src=\"/images/PHPMailer_3.png\"></p>\n<p>拉到最后，找到</p>\n<p><img src=\"/images/PHPMailer_4.png\"></p>\n<p>根据提示，开启前两项服务，然后生成授权码，记下来，之后配置会用</p>\n<p><img src=\"/images/PHPMailer_5.png\"></p>\n<p>clone 下来的 PHPMailer 项目的 README 文件提供了一个简单的引入例子<br><strong>A Simple Example</strong></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;PHPMailerAutoload.php&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable\">$mail</span> = <span class=\"keyword\">new</span> PHPMailer;</span><br><span class=\"line\"><span class=\"comment\">//$mail-&gt;SMTPDebug = 3;  // Enable verbose debug output</span></span><br><span class=\"line\">              </span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;isSMTP();  <span class=\"comment\">// Set mailer to use SMTP</span></span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;Host = <span class=\"string\">&#x27;smtp1.example.com;smtp2.example.com&#x27;</span>;  <span class=\"comment\">// Specify main and backup SMTP servers</span></span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;SMTPAuth = <span class=\"literal\">true</span>;   <span class=\"comment\">// Enable SMTP authentication</span></span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;Username = <span class=\"string\">&#x27;user@example.com&#x27;</span>;  <span class=\"comment\">// SMTP username</span></span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;Password = <span class=\"string\">&#x27;secret&#x27;</span>;  <span class=\"comment\">// SMTP password</span></span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;SMTPSecure = <span class=\"string\">&#x27;tls&#x27;</span>;  <span class=\"comment\">// Enable TLS encryption, `ssl` also accepted</span></span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;Port = <span class=\"number\">587</span>;  <span class=\"comment\">// TCP port to connect to</span></span><br><span class=\"line\">                 </span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;setFrom(<span class=\"string\">&#x27;from@example.com&#x27;</span>, <span class=\"string\">&#x27;Mailer&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;addAddress(<span class=\"string\">&#x27;joe@example.net&#x27;</span>, <span class=\"string\">&#x27;Joe User&#x27;</span>);  <span class=\"comment\">// Add a recipient</span></span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;addAddress(<span class=\"string\">&#x27;ellen@example.com&#x27;</span>);  <span class=\"comment\">// Name is optional</span></span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;addReplyTo(<span class=\"string\">&#x27;info@example.com&#x27;</span>, <span class=\"string\">&#x27;Information&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;addCC(<span class=\"string\">&#x27;cc@example.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;addBCC(<span class=\"string\">&#x27;bcc@example.com&#x27;</span>);</span><br><span class=\"line\">                        </span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;addAttachment(<span class=\"string\">&#x27;/var/tmp/file.tar.gz&#x27;</span>);  <span class=\"comment\">// Add attachments</span></span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;addAttachment(<span class=\"string\">&#x27;/tmp/image.jpg&#x27;</span>, <span class=\"string\">&#x27;new.jpg&#x27;</span>);  <span class=\"comment\">// Optional name</span></span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;isHTML(<span class=\"literal\">true</span>);  <span class=\"comment\">// Set email format to HTML</span></span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;Subject = <span class=\"string\">&#x27;Here is the subject&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;Body    = <span class=\"string\">&#x27;This is the HTML message body &lt;b&gt;in bold!&lt;/b&gt;&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable\">$mail</span>-&gt;AltBody = <span class=\"string\">&#x27;This is the body in plain text for non-HTML mail clients&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"variable\">$mail</span>-&gt;send()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Message could not be sent.&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Mailer Error: &#x27;</span> . <span class=\"variable\">$mail</span>-&gt;ErrorInfo;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Message has been sent&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 PHPMailer 文件夹下，新建一个 index.php 文件，复制粘贴以上代码，修改各项配置</p>\n<p><img src=\"/images/PHPMailer_6.png\"></p>\n<p>由于使用了 SSL 连接，所以需要开启PHP的 openssl 扩展，这里不再赘述，配置完之后，放在 Web 服务器下，访问 index.php，正常的话，就能收到一封测试邮件了，如果失败，可以根据报错信息进行排查。</p>\n<h2 id=\"最小化安装-推荐\"><a href=\"#最小化安装-推荐\" class=\"headerlink\" title=\"最小化安装(推荐)\"></a>最小化安装(推荐)</h2><p>直接把整个 PHPMailer 项目放到服务器上，未免太浪费空间，而且项目中的许多文件都是没用的，所以 README 文件中也提到了最小化安装</p>\n<p><img src=\"/images/PHPMailer_7.png\"></p>\n<p>文中提到 <strong>class.phpmailer.php</strong> 是必需的，另外的文件是可选的，因为我们使用的是 SMTP，所以还需要<strong>class.smtp.php</strong>，如果你使用了 POP3，则需要引入 <strong>class.pop3.php</strong>，新建一个 Mail 文件夹，导入以上两个文件，新建 index.html,send.php，文件结构如下:</p>\n<p><img src=\"/images/PHPMailer_8.png\"></p>\n<p>两个文件代码如下</p>\n<p>index.html </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>phpmailer Unit Test<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>phpmailer Unit Test<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">\t请你输入<span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">color</span>=<span class=\"string\">&quot;#FF6666&quot;</span>&gt;</span>收信<span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span>的邮箱地址:</span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;phpmailer&quot;</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;./send.php&quot;</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;post&quot;</span>&gt;</span></span><br><span class=\"line\">\t邮箱地址: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">size</span>=<span class=\"string\">&quot;50&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;address&quot;</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;发送&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>send.php</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">\t<span class=\"keyword\">require</span>(<span class=\"string\">&quot;class.phpmailer.php&quot;</span>);  <span class=\"comment\">//下载的文件必须放在该文件所在目录</span></span><br><span class=\"line\">\t<span class=\"keyword\">require</span>(<span class=\"string\">&quot;class.smtp.php&quot;</span>);</span><br><span class=\"line\">\t<span class=\"variable\">$mail</span> = <span class=\"keyword\">new</span> PHPMailer();  <span class=\"comment\">//建立邮件发送类</span></span><br><span class=\"line\">\t<span class=\"variable\">$address</span> = <span class=\"variable\">$_POST</span>[<span class=\"string\">&#x27;address&#x27;</span>];</span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;IsSMTP();  <span class=\"comment\">// 使用SMTP方式发送</span></span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;CharSet=<span class=\"string\">&#x27;UTF-8&#x27;</span>;  <span class=\"comment\">// 设置邮件的字符编码</span></span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;Host = <span class=\"string\">&quot;smtp.qq.com&quot;</span>;  <span class=\"comment\">// 您的企业邮局域名</span></span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;SMTPAuth = <span class=\"literal\">true</span>;  <span class=\"comment\">// 启用SMTP验证功能</span></span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;SMTPSecure = <span class=\"string\">&quot;ssl&quot;</span>;</span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;Port = <span class=\"string\">&quot;465&quot;</span>;  <span class=\"comment\">//SMTP端口</span></span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;Username = <span class=\"string\">&quot;xxx@qq.com&quot;</span>;  <span class=\"comment\">// 邮箱用户名(请填写完整的email地址)</span></span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;Password = <span class=\"string\">&quot;xxx&quot;</span>;  <span class=\"comment\">// 授权码</span></span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;From = <span class=\"string\">&quot;xxx@qq.com&quot;</span>;  <span class=\"comment\">//邮件发送者email地址</span></span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;FromName = <span class=\"string\">&quot;您的名称&quot;</span>;</span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;AddAddress(<span class=\"string\">&quot;<span class=\"subst\">$address</span>&quot;</span>, <span class=\"string\">&quot;&quot;</span>);  <span class=\"comment\">//收件人地址(&quot;收件人email&quot;,&quot;收件人姓名&quot;)</span></span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;AddReplyTo(<span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;AddAttachment(<span class=\"string\">&quot;/var/tmp/file.tar.gz&quot;</span>);   <span class=\"comment\">// 添加附件</span></span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;IsHTML(<span class=\"literal\">true</span>);   <span class=\"comment\">// set email format to HTML //是否使用HTML格式</span></span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;Subject = <span class=\"string\">&quot;PHPMailer测试邮件&quot;</span>;  <span class=\"comment\">//邮件标题</span></span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;Body = <span class=\"string\">&quot;Hello,这是测试邮件&quot;</span>;  <span class=\"comment\">//邮件内容</span></span><br><span class=\"line\">\t<span class=\"variable\">$mail</span>-&gt;AltBody = <span class=\"string\">&quot;This is the body in plain text for non-HTML mail clients&quot;</span>;  <span class=\"comment\">//附加信息</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!<span class=\"variable\">$mail</span>-&gt;Send())&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">echo</span> <span class=\"string\">&quot;邮件发送失败. &lt;p&gt;&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">echo</span> <span class=\"string\">&quot;错误原因: &quot;</span> . <span class=\"variable\">$mail</span>-&gt;ErrorInfo;</span><br><span class=\"line\">\t\t<span class=\"keyword\">exit</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">echo</span> <span class=\"string\">&quot;邮件发送成功&quot;</span>;</span><br><span class=\"line\">\t<span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>配置参数和上面的一样，不再赘述，之后点击 index.html 文件</p>\n<p><img src=\"/images/PHPMailer_9.png\"></p>\n<p>输入邮箱地址就可以啦</p>\n<p><img src=\"/images/PHPMailer_10.png\"></p>\n<p><img src=\"/images/PHPMailer_11.png\"></p>\n<p><strong>以上代码均为测试，若用于生产环境，可以对其进行封装</strong><br><strong>如有问题，欢迎回复交流</strong><br><br><br></p>\n","categories":["后端"],"tags":["PHP"]},{"title":"关于本博客","url":"https://zhouxelf.com/2017/01/05/关于本博客/","content":"<h1 id=\"关于本博客\"><a href=\"#关于本博客\" class=\"headerlink\" title=\"关于本博客\"></a>关于本博客</h1><p>想要搭建自己的个人博客也有一段时间了，之前考核做了个人博客，后来买空间，买域名，把例子也放了上去，但那个做的实在粗糙，拿不出手，放上去一段时间，就撤下来了。</p>\n<p>之前重写博客，但是没有做好规划，后端写了一部分，去写前端，发现页面写的太丑，对于一个追求完美的人来说，真的不能接受，如此，就搁置了一段时间。而且我搭建个人博客的初衷是记录自己的学习和生活，当然如果能对别人有一些帮助，那就更好了，一直在搭建博客上钻研，这就显得本末倒置了。</p>\n<p>后来几个小伙伴用 <strong>WordPress</strong> 搭建了博客，看着效果还不错，就去试用了一段时间，不过越用越感觉它太重了，很多的功能都用不到，我只是想安安静静的写博客啊。无奈，放弃。</p>\n<p>经常在网上搜索问题，也常看别人的博客，发现很多人的博客都放在 <strong>GitHub</strong> 上，效果很好，页面也很简洁。了解一下，知道了 <strong>GitHub Pages</strong>，顿时感觉这就是我想要的，马上摸索，又知道了博客搭建工具 <strong>Hexo</strong>， 然后很快搭建了自己的博客。</p>\n<p>使用 <strong>Hexo</strong> 最大的好处，就是你不用去关注太多东西，只需专注博客的内容就好了，简单配置下，就可以使用，而且不用像之前一样去买云服务器。如果感觉不喜欢 <strong>username.github.io</strong> ，买个逼格高的域名解析一下就行了。</p>\n<p>另外，<strong>Hexo</strong> 提供了很多主题，如果不喜欢，随时可以换。秉持着 <strong>Simple is the best</strong> 的原则，选择了现在的主题，喜欢的，可以在这里 <a href=\"https://github.com/forsigner/fexo\">forsigner</a> 找到主题原作者。 </p>\n<p>博客搭建完成了，以后的博客都会同步更新到这里，欢迎交流！<br><br><br></p>\n","categories":["随笔"],"tags":["随笔"]},{"title":"about","url":"https://zhouxelf.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"https://zhouxelf.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"https://zhouxelf.com/tag/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"https://zhouxelf.com/search/index.html","content":"","categories":[],"tags":[]}]